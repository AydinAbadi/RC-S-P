% !TEX root =R-zkCSP.tex


\subsection{PoRID Protocol}

In this section, we propose ``PoR with identifiable abort'' (PoRID) that is a concrete instantiation of $\text{VSID}_{\scriptscriptstyle\text{light}}$. It is built upon the PoR protocol, presented in the previous section and is in the same security model as $\text{VSID}_{\scriptscriptstyle\text{light}}$ is, i.e. either $\mathcal C$ or $\mathcal S$ can be malicious. In PoRID similar to $\text{VSID}_{\scriptscriptstyle\text{light}}$, $\mathcal C$ and $\mathcal S$ use a bulletin board to exchange signed messages.  In the protocol, at setup $\mathcal C$ encodes its file and generates public parameters and  metadata.  It posts the public parameters and metadata to the bulletin board and   sends the encoded file to $\mathcal S$ who runs a few lightweight checks to ensure the correctness of the public parameters and metadata. It agrees to serve, if it is convinced of their correctness. Later, when $\mathcal C$ wants to ensure the availability of its outsourced file, it  generates and posts a query  to the board.   $\mathcal S$  checks the correctness of the query, by performing a couple of highly efficient verifications. 

The server-side prove and client-side verify algorithms are similar to those in PoR with a difference that $\mathcal S$ posts the PoR proofs (i.e. output of prove algorithm) to the board. In  case of any dispute, $\mathcal C$ or $\mathcal S$ invokes the arbiter who, given the signed posted messages, checks the proofs  to identify a corrupt party. In particular,  it first checks the validity of the query (regardless of the party who invokes it). However, if  is invoked by  $\mathcal C$, it also checks  only one of the PoR proofs that the client claims it is invalid. Thus, it is much more efficient than $\text{VSID}_{\scriptscriptstyle\text{light}}$ as it does not need any zero-knowledge proofs (mainly due to the use of Merkle tree) and requires the  arbiter to check only one of the proofs (due  to the idea of proof of misbehaviour). PoRID protocol is presented below.






\begin{enumerate}
   
\item\textbf{Client-side Setup}. $\mathtt{PoRID.setup}(1^{\lambda}, u)$
\begin{enumerate}
\item Calls  $\mathtt{PoR.setup}(1^{\lambda}, u)\rightarrow (u^{\scriptscriptstyle *},pp)$, that results in public parameters $pp:=(\sigma,\beta,m,\zeta)$ and encoded file: $u^{\scriptscriptstyle *}=u^{\scriptscriptstyle '}_{\scriptscriptstyle 0}||0,...,u^{\scriptscriptstyle '}_{\scriptscriptstyle m}||m$. Recall,  $\zeta:=(\psi,\eta, \iota)$ is the $\mathtt{PRF}$'s description.

\item Posts $pp$ to the bulletin board and sends $u^{\scriptscriptstyle *}$ to $\mathcal{S}$ 
\end{enumerate}

\

\item\textbf{Server-side Setup}. $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *},pp)$
%\begin{enumerate}

Verifies the correctness of public parameters:
\begin{enumerate}
\item rebuilds  the Merkle tree on $u^{\scriptscriptstyle *}$ and checks the resulting root equals $\sigma$
\item checks $|u^{*}|=m$ and  $\beta\leq m$
\end{enumerate}
 If the proofs are accepted, then  it outputs $a = 1$ and proceeds to the next step; otherwise, it outputs $a = 0$ and halts.
 
 


\

\item\textbf{Client-side Query Generation}. $\mathtt{PoRID.genQuery}(1^{\lambda},  pp)$ 
\begin{enumerate}
\item Calls $\mathtt{PoR.genQuery}(1^{\lambda}, pp)\rightarrow \hat{k}$, to generate a key, $\hat{k}$ %whose element have been sorted 
\item Posts $\hat{k}$ to the board. 
\end{enumerate}


\

\item\textbf{Server-side Query Verification}. $\mathtt{PoRID.checkQuery}(\hat{k}, pp)$
\begin{enumerate}
\item  Checks if  $\hat{k}$ is not empty, i.e. $\hat{k}\neq \bot$, and is in the key's universe, i.e. $\hat{k}\in \{0,1\}^{\scriptscriptstyle\psi}$%If it is empty, then it outputs $I=\mathcal C$
\item  If the checks pass, then it outputs $b=1$; otherwise, it outputs $b=0$


\end{enumerate}


\

\item\textbf{Server-side Service Proof Generation}. $\mathtt{PoRID.prove}(u^{\scriptscriptstyle *},\hat{k},pp)$ 
\begin{enumerate}
\item Calls $\mathtt{PoR.prove}(u^{\scriptscriptstyle *},\hat{k},pp)\rightarrow  {\bm{\pi}}$, to generate proof vector: $ {\bm{\pi}}$ 
\item Posts $ {\bm{\pi}}$ to the board. 
\end{enumerate}

\

\item\textbf{Client-side Proof Verification}\label{PoRID::Client-side-Proof-Verification}. $\mathtt{PoRID.verify}( {\bm{\pi}},\hat{k} ,pp)$
%\begin{enumerate}

 Calls $\mathtt{PoR.verify}( {\bm{\pi}},\hat{k} ,pp)\rightarrow  {\bm{d}}$, to verify the proof. If $ {\bm{d}}[0] = 1$,  it accepts the proof; otherwise, it rejects it.


\

\item\textbf{Arbiter-side Identification}\label{PoRID::Arbiter-side-Identification}. $\mathtt{PoRID.identify}( {\bm{\pi}}, g,\hat{k},pp)$ 

This algorithm can be invoked by $\mathcal{C}$ or $\mathcal{S}$, in the case of dispute. If it is invoked by $\mathcal{C}$, then $g$ refers to a rejected proof's  index; however, if it is invoked by $\mathcal{S}$, then $g$ is null, i.e.  $g=\bot$. The arbiter performs as follows. 


\begin{enumerate}



\item Ensures  query $\hat{k}$ is well-structured by calling $\mathtt{PoRID.checkQuery}(\hat{k}, pp)$. If it returns $b=0$, then it outputs $I=\mathcal C$ and halts; otherwise, it proceeds to the next step. 




\item Derives the related challenged block's index from $\hat{k}$, by computing $q_{\scriptscriptstyle g}=\mathtt{PRF}(\hat{k},g)\bmod m+1$ 



\item If $g\neq \bot$, then verifies only $g$-th proof, by setting $\hat{\bm{\pi}}={\bm{\pi}}[g], \hat{\bm{q}}=q_{\scriptscriptstyle g}$ and then calling $\mathtt{PoR.verify}( \hat{\bm{\pi}},\hat{\bm{q}},pp)\rightarrow  {\bm{d}}'$. If $ {\bm{d}}'[0]=0$, then it outputs $I=\mathcal S$. Otherwise, it outputs $I=\bot$
\end{enumerate}
\end{enumerate}

\begin{theorem}
The PoRID protocol satisfies the $\epsilon$-soundness, inputs well-formedness, and detectable abort properties, w.r.t. Definitions \ref{extractable}, \ref{deff::VSID-Inputs-Well-formedess}, and \ref{def::VSID-Identifiable-Abort}, if PoR is $\epsilon$-sound and the  signature scheme is secure.
\end{theorem}


\begin{proof}[sketch]
The $\epsilon$-soundness of PoRID directly stems from the security of PoR scheme, i.e. $\epsilon$-soundness. Specifically,
in PoRID the (honest) client makes black-box calls to the algorithms of PoR, to ensure the soundness. The latter scheme's soundness ensures that an extractor can recover the entire file interacting with a corrupt server who passes  $\epsilon$ fraction of challenges. On the other hand, the inputs well-formedness holds for the following reasons. The metadata generation algorithm, i.e. the Merkle tree algorithm that builds a tree and computes a root, is deterministic and involves only public  parameters. Thus, given the tree's leaves (i.e. file blocks), its parameters, and the root, anyone can reconstruct it, check if it yields the same root, and verify the tree's parameters. Also, a query contains a single random key, $\hat{k}$, whose correctness can be checked deterministically, i.e. by checking $\hat{k}\neq \bot$ and  $\hat{k}\in \{0,1\}^{\scriptscriptstyle\psi}$. The detectable abort property holds as long as the soundness and inputs well-formedness hold and the signature scheme is secure. The reason is that algorithm $\mathtt{PoRID.identify}(.)$, which ensures detected abort, is a wrapper function that makes black-box calls to algorithms $\mathtt{PoRID.checkQuery}(.)$ and $\mathtt{PoR.verify}(.)$, where the former  ensures input (i.e. query) well-formedness, and the latter  ensures soundness.  Although the number of proofs that are passed to $\mathtt{PoR.verify}(.)$ in phase \ref{PoRID::Client-side-Proof-Verification}, differs from the number of proofs passed to the same algorithm in phase \ref{PoRID::Arbiter-side-Identification}, the difference does not affect the security, as due to the security of PoR (i.e.  Merkle tree) an invalid proof is detected with the same probability in both phases. The signatureâ€™s security ensures if a proof is not signed correctly, then it can also be rejected by the arbiter and the signer is held accountable for providing an ill-formed message; on the other hand, if a proof is signed correctly, then it cannot be repudiated by the signer later on that guarantees the signer is held accountable for a rejected proof it provides. 
\hfill\(\Box\)\end{proof}




