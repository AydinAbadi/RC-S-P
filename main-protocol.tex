% !TEX root =R-zkCSP.tex


\subsection{Recurring Contingent Service Payment (RC-S-P) Protocol}


%In this section, we present a generic ``recurring contingent service payment'' (R-CSP) protocol. It utilises a novel combination of $\text{VSID}_{\scriptscriptstyle\text{light}}$, SAP, and symmetric key encryption schemes along with the coin masking technique and the private time bubble notion. At a high level the protocol works as follows.  The  client and server use SAP to provably agree on (a) a secret key, $k$, for a symmetric key encryption and (b) a statement that includes payment details. They also  agree on (a) the private time bubble's length, that is the total number of billing cycles: $z$, plus a waiting period, $H$, and (b) a smart contract which  specifies $z$ and  the total amount of masked coins each party should deposit. They deploy the contract.  Each party deposits its masked coins in the contract. If the deposit amount is less than what is stated in the contract, each party has a chance to withdraw its coins and terminate the contract. To start using/providing the service, they invoke $\text{VSID}_{\scriptscriptstyle\text{light}}$ protocol. In particular, they engage in   $\mathtt{VSID.KeyGen}()$, $\mathtt{VSID.setup}()$, and $\mathtt{VSID.serve}()$ algorithms. If the server decides not to serve, e.g. it detects the client's misbehaviour,  it sends $0$  within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract. Otherwise, the server sends $1$ to the contract. 
 
 
 In this section, we present  ``recurring contingent service payment'' (RC-S-P) protocol for a generic service. It utilises a novel combination of $\text{VSID}_{\scriptscriptstyle\text{light}}$, SAP, the private time bubble notion, and symmetric key encryption schemes along with the coin masking and padding techniques. At a high level the protocol works as follows.  The  client and server use SAP to provably agree on two private statements; first statement includes  payment details, while another one specifies a secret key, $k$, and a pad's length. They also  agree on  public parameters such as (a) the private time bubble's length, that is the total number of billing cycles: $z$, plus a waiting period, $H$, and (b) a smart contract which  specifies $z$ and  the total amount of masked coins each party should deposit. They deploy the contract.  Each party deposits its masked coins in the contract. If either party does not deposit enough coins on time,   later each party has a chance to withdraw its coins and terminate the contract. To start using/providing the service, they invoke $\text{VSID}_{\scriptscriptstyle\text{light}}$ protocol. In particular, they engage in   $\mathtt{VSID.keyGen}()$, $\mathtt{VSID.setup}()$, and $\mathtt{VSID.serve}()$ algorithms. If the server decides not to serve, e.g. it detects the client's misbehaviour,  it sends $0$  within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract. Otherwise, the server sends $1$ to the contract. 
 
 
 
At the end of each billing cycle, the client generates an encrypted query, by calling $\mathtt{VSID.genQuery}()$ and encrypting its output using the key, $k$. It pads the encrypted query and  sends the result  to the contract. The encryption and pads ensure  nothing about the client's input (e.g. outsourced file) is revealed to the public within the private time bubble.  In the same cycle, the server retrieves the query, removes the pads and decrypts the result. Then, it locally checks its validity, by calling $\mathtt{VSID.checkQuery}()$. If the query is rejected, the server locally stores the index of the billing cycle and then  generates a dummy proof.  Otherwise, if the server accepts the query, it generates a proof of service by calling $\mathtt{VSID.prove}()$. In either case, the server encrypts the proof, pads it and sends the result to the contract. Note that sending (padded encrypted) dummy proof ensures that the public, during the private time bubble, does not learn if the client generates invalid queries. 

 After the server sends the messages to the contract, the client removes the pads, decrypts the proof and locally verifies it, by calling $\mathtt{VSID.verify}()$. If the verification is passed, then the client knows the server has delivered the service honestly. However, if the proof is rejected,  it waits until the private time bubble passes and dispute resolution time arrives. During the dispute resolution period, in the case the client or server  rejects any proofs, it sends a ``dispute'' message to the contract. The party also invokes the arbiter,  refers it to the invalid encrypted proofs in the contract, and  sends to it the decryption key and the pads' detail. The arbiter checks the validity of the key and pads, by using SAP. If they are accepted,  then the arbiter locally removes the pads from the encrypted proofs,   decrypts the related proofs, and runs $\mathtt{VSID.identify}()$ to check the validity of the party's claim. The arbiter sends to the contract a report of its findings that includes  the total number of times  the server and client provided invalid proofs. In the next phase, to distribute the coins, either client or server  sends: (a) ``pay'' message, (b) the agreed statement that specifies the payment details, and (c) the statement's proof to the contract which verifies the statement and if approved it distributes the coins according to the statement's detail, and the arbiter's report. 

Now we outline why RC-S-P addresses the issues.    In the setup, if the client provides ill-formed inputs (so later it can  accuse the server) then the server can detect and avoid serving it.  After the setup, if the client avoids sending any input,  then the server still gets paid for the service it provided. Also, in the case of a dispute between the parties, their claim is checked, and  the corrupt party is identified. The corrupt party has to pay the arbiter and if that is the client, then it has to pay the server as well.  These  features not only do guarantee the server's resource is not wasted, but also ensures fairness (i.e.  if a potentially malicious server is paid, then it must have provided the service and if a potentially malicious client does not pay, then it will learn nothing). Furthermore, as during the private time bubble  (a) no plaintext proof is given to the contract, and (b) no dispute resolution and coin transfer take place on contract, the public cannot figure out the outcome of each verification. This  preserves the server's privacy. Also, because the  deposited coins are masked and the agreed statement is kept private,   nothing about the detail of the service  is leaked to the public before the bubble bursts. This preserves the client's privacy. Moreover, as either party can prove to the contract the validity of the agreed statement, and ask the contract to distribute the coins, the coins will be not be locked forever. The RC-S-P protocol is presented below. It is assumed that (a) each party $\mathcal{R} \in\{\mathcal{C,S,A}r\}$ already has a blockchain public address which is known to all parties, (b) it uses that (authorised) address to send transactions to the smart contract, and (c) the contract   before recording a transaction, ensures the transaction is  originated from an authorised address.

\begin{enumerate}
\item \textbf{Key Generation}. $\mathtt{RCSP}.\mathtt{keyGen}(1^{\scriptscriptstyle\lambda}, F)$
\begin{enumerate}


\item  $\mathcal C$ runs  $\mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)$. It picks a random secret key  $\bar{k}$ for a symmetric key encryption. Also,  it sets two parameters: $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$, where  $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$  refer to the number of  dummy values that will be used to pad encrypted proofs and encrypted queries respectively\footnote{\scriptsize The values of  $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$ is determined as follows, $pad_{\scriptscriptstyle \pi}=\pi_{\scriptscriptstyle max}-\pi_{\scriptscriptstyle act}$ and $pad_{\scriptscriptstyle q}=q_{\scriptscriptstyle max}-q_{\scriptscriptstyle act}$, where $\pi_{\scriptscriptstyle max}$ and $\pi_{\scriptscriptstyle act}$ refer to the maximum and actual the service's proof size  while $q_{\scriptscriptstyle max}$ and $q_{\scriptscriptstyle act}$ refer to the maximum and actual the service's query size, respectively.},  determined by the security parameter and description of $F$.  Let $qp:=(pad_{\scriptscriptstyle \pi},pad_{\scriptscriptstyle q}, \bar{k})$. The keys' size is part of the security parameter.  Let  $\bm{k}=[k,K']$, where $K'$ contains $qp$. 
\end{enumerate}

\

\item \textbf{Client-side Initiation}. $\mathtt{RCSP}.\mathtt{cInit}(1^\lambda, u,\bm{k}, M,z,pl,enc)$
\begin{enumerate}

\item Calls  $\mathtt{VSID.setup}(1^{\lambda}, u,k,M)\rightarrow (u^{\scriptscriptstyle *},e)$, to encode  service input, and generate metadata. 



\item  Calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},qp )\rightarrow(r_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp}, adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}})$, to initiate an agreement (with $\mathcal{S}$) on $qp$.  Let $T_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp})$ be proof/query encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}:=(qp,r_{\scriptscriptstyle qp})$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 


\item   Sets coin parameters as   follows,   $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution, given  price list $pl$.  %It appends $o$ and $l$ to $k'$.




\item  Sets  $cp:=(o,o_{\scriptscriptstyle max},l,l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. Then, $\mathcal C$ calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},cp )\rightarrow(r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}})$, to initiate an agreement (with $\mathcal{S}$) on $cp$. Let $T_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}:=(cp,r_{\scriptscriptstyle cp})$ is the opening and $g_{\scriptscriptstyle cp}$ is the commitment stored on the contract as a result of executing   SAP.  





\item Set parameters  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $p_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal{S}}$ are   the total number of masked coins $\mathcal C$ and $\mathcal S$ should deposit respectively. $\mathcal C$ signs and deploys a smart contract, SC, that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$, $p_{\scriptscriptstyle\mathcal{S}}$,  $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}}$, and $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}}$. Let $adr_{\scriptscriptstyle \text{SC}}$ be the address of the deployed SC, and $T:=\{T_{\scriptscriptstyle qp},T_{\scriptscriptstyle cp}\}$. $\mathcal{C}$ sets a set of time points/windows, $\texttt{Time}:\{ \texttt{T}_{\scriptscriptstyle 0},..., \texttt{T}_{\scriptscriptstyle 3},\texttt{G}_{\scriptscriptstyle 1,1},...,\texttt{G}_{\scriptscriptstyle z,2},\texttt{H}, \texttt{K}_{\scriptscriptstyle 1},\texttt{K}_{\scriptscriptstyle 2}, \texttt{L}\}$, are explicitly specified in the contract who will accept a certain party's message only in a specified  time point/window. The time allocation will become clear in the next phases. 


\item Sets four counters $[y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}, y'_{\scriptscriptstyle\mathcal S}]$ in the contract, where their initial value is $0$. Let $\bm{y}: [y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}, y'_{\scriptscriptstyle\mathcal S}, \texttt{Time},adr_{\scriptscriptstyle \text{SC}}]$

\item Deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract.

\item Sends $u^{\scriptscriptstyle *}, e, \ddot{x}_{\scriptscriptstyle qp},\ddot{x}_{\scriptscriptstyle cp}$, and $p_{\scriptscriptstyle\mathcal{S}}$ (along with $adr_{\scriptscriptstyle \text{SC}}$) to $\mathcal S$. It sends  the public key's encryption: $pk^{\scriptscriptstyle *}=\mathtt{Enc}(\bar{k},pk)$ to SC. Let the above process finish at time $\texttt{T}_{\scriptscriptstyle 0}$. 





%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $qp$, $\mathcal C$ sends $qp$ to  $\mathcal S$.  Next (if the $\mathcal S$ agrees on the parameters) they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $t_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp})$ be proof/query encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 
%
%
%\item Let  $cp:=(o,o_{\scriptscriptstyle max},l,l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. For $\mathcal C$ and $\mathcal S$ to provably agree on $cp$, similar to the previous step, they invoke SAP again, at time $T_{\scriptscriptstyle 1}$.  Let $t_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}$ is the opening and $g_{\scriptscriptstyle cp}$ the commitment stored on the contract as a result of running the  SAP. 
%
%
%
%\item $\mathcal C$ set parameters  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ are   the total number of masked coins $\mathcal C$ and $\mathcal S$ should deposit respectively. $\mathcal C$ signs and deploys  smart contract SC that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. Moreover, it sets four counters $\bm{y}=[y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}, y'_{\scriptscriptstyle\mathcal S}]$ in the contract, where their initial value is $0$. It deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract.

% at time $T_{\scriptscriptstyle 2}$. $\mathcal S$ signs the contract too, if it agrees on the parameters.  

 

%\item $\mathcal C$ runs  $\mathtt{VSID.setup}(1^{\lambda}, u,k,M)\rightarrow (u^{\scriptscriptstyle *},e)$.  It sends  $e$ and $u^{\scriptscriptstyle *}$ to $\mathcal S$ and sends  the public key's encryption: $\mathtt{Enc}(\bar{k},pk)$ to SC at time $T_{\scriptscriptstyle 2}$.





%$\mathcal C$ and $\mathcal S$ respectively construct  vectors $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$ and $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  initially empty. 
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters,  $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution.  Also, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins the client and server will use  respectively. 








%\item $\mathcal C$ constructs  vector $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$, also $\mathcal S$  constructs $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty. 
%
%%$\mathcal C$ and $\mathcal S$ respectively construct  vectors $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$ and $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  initially empty. 
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters,  $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution.  Also, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins the client and server will use  respectively. 
%
%\item $\mathcal C$ and $\mathcal S$ construct  a statement of the  form: $x=(o,l,  f_{\scriptscriptstyle\mathcal C},f_{\scriptscriptstyle\mathcal S},z)$   
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $\mu$ be the statement's proof. 
%
%\item  $\mathcal C$ sends to $\mathcal S$ a statement of the form $x'=({pad}_{\scriptscriptstyle 1},{pad}_{\scriptscriptstyle 2},\bar{k})$ where  ${pad}_{\scriptscriptstyle 1}$ and ${pad}_{\scriptscriptstyle 2}$  refer to the number of  dummy values that will be used to pad encrypted queries and encrypted proofs respectively; and    $\bar{k}$ is a  secret key.
%
%
%
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x'$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 
%
%
%\item $\mathcal C$ and $\mathcal S$ agree on a smart contract: SC. Let $p_{\scriptscriptstyle\mathcal C}=z(o+l)+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ be   the total number of coins the client and server should deposit respectively. SC  explicitly specifies  parameters $z$,  $p_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}$. They sign and deploy the contract. 


% that specifies the total number of the service's proofs: $z$ and total amount of masked coins each party should deposit, i.e. the client and server should deposit $p_{\scriptscriptstyle\mathcal C}=z(o+l)+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ coins, respectively. They sign and deploy the contract. 

%\item $\mathcal C$ and $\mathcal S$ deposit their masked coins in SC at time $T_{\scriptscriptstyle 2}$
%\item At time $T_{\scriptscriptstyle 3}$, if the deposit amount that either party has put is less than the amount stated in SC, then SC allows each party to withdraw its coins and terminate the contract.

\end{enumerate}

\
\item \textbf{Server-side Initiation}\label{RCSP::Server-side-Initiation}. $\mathtt{RCSP}.\mathtt{sInit}(u^{\scriptscriptstyle *},e, pk^{\scriptscriptstyle *},z, T, p_{\scriptscriptstyle\mathcal{S}} ,\bm{y},enc)$

\begin{enumerate}

\item Checks the parameters  in $T$ (e.g. $qp$ and $cp$) and  in SC (e.g. $p_{\scriptscriptstyle\mathcal{S}}, \bm{y}$) and ensures sufficient amount of coins has been deposited by $\mathcal C$.  

\item Calls $\mathtt{SAP.agree}(qp,r_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{1}})\rightarrow (g'_{\scriptscriptstyle qp},b_{\scriptscriptstyle 1})$ and $\mathtt{SAP.agree}(cp,r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{2}})\rightarrow (g'_{\scriptscriptstyle cp},b_{\scriptscriptstyle 2})$, to verify the correctness of tokens in $T$ and to agree on the tokens' parameters, where $qp,r_{\scriptscriptstyle qp}\in \ddot{x}_{\scriptscriptstyle qp}, \text{and }  cp,r_{\scriptscriptstyle cp} \in  \ddot{x}_{\scriptscriptstyle cp}$. Recall that if both $\mathcal{C}$ and $\mathcal{S}$ are honest, then $g_{\scriptscriptstyle qp}=g'_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}=g'_{\scriptscriptstyle cp}$. 




\item If any above check is rejected, then it sets $a=0$. Otherwise, it decrypts the public key, $\mathtt{Dec}(\bar{k},pk^{\scriptscriptstyle *})=pk$; and then runs $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk)\rightarrow a$. 

\item Sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=p_{\scriptscriptstyle\mathcal{S}}$ coins to SC at time $\texttt{T}_{\scriptscriptstyle 1}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$
\end{enumerate}
Note, $\mathcal S$  and  $\mathcal C$ can withdraw their coins at time $\texttt{T}_{\scriptscriptstyle 2}$, if  $\mathcal S$ sends $a=0$, fewer coins than $p_{\scriptscriptstyle\mathcal{S}}$, or nothing to the SC. To withdraw, $\mathcal S$  or  $\mathcal C$  simply sends a ``pay'' message to $\mathtt{RCSP}.\mathtt{pay}(.)$ algorithm (only) at time $\texttt{T}_{\scriptscriptstyle 2}$.

\

\textbf{\textit{Billing-cycles Onset}}. $\mathcal{C}$ and $\mathcal{S}$ engage in the following three phases, i.e. phase \ref{Billing-cycles-genQuery}-\ref{Client-sideProofVerification},  at the end of every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $\texttt{G}_{\scriptscriptstyle j,1}$ and $\texttt{G}_{\scriptscriptstyle j,2}$, where $\texttt{G}_{\scriptscriptstyle j,2}>\texttt{G}_{\scriptscriptstyle j,1}$, and $\texttt{G}_{\scriptscriptstyle 1,1}>\texttt{T}_{\scriptscriptstyle 2}$ 

%At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 
%\item \textbf{Billing-cycles}. At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 



\

\item\textbf{Client-side Query Generation}.\label{Billing-cycles-genQuery} $\mathtt{RCSP}.\mathtt{genQuery}(1^\lambda, \text{aux},k,Q, T_{\scriptscriptstyle qp}, enc)$

\begin{enumerate}
\item Calls $\mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q)\rightarrow c_{\scriptscriptstyle j}:=(\bm{q}_{\scriptscriptstyle j},\bm{w}_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}})$, to generate a query-proof pair. 
\item Encrypts the pair, $\mathtt{Enc}(\bar{k},c_{\scriptscriptstyle j})=c'_{\scriptscriptstyle j}$. Then, it pads (each element of) the result with ${pad}_{\scriptscriptstyle q}\in T_{\scriptscriptstyle qp}$ random values that are picked from the encryption's output range, $U$. Let $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. 
\item Sends the padded encrypted query-proof pair, $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$
\end{enumerate}

\

\item\textbf{Server-side Proof Generation}. $\mathtt{RCSP}.\mathtt{prove}(u^{\scriptscriptstyle *},  \sigma,  c^{\scriptscriptstyle *}_{\scriptscriptstyle j},pk^{\scriptscriptstyle *}, T_{\scriptscriptstyle qp},enc)$


\begin{enumerate}

\item Constructs an empty  vector, $\bm{m}_{\scriptscriptstyle\mathcal S}=\bot$, if $j=1$.  
\item Removes the pads from $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, using  parameters of $T_{\scriptscriptstyle qp}$. Let  $c'_{\scriptscriptstyle j}$ be the result. Next, it  decrypts  the result, $\mathtt{Dec(}\bar{k},c'_{\scriptscriptstyle j})=c_{\scriptscriptstyle j}$. Then, using the decrypted public key, it   runs $\mathtt{VSID.checkQuery}(c_{\scriptscriptstyle j}, pk)\rightarrow b_{\scriptscriptstyle j}$, to check the correctness of the queries.

%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$. % or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.



%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$, or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.

\begin{itemize}
\item[$\bullet$] If $\mathcal S$ accepts the query, i.e. $b_{\scriptscriptstyle j}=1$, then  calls $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c_{\scriptscriptstyle j},pk)\rightarrow \pi_{\scriptscriptstyle j}$, to generate the service proof. In this case, $\mathcal S$ encrypts it, $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})=\pi'_{\scriptscriptstyle j}$. Next, it   pads (every element of) the encrypted proof with ${pad}_{\scriptscriptstyle \pi}\in T_{\scriptscriptstyle qp}$ random values  picked from $U$. Let $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. It sends the padded encrypted proof  to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ 

\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends  $j$  to $\bm{m}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $\pi'_{\scriptscriptstyle j}\in U$,  pads the result as above, and sends the padded dummy proof, $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ %, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$.

\end{itemize}
When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, $\mathcal S$ sets    $m_{\scriptscriptstyle\mathcal S}:=(\bm{m}_{\scriptscriptstyle\mathcal{S}},adr_{\scriptscriptstyle \text{SC}})$.

\end{enumerate}

\

\item \textbf{Client-side Proof Verification}.\label{Client-sideProofVerification} $\mathtt{RCSP}.\mathtt{verify}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k,T_{\scriptscriptstyle qp},enc)$
\begin{enumerate}


\item Constructs an empty vector, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$, if $j=1$. 

\item Removes the pads from $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, utilising  parameters of $T_{\scriptscriptstyle qp}$. Let $\pi'_{\scriptscriptstyle j}$ be the result. It decrypts the service proof: $\mathtt{Dec}(\bar{k},\pi'_{\scriptscriptstyle j})=\pi''_{\scriptscriptstyle j}$ and then calls $\mathtt{VSID.verify}(\pi''_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k)\rightarrow d_{\scriptscriptstyle j}$, to verify the proof. Note that if $\pi'_{\scriptscriptstyle j}=\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})$, then $\pi''_{\scriptscriptstyle j}=\pi_{\scriptscriptstyle j}$. 

\begin{itemize}
\item[$\bullet$] If $\pi''_{\scriptscriptstyle j}$ passes the verification (i.e. $d_{\scriptscriptstyle j}=1$), then $\mathcal C$ concludes that the service  for this verification has been delivered successfully. 

\item[$\bullet$]  Otherwise (when $\pi''_{\scriptscriptstyle j}$ is rejected), $\mathcal C$ appends $j$  to $\bm{m}_{\scriptscriptstyle\mathcal{C}}$. 


\end{itemize}
When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    ${m}_{\scriptscriptstyle\mathcal C}:=(\bm{m}_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle \text{SC}},e')$, where  $e'$  contains the opening of $\mathtt{Com}_{\scriptscriptstyle sk}$ or  $\bot$ as stated in Remark \ref{remark::light-VSID}.


\end{enumerate}

\

\item \textbf{Dispute Resolution}.\label{RCSP::Dispute-Resolution} $\mathtt{RCSP}.\mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}},z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{c}}^{\scriptscriptstyle *},pk^{\scriptscriptstyle*}, T_{\scriptscriptstyle qp},enc)$



 The phase takes place only in  case of dispute, e.g. when $\mathcal C$ and/or $\mathcal S$ reject any proofs in the previous phases. %or  either party does not receive its counterparty's message on time. %A party who accepts all proofs does not need to get involved in this phase. 

\begin{enumerate}
%\item $\mathcal C$ and/or $\mathcal S$ at time $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$ sends ``dispute'' message to the contract. 


\item The arbiter sets  counters: $y_{\scriptscriptstyle\mathcal C}, y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}$ and  $y'_{\scriptscriptstyle\mathcal S}$ and a vector: $\bm{des}$, that are initially set to $0$,  before time $\texttt{K}_{\scriptscriptstyle 1}$,  where $\texttt{K}_{\scriptscriptstyle 1}>\texttt{G}_{\scriptscriptstyle z,2}+\texttt{H}$. 
\item $\mathcal C$  sends $m_{\scriptscriptstyle\mathcal C}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter at time $\texttt{K}_{\scriptscriptstyle 1}$. Also,  $\mathcal S$ sends $m_{\scriptscriptstyle\mathcal S}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter at time $\texttt{K}_{\scriptscriptstyle 1}$ %,   where $|\vv{\bm{v}}_{\scriptscriptstyle\mathcal{C}}|\neq 0$ and $|\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}|\neq 0$. 

%\item The arbiter ensures they have already reached an agreement by checking $a=1$ and the server deposit equals the amount the client suggested, i.e. $a=0$ and $coins^{*}_{\scriptscriptstyle\mathcal{S}}=p_{\scriptscriptstyle\mathcal{S}}$. Otherwise, the arbiter halts.  

\item\label{arbiter-checks-statement} The arbiter checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$ sent by each party  $\forall \mathcal R\in \{\mathcal {C,S}\}$. To  do so, it sends  each $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. The arbiter  constructs an empty vector: $\bm{v}$.  If  party $\mathcal R$'s statement is accepted, then 
 it appends every  element of $\bm{m}_{\scriptscriptstyle\mathcal{R}}$ to $\bm{v}$ and $\bm{des}$,  if that element is not already in $\bm{des}$. Also, it ensures $\bm{v}$ contains only distinct elements which are in the range $[1,z]$. Otherwise (if the party's statement is rejected) it discards the party's request, ${m}_{\scriptscriptstyle\mathcal{R}}$. It proceeds to the next step if $\bm{v}$ is not empty, otherwise it halts. 
 %, and increments $ y'_{\scriptscriptstyle\mathcal R}$ by 1

%\item The Arbiter, for each party, checks the validity of $k$ by sending $k$ and $\mu'$ to SAP contract which  returns  either $1$ or $0$. The arbiter proceeds to the next step if the output is 1; otherwise, it does nothing. 
%\item The Arbiter decrypts those proofs and challenges whose index are in $\vv{\bm{v}}$. In particular,  $\forall i\in \vv{\bm{v}}: \mathtt{Dec}(\bar{k},\mathtt{Enc}(c_{\scriptscriptstyle i}))=c_{\scriptscriptstyle i}$ and $ \mathtt{Dec}(\bar{k},\mathtt{Enc}(\pi_{\scriptscriptstyle i}))=\pi_{\scriptscriptstyle i}$

\item The arbiter uses $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key that was sent to SC, $\mathtt{Dec}(\bar{k},pk^{\scriptscriptstyle *})=pk$



\item\label{the-arbiter-loop} The arbiter  for every element $i\in\bm{v}$:

\begin{enumerate}
%\item Checks if $\mathcal C$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery}. If the check fails, it increments $u_{\scriptscriptstyle\mathcal C}$ by $1$ and retakes step \ref{the-arbiter-loop} with the next element of $\vv{\bm{v}}$. Otherwise, it proceeds to the next step. 

%\item Checks if $\mathcal S$  sent to SC an encrypted proof on time, in step \ref{Billing-cycles-sendProof}. If the check fails, it increments $u_{\scriptscriptstyle\mathcal S}$ by $1$ and retakes step \ref{the-arbiter-loop} with the next element of $\vv{\bm{v}}$. Otherwise, it proceeds to the next step. 
\item removes the pads from the related encrypted    query-proof pair  and from encrypted service proof. Let $c'_{\scriptscriptstyle i}$ and $\pi'_{\scriptscriptstyle i}$ be the result. %unpadded encrypted  query-proof pair  and encrypted service proof  respectively. 
\item decrypts the encrypted query-proof pair and encrypted service proof as follows, $ \mathtt{Dec}(\bar{k},c'_{\scriptscriptstyle i})=c_{\scriptscriptstyle i}$ and 
$ \mathtt{Dec}(\bar{k},\pi'_{\scriptscriptstyle i})=\pi''_{\scriptscriptstyle i}$ 
\item\label{arbiter-identify} calls   $\mathtt{VSID.identify}(\pi''_{\scriptscriptstyle i},c_{\scriptscriptstyle i},pk,e')\rightarrow I_{\scriptscriptstyle i}$
\begin{enumerate}
\item[$\bullet$] if $I_{\scriptscriptstyle i}=\mathcal C$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by $1$ 
\item[$\bullet$]  if $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$ by $1$ 
\item[$\bullet$]  if $I_{\scriptscriptstyle i}=\bot$, then it increments  $y'_{\scriptscriptstyle\mathcal C}$ or $y'_{\scriptscriptstyle\mathcal S}$ by $1$, if the arbiter is invoked by  $\mathcal {C}$ or $\mathcal {S}$ respectively. 
\end{enumerate}
\end{enumerate}

%\item The Arbiter for every  $i\in\vv{\bm{v}}$ calls   $\mathtt{VSID.identify}(\pi_{\scriptscriptstyle i},c_{\scriptscriptstyle i},pk,e')\rightarrow I_{\scriptscriptstyle i}$, to resolve the dispute. 
%
%
%
%
%Let $u_{\scriptscriptstyle\mathcal C}$ and $u_{\scriptscriptstyle\mathcal S}$  be the total number of times $\mathtt{VSID.identify}()$ returns $\mathcal{C}$ and $\mathcal{S}$ respectively.  Also, let $y_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal S}$ be the total number of times $\mathtt{VSID.identify}()$ returns $\bot$ when it is invoked by the client and server  respectively. 
Let $\texttt{K}_{\scriptscriptstyle 2}$ be the time that the arbiter finishes the above checks.

\item The arbiter sends $\bm{y}:[y_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S}]$  to SC at time $\texttt{K}_{\scriptscriptstyle 2}$
\end{enumerate}

\

\item \textbf{Coin Transfer}\label{RCSP::CoinTransfer}. $\mathtt{RCSP}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})$
\begin{enumerate}
 
 \item If SC  receives  ``pay'' message only at time $\texttt{T}_{2}$, such that $a=0$ or $coins^{*}_{\scriptscriptstyle\mathcal{S}}<p_{\scriptscriptstyle\mathcal{S}}$, then it sends $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins to $\mathcal C$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$. In other words, the parties can withdraw their coins if they do not reach an agreement at the end of   phase \ref{RCSP::Server-side-Initiation}, i.e. server-side initiation.  Else (i.e. they reach an agreement), they take the following step. 

\item Either $\mathcal C$ or $\mathcal S$ send ``pay'' message and the statement, $\ddot{x}_{\scriptscriptstyle cp}\in T_{\scriptscriptstyle cp}$,  to SC at time $\texttt{L}>\texttt{K}_{\scriptscriptstyle 2}$
\item SC checks the validity of the statement by sending $\ddot{x}_{\scriptscriptstyle cp}$ to SAP contract which  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$. 
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$ coins  to $\mathcal C$
\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$
\item[$\bullet$] $l(y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal C})$ coins to the arbiter.  
\end{itemize}

\end{enumerate}
\end{enumerate}



\begin{remark} If all parties behave honestly,   then the server receives all its deposit back plus the amount of coins they initially agreed to pay the sever if it  delivers accepting proofs for all $z$ cycles, i.e. in total it receives $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o\cdot z$ coins. Also, in this case an honest client receives all coins minus the amount of coins paid to the server for delivering accepting proofs for $z$ cycles, i.e. in total it receives $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o\cdot z$ coins. However, the arbiter receives no coins, as it is never invoked. 
\end{remark}

\begin{remark} As stated in Section \ref{sec::RC-S-P-Definition},   algorithms $\mathtt{RCSP}.\mathtt{genQuery}(.),\mathtt{RCSP}.\mathtt{prove}(.),\mathtt{RCSP}.\mathtt{verify}(.)$ and $\mathtt{RCSP}.\mathtt{resolve}(.)$ implicitly  take $a, coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal{S}}, p_{\scriptscriptstyle\mathcal{S}}$ as another inputs and  execute only if $a=1$ and $coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal{S}}=p_{\scriptscriptstyle\mathcal{S}}$. For the sake of simplicity we  avoided explicitly stating it in the protocol.   
\end{remark}

\begin{remark}
Keeping track of  $(y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S})$ enables the arbiter to make malicious parties, who \emph{unnecessarily} invoke  it for  accepting proofs in step \ref{arbiter-identify}, pay  for the verifications it performs. 
\end{remark}


%\begin{remark}
%Keeping track of  $(y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S})$ enables the arbiter to make malicious parties, who \emph{unnecessarily} invoke  it for invalid statement in step \ref{arbiter-checks-statement} or  accepting proofs in step \ref{arbiter-identify}, pay  for the verifications it performs. 
%\end{remark}

%\begin{remark}
%If the client or server  receives no input from its counter-party, it still needs to invoke the arbiter, so that party can be paid (back) fairly. 
%\end{remark}





\begin{remark} The VSID scheme  does not (need to) preserve the privacy of the proofs. However, in RC-S-P  protocol  each proof's privacy must be preserved, for a certain time; otherwise, the proof itself can leak its status, e.g. when it can be publicly verified. This is the reason in RC-S-P protocol,  \emph{encrypted} proofs are sent to the contract.   
\end{remark}


\begin{remark}
For the sake of simplicity, in the above protocol, we assumed that each arbiter's invocation has a fixed  cost regardless of the number of steps it takes. To define a fine grained costing, one can simply allocate to each step the arbiter takes a certain rate and also separate counter  for the client and server.  
\end{remark}

\begin{remark}
In the case where $\mathtt{VSID.verify}()$ is privately verifiable and    the server invokes the arbiter, the client needs to provide inputs to the arbiter too. Otherwise (when it is publicly verifiable and  the server invokes the arbiter), the client's involvement is not required in the dispute resolution phase.  In contrast, if the client invokes the arbiter, the server's involvement is not required in that phase, regardless of the type of verifiability $\mathtt{VSID.verify}()$ supports. 
\end{remark}

\begin{theorem}
The RC-S-P protocol is secure, w.r.t. Definition \ref{def::RC-S-P-Security}, if VSID and SAP are secure and the encryption scheme is semantically secure. 
\end{theorem}



 To prove the above theorem, we show that RC-S-P meets all security properties defined in Section \ref{sec::RC-S-P-Definition}.  We start by proving that RC-S-P satisfies security against a malicious server.  
 
 \input{RCSP-Proof}
 
 
\subsection{Reducing the Arbiter involvement}

{\color{blue}Explain how we can use the smart contracts of \cite{DongWAMM17} to delegate the arbiter task to smart contracts. In this case, only if the smart contracts do not reach a consensus the arbiter is involved. }
\input{PoR-protocol}




