% !TEX root =R-zkCSP.tex


\subsection{Recurring Contingent Service Payment (RC-S-P) Protocol}


%In this section, we present a generic ``recurring contingent service payment'' (R-CSP) protocol. It utilises a novel combination of $\text{VSID}_{\scriptscriptstyle\text{light}}$, SAP, and symmetric key encryption schemes along with the coin masking technique and the private time bubble notion. At a high level the protocol works as follows.  The  client and server use SAP to provably agree on (a) a secret key, $k$, for a symmetric key encryption and (b) a statement that includes payment details. They also  agree on (a) the private time bubble's length, that is the total number of billing cycles: $z$, plus a waiting period, $H$, and (b) a smart contract which  specifies $z$ and  the total amount of masked coins each party should deposit. They deploy the contract.  Each party deposits its masked coins in the contract. If the deposit amount is less than what is stated in the contract, each party has a chance to withdraw its coins and terminate the contract. To start using/providing the service, they invoke $\text{VSID}_{\scriptscriptstyle\text{light}}$ protocol. In particular, they engage in   $\mathtt{VSID.KeyGen}()$, $\mathtt{VSID.setup}()$, and $\mathtt{VSID.serve}()$ algorithms. If the server decides not to serve, e.g. it detects the client's misbehaviour,  it sends $0$  within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract. Otherwise, the server sends $1$ to the contract. 
 
 
 In this section, we present  ``recurring contingent service payment'' (RC-S-P) protocol for a generic service. It utilises a novel combination of $\text{VSID}_{\scriptscriptstyle\text{light}}$, SAP, the private time bubble notion, and symmetric key encryption schemes along with the coin masking and padding techniques. At a high level the protocol works as follows.  The  client and server use SAP to provably agree on two private statements; first statement includes  payment details, while another one specifies a secret key, $k$, and a pad's length. They also  agree on  public parameters such as (a) the private time bubble's length, that is the total number of billing cycles: $z$, plus a waiting period, $H$, and (b) a smart contract which  specifies $z$ and  the total amount of masked coins each party should deposit. They deploy the contract.  Each party deposits its masked coins in the contract. If either party does not deposit enough coins on time,   later each party has a chance to withdraw its coins and terminate the contract. To start using/providing the service, they invoke $\text{VSID}_{\scriptscriptstyle\text{light}}$ protocol. In particular, they engage in   $\mathtt{VSID.keyGen}()$, $\mathtt{VSID.setup}()$, and $\mathtt{VSID.serve}()$ algorithms. If the server decides not to serve, e.g. it detects the client's misbehaviour,  it sends $0$  within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract. Otherwise, the server sends $1$ to the contract. 
 
 
 
At the end of each billing cycle, the client generates an encrypted query, by calling $\mathtt{VSID.genQuery}()$ and encrypting its output using the key, $k$. It pads the encrypted query and  sends the result  to the contract. The encryption and pads ensure  nothing about the client's input (e.g. outsourced file) is revealed to the public within the private time bubble.  In the same cycle, the server retrieves the query, removes the pads and decrypts the result. Then, it locally checks its validity, by calling $\mathtt{VSID.checkQuery}()$. If the query is rejected, the server locally stores the index of the billing cycle and then  generates a dummy proof.  Otherwise, if the server accepts the query, it generates a proof of service by calling $\mathtt{VSID.prove}()$. In either case, the server encrypts the proof, pads it and sends the result to the contract. Note that sending (padded encrypted) dummy proof ensures that the public, during the private time bubble, does not learn if the client generates invalid queries. 

 After the server sends the messages to the contract, the client removes the pads, decrypts the proof and locally verifies it, by calling $\mathtt{VSID.verify}()$. If the verification is passed, then the client knows the server has delivered the service honestly. However, if the proof is rejected,  it waits until the private time bubble passes and dispute resolution time arrives. During the dispute resolution period, in the case the client or server  rejects any proofs, it sends a ``dispute'' message to the contract. The party also invokes the arbiter,  refers it to the invalid encrypted proofs in the contract, and  sends to it the decryption key and the pads' detail. The arbiter checks the validity of the key and pads, by using SAP. If they are accepted,  then the arbiter locally removes the pads from the encrypted proofs,   decrypts the related proofs, and runs $\mathtt{VSID.identify}()$ to check the validity of the party's claim. The arbiter sends to the contract a report of its findings that includes,  the total number of times  the server and client provided invalid proofs and the total number of times each of them raised disputes on accepting proofs. In the next phase, to distribute the coins, either client or server  sends: (a) ``pay'' message, (b) the agreed statement that specifies the payment details, and (c) the statement's proof to the contract which verifies the statement and if approved it distributes the coins according to the statement's detail, and the arbiter's report. 

Now we outline why RC-S-P addresses the issues.    In the setup, if the client provides ill-formed inputs (so later it can  accuse the server) then the server can detect and avoid serving it.  After the setup, if the client avoids sending any input,  then the server still gets paid for the service it provided. Also, in the case of a dispute between the parties, their claim is checked, and  the corrupt party is identified. The corrupt party has to pay the arbiter and if that is the client, then it has to pay the server as well.  These  features not only do guarantee the server's resource is not wasted, but also ensures fairness (i.e.  if a potentially malicious server is paid, then it must have provided the service and if a potentially malicious client does not pay, then it will learn nothing). Furthermore, as during the private time bubble  (a) no plaintext proof is given to the contract, and (b) no dispute resolution and coin transfer take place on contract, the public cannot figure out the outcome of each verification. This  preserves the server's privacy. Also, because the  deposited coins are masked and the agreed statement is kept private,   nothing about the detail of the service  is leaked to the public before the bubble bursts. This preserves the client's privacy. Moreover, as either party can prove to the contract the validity of the agreed statement, and ask the contract to distribute the coins, the coins will be not be locked forever. The RC-S-P protocol is presented below. It is assumed that (a) each party $\mathcal{R} \in\{\mathcal{C,S,A}r\}$ already has a blockchain public address which is known to all parties, (b) it uses that (authorised) address to send transactions to the smart contract, and (c) the contract   before recording a transaction, ensures the transaction is  originated from an authorised address.

\begin{enumerate}
\item \textbf{Key Generation}. 
\begin{enumerate}


\item  $\mathcal C$ runs  $\mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:(sk,pk)$. It picks a random secret key  $\bar{k}$ for a symmetric key encryption. Also, it sets two parameters: $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$, where  $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$  refer to the number of  dummy values that will be used to pad encrypted proofs and encrypted queries respectively \footnote{\scriptsize The values of  $pad_{\scriptscriptstyle \pi}$ and $pad_{\scriptscriptstyle q}$ is determined as follows, $pad_{\scriptscriptstyle \pi}=\pi_{\scriptscriptstyle max}-\pi_{\scriptscriptstyle act}$ and $pad_{\scriptscriptstyle q}=q_{\scriptscriptstyle max}-q_{\scriptscriptstyle act}$, where $\pi_{\scriptscriptstyle max}$ and $\pi_{\scriptscriptstyle act}$ refer to the maximum and actual proof size  while $q_{\scriptscriptstyle max}$ and $q_{\scriptscriptstyle act}$ refer to the maximum and actual query size, respectively.}.  Let $qp:=(pad_{\scriptscriptstyle \pi},pad_{\scriptscriptstyle q}, \bar{k})$. The keys' size is part of the security parameter. 


\item  $\mathcal C$ sets coin parameters as   follows,   $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution.    Let $k':\{o,l,qp\}$ and  let $\bm{k}=[k,k']$. 


\end{enumerate}
\item \textbf{Initiation}. 
\begin{enumerate}
\item For $\mathcal C$ and $\mathcal S$ to provably agree on $qp$, $\mathcal C$ sends $qp$ to  $\mathcal S$.  Next (if the $\mathcal S$ agrees on the parameters) they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $t_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp})$ be proof/query encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 


\item Let  $cp:=(o,o_{\scriptscriptstyle max},l,l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. For $\mathcal C$ and $\mathcal S$ to provably agree on $cp$, similar to the previous step, they invoke SAP again, at time $T_{\scriptscriptstyle 1}$.  Let $t_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}$ is the opening and $g_{\scriptscriptstyle cp}$ the commitment stored on the contract as a result of running the  SAP. 



\item $\mathcal C$ set parameters  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ are   the total number of masked coins $\mathcal C$ and $\mathcal S$ should deposit respectively. $\mathcal C$ signs and deploys  smart contract SC that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. It deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract.

% at time $T_{\scriptscriptstyle 2}$. $\mathcal S$ signs the contract too, if it agrees on the parameters.  

\item $\mathcal C$ constructs  vector $\bm{v}_{\scriptscriptstyle\mathcal C}$, also $\mathcal S$  constructs $\bm{v}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty. 

\item $\mathcal C$ runs  $\mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:(sk,pk)$ and
$\mathtt{VSID.setup}(1^{\lambda}, u,k,M)\rightarrow (u^{\scriptscriptstyle *},e)$.  It sends  $e$ and $u^{\scriptscriptstyle *}$ to $\mathcal S$ and sends  the public key's encryption: $\mathtt{Enc}(\bar{k},pk)$ to SC at time $T_{\scriptscriptstyle 2}$.





%$\mathcal C$ and $\mathcal S$ respectively construct  vectors $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$ and $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  initially empty. 
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters,  $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution.  Also, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins the client and server will use  respectively. 








%\item $\mathcal C$ constructs  vector $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$, also $\mathcal S$  constructs $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty. 
%
%%$\mathcal C$ and $\mathcal S$ respectively construct  vectors $\vv{\bm{v}}_{\scriptscriptstyle\mathcal C}$ and $\vv{\bm{v}}_{\scriptscriptstyle\mathcal S}$,  initially empty. 
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters,  $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, and $l$: the amount of coins  to cover the cost of each potential dispute resolution.  Also, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins the client and server will use  respectively. 
%
%\item $\mathcal C$ and $\mathcal S$ construct  a statement of the  form: $x=(o,l,  f_{\scriptscriptstyle\mathcal C},f_{\scriptscriptstyle\mathcal S},z)$   
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $\mu$ be the statement's proof. 
%
%\item  $\mathcal C$ sends to $\mathcal S$ a statement of the form $x'=({pad}_{\scriptscriptstyle 1},{pad}_{\scriptscriptstyle 2},\bar{k})$ where  ${pad}_{\scriptscriptstyle 1}$ and ${pad}_{\scriptscriptstyle 2}$  refer to the number of  dummy values that will be used to pad encrypted queries and encrypted proofs respectively; and    $\bar{k}$ is a  secret key.
%
%
%
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x'$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 
%
%
%\item $\mathcal C$ and $\mathcal S$ agree on a smart contract: SC. Let $p_{\scriptscriptstyle\mathcal C}=z(o+l)+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ be   the total number of coins the client and server should deposit respectively. SC  explicitly specifies  parameters $z$,  $p_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}$. They sign and deploy the contract. 


% that specifies the total number of the service's proofs: $z$ and total amount of masked coins each party should deposit, i.e. the client and server should deposit $p_{\scriptscriptstyle\mathcal C}=z(o+l)+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ coins, respectively. They sign and deploy the contract. 

%\item $\mathcal C$ and $\mathcal S$ deposit their masked coins in SC at time $T_{\scriptscriptstyle 2}$
%\item At time $T_{\scriptscriptstyle 3}$, if the deposit amount that either party has put is less than the amount stated in SC, then SC allows each party to withdraw its coins and terminate the contract.



\item $\mathcal S$ checks the above parameters, and ensures sufficient amount of coins has been deposited.  If any check is rejected, then it sets $a=0$. Otherwise, it decrypts the public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$. It runs $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk)\rightarrow a$. Next, it sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to SC at time $T_{\scriptscriptstyle 3}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$

\item $\mathcal C$  and  $\mathcal S$ can withdraw their coins at time $T_{\scriptscriptstyle 4}$, if the server sends $a=0$, fewer coins than $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$, or nothing to the SC 

\end{enumerate}
\item \textbf{Billing-cycles}. The parties perform as follows at the end of  every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $G_{\scriptscriptstyle j,1}$ and $G_{\scriptscriptstyle j,2}$, where $G_{\scriptscriptstyle j,2}>G_{\scriptscriptstyle j,1}$, and $G_{\scriptscriptstyle 1,1}>T_{\scriptscriptstyle 4}$ 

%At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 
%\item \textbf{Billing-cycles}. At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 
\begin{enumerate}

\item\label{Billing-cycles-genQuery} To generate a query-proof pair, $\mathcal C$  calls $\mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q)\rightarrow c_{\scriptscriptstyle j}$. It encrypts the pair, $\mathtt{Enc}(\bar{k},c_{\scriptscriptstyle j})=c'_{\scriptscriptstyle j}$. Then, it pads the result with ${pad}_{\scriptscriptstyle q}$ random values that are picked from the encryption's output range, $U$. It sends the padded encrypted query-proof pair to SC at time $G_{\scriptscriptstyle j,1}$ 

%It sends the outputs' encryption: $\mathtt{Enc}(\bar{k},c_{\scriptscriptstyle j})$, to SC at time $G_{\scriptscriptstyle j,1}$ 



\item In this phase, $\mathcal S$ generates a service proof. To do so, it  constructs two empty  vectors, $\bm{m}_{\scriptscriptstyle\mathcal S}=\bot$ and $\bm{v}_{\scriptscriptstyle\mathcal{S}}=\bot$.  It also  removes the pads from the padded encrypted query-proof pair. Let  $c'_{\scriptscriptstyle j}$ be the result. Next, it  decrypts  the result, $\mathtt{Dec(}\bar{k},c'_{\scriptscriptstyle j})=c_{\scriptscriptstyle j}$. Then, it   calls $\mathtt{VSID.checkQuery}(c_{\scriptscriptstyle j}, pk)\rightarrow b_{\scriptscriptstyle j}$, to check the correctness of the queries.

%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$. % or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.



%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$, or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.

\begin{itemize}
\item[$\bullet$] If $\mathcal S$ accepts the query, i.e. $b_{\scriptscriptstyle j}=1$, then it calls $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c_{\scriptscriptstyle j},pk)\rightarrow \pi_{\scriptscriptstyle j}$, to generate the service proof. In this case, $\mathcal S$ encrypts the proof, $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})=\pi'_{\scriptscriptstyle j}$. Next, it   pads the encrypted proof with ${pad}_{\scriptscriptstyle \pi}$ random values that are picked from $U$. It sends the padded encrypted proof  to SC at time $G_{\scriptscriptstyle j,2}$ 

\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $\bm{v}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $\pi'_{\scriptscriptstyle j}\in U$,  pads the result as above, and sends the padded dummy proof to SC at time $G_{\scriptscriptstyle j,2}$ %, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$.


\end{itemize}
When $j=z$  and $\bm{v}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, $\mathcal S$ sets    $\bm{m}_{\scriptscriptstyle\mathcal S}:[\bm{v}_{\scriptscriptstyle\mathcal{S}},\ddot{x}_{\scriptscriptstyle qp}, \text{``dispute''}]$.
%\item\label{Billing-cycles-sendProof} $\mathcal S$ sends the proof's encryption: $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})$, to SC at time $G_{\scriptscriptstyle j,2}$

\item In this phase,  $\mathcal C$ verifies the service proof. It first constructs two empty vectors, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$ and $\bm{v}_{\scriptscriptstyle\mathcal{C}}=\bot$. Then, it  removes the pads from the padded encrypted proof. Let $\pi'_{\scriptscriptstyle j}$ be the result. It decrypts the service proof: $\mathtt{Dec}(\bar{k},\pi'_{\scriptscriptstyle j})=\pi''_{\scriptscriptstyle j}$ and then calls $\mathtt{VSID.verify}(\pi''_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k)\rightarrow d_{\scriptscriptstyle j}$, to verify the proof. Note that if $\pi'_{\scriptscriptstyle j}=\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})$, then $\pi''_{\scriptscriptstyle j}=\pi_{\scriptscriptstyle j}$. If $\pi''_{\scriptscriptstyle j}$ passes the verification (i.e. $d_{\scriptscriptstyle j}=1$), then $\mathcal C$ concludes that the service  for this verification has been delivered successfully. Otherwise (when $\pi''_{\scriptscriptstyle j}$ is rejected), $\mathcal C$ appends $j$  to $\bm{v}_{\scriptscriptstyle\mathcal{C}}$. If $j=z$  and $\bm{v}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    $\bm{m}_{\scriptscriptstyle\mathcal C}:[\bm{v}_{\scriptscriptstyle\mathcal{C}},\ddot{x}_{\scriptscriptstyle qp},e', \text{``dispute''}]$, where (as stated in Remark \ref{remark::light-VSID}) $e'$  contains the opening of $\mathtt{Com}_{\scriptscriptstyle sk}$ or  $\bot$.

%$\mathcal C$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{C}}$, if $\pi''_{\scriptscriptstyle j}$ is rejected, i.e. $d_{\scriptscriptstyle j}=0$
%\item $\mathcal C$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{C}}$, if $\pi_{\scriptscriptstyle j}$ is rejected, i.e. $d_{\scriptscriptstyle j}=0$, or was  not posted on time.

\end{enumerate}
\item \textbf{Dispute Resolution}\label{RCSP::Dispute-Resolution}. The phase takes place only in  case of dispute, e.g. when $\mathcal C$ and/or $\mathcal S$ reject any proofs in the previous phase. %or  either party does not receive its counterparty's message on time. %A party who accepts all proofs does not need to get involved in this phase. 

\begin{enumerate}
%\item $\mathcal C$ and/or $\mathcal S$ at time $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$ sends ``dispute'' message to the contract. 
\item $\mathcal C$  sends $\bm{m}_{\scriptscriptstyle\mathcal C}$ to the arbiter at time $K_{\scriptscriptstyle 1}$, where $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$.  Also,  $\mathcal S$ sends $\bm{m}_{\scriptscriptstyle\mathcal S}$ to the arbiter at time $K_{\scriptscriptstyle 1}$ %,   where $|\vv{\bm{v}}_{\scriptscriptstyle\mathcal{C}}|\neq 0$ and $|\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}|\neq 0$. 


\item The arbiter sets four counters: $y_{\scriptscriptstyle\mathcal C}, y_{\scriptscriptstyle\mathcal S}, y'_{\scriptscriptstyle\mathcal C},$ and $y'_{\scriptscriptstyle\mathcal S}$, that are initially set to $0$ 

\item\label{arbiter-checks-statement} The arbiter, checks the validity of the statement: $\ddot{x}_{\scriptscriptstyle qp}\in \bm{m}_{\scriptscriptstyle\mathcal R}$,  $\forall \mathcal R\in \{\mathcal {C,S}\}$. To do that, it sends  $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. The arbiter  constructs an empty vector: $\bm{v}$.  If  party $\mathcal R$'s statement is accepted, then 
 it appends the elements of $\bm{v}_{\scriptscriptstyle\mathcal{R}}$ to $\bm{v}$, such that $\bm{v}$ contains only distinct elements which are in the range $[1,z]$. Otherwise (if the party's statement is rejected) it discards the party's request: $\bm{m}_{\scriptscriptstyle\mathcal{R}}$, and increments $ y'_{\scriptscriptstyle\mathcal R}$ by 1

%\item The Arbiter, for each party, checks the validity of $k$ by sending $k$ and $\mu'$ to SAP contract which  returns  either $1$ or $0$. The arbiter proceeds to the next step if the output is 1; otherwise, it does nothing. 
%\item The Arbiter decrypts those proofs and challenges whose index are in $\vv{\bm{v}}$. In particular,  $\forall i\in \vv{\bm{v}}: \mathtt{Dec}(\bar{k},\mathtt{Enc}(c_{\scriptscriptstyle i}))=c_{\scriptscriptstyle i}$ and $ \mathtt{Dec}(\bar{k},\mathtt{Enc}(\pi_{\scriptscriptstyle i}))=\pi_{\scriptscriptstyle i}$

\item The arbiter uses $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key that was sent to SC, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$



\item\label{the-arbiter-loop} The arbiter  for every element $i\in\bm{v}$:

\begin{enumerate}
%\item Checks if $\mathcal C$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery}. If the check fails, it increments $u_{\scriptscriptstyle\mathcal C}$ by $1$ and retakes step \ref{the-arbiter-loop} with the next element of $\vv{\bm{v}}$. Otherwise, it proceeds to the next step. 

%\item Checks if $\mathcal S$  sent to SC an encrypted proof on time, in step \ref{Billing-cycles-sendProof}. If the check fails, it increments $u_{\scriptscriptstyle\mathcal S}$ by $1$ and retakes step \ref{the-arbiter-loop} with the next element of $\vv{\bm{v}}$. Otherwise, it proceeds to the next step. 
\item removes the pads from the related encrypted    query-proof pair and encrypted service proof. Let $c'_{\scriptscriptstyle i}$ and $\pi'_{\scriptscriptstyle i}$ be the result. %unpadded encrypted  query-proof pair  and encrypted service proof  respectively. 
\item decrypts the encrypted query-proof pair and encrypted service proof as follows, $ \mathtt{Dec}(\bar{k},c'_{\scriptscriptstyle i})=c_{\scriptscriptstyle i}$ and 
$ \mathtt{Dec}(\bar{k},\pi'_{\scriptscriptstyle i})=\pi''_{\scriptscriptstyle i}$ 
\item\label{arbiter-identify} calls   $\mathtt{VSID.identify}(\pi''_{\scriptscriptstyle i},c_{\scriptscriptstyle i},pk,e')\rightarrow I_{\scriptscriptstyle i}$
\begin{enumerate}
\item[$\bullet$] if $I_{\scriptscriptstyle i}=\mathcal C$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by $1$ 
\item[$\bullet$]  if $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$ by $1$ 
\item[$\bullet$]  if $I_{\scriptscriptstyle i}=\bot$, then it increments  $y'_{\scriptscriptstyle\mathcal C}$ or $y'_{\scriptscriptstyle\mathcal S}$ by $1$, if the arbiter is invoked by the client or server respectively. 
\end{enumerate}
\end{enumerate}

%\item The Arbiter for every  $i\in\vv{\bm{v}}$ calls   $\mathtt{VSID.identify}(\pi_{\scriptscriptstyle i},c_{\scriptscriptstyle i},pk,e')\rightarrow I_{\scriptscriptstyle i}$, to resolve the dispute. 
%
%
%
%
%Let $u_{\scriptscriptstyle\mathcal C}$ and $u_{\scriptscriptstyle\mathcal S}$  be the total number of times $\mathtt{VSID.identify}()$ returns $\mathcal{C}$ and $\mathcal{S}$ respectively.  Also, let $y_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal S}$ be the total number of times $\mathtt{VSID.identify}()$ returns $\bot$ when it is invoked by the client and server  respectively. 
Let $K_{\scriptscriptstyle 2}$ be the time that the arbiter finishes the above checks.

\item The arbiter sends $(y_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S})$ and $(y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S})$ to SC at time $K_{\scriptscriptstyle 3}$
\end{enumerate}
\item \textbf{Coin Transfer}\label{RCSP::CoinTransfer}.
\begin{enumerate}
\item Either $\mathcal C$ or $\mathcal S$ send ``pay'' message and the statement, $\ddot{x}_{\scriptscriptstyle cp}$,  to SC at time $L>K_{\scriptscriptstyle 3}$
\item SC checks the validity of the statement by sending $\ddot{x}_{\scriptscriptstyle cp}$ to SAP contract which  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$. 
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$
\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$
\item[$\bullet$] $l(y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal C})$ coins to the arbiter.  
\end{itemize}

\end{enumerate}
\end{enumerate}



\begin{remark} If all parties behave honestly,   then the server receives all its deposit back plus the amount of coins they initially agreed to pay the sever if it  delivers accepting proofs for all $z$ cycles, i.e. in total it receives $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o\cdot z$ coins. Also, in this case an honest client receives all coins minus the amount of coins paid to the server for delivering accepting proofs for $z$ cycles, i.e. in total it receives $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o\cdot z$ coins. However, the arbiter receives no coins, as it is never invoked. 


\begin{remark}
Keeping track of  $(y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S})$ enables the arbiter to make malicious parties, who \emph{unnecessarily} invoke  it for invalid statement in step \ref{arbiter-checks-statement} or  accepting proofs in step \ref{arbiter-identify}, pay  for the verifications it performs. 
\end{remark}

%\begin{remark}
%If the client or server  receives no input from its counter-party, it still needs to invoke the arbiter, so that party can be paid (back) fairly. 
%\end{remark}




\end{remark}
\begin{remark} The VSID scheme  does not (need to) preserve the privacy of the proofs. However, in RC-S-P  protocol  each proof's privacy must be preserved, for a certain time; otherwise, the proof itself can leak its status, e.g. when it can be publicly verified. This is the reason in RC-S-P protocol,  \emph{encrypted} proofs are sent to the contract.   
\end{remark}


\begin{remark}
For the sake of simplicity, in the above protocol, we assumed that each arbiter's invocation has a fixed  cost regardless of the number of steps it takes. To define a fine grained costing, one can simply allocate to each step the arbiter takes a certain rate and also separate counter  for the client and server.  
\end{remark}

\begin{remark}
In the case where $\mathtt{VSID.verify}()$ is privately verifiable and    the server invokes the arbiter, the client needs to provide inputs to the arbiter too. Otherwise (when it is publicly verifiable and  the server invokes the arbiter), the client's involvement is not required in the dispute resolution phase.  In contrast, if the client invokes the arbiter, the server's involvement is not required in that phase, regardless of the type of verifiability $\mathtt{VSID.verify}()$ supports. 
\end{remark}

\begin{theorem}
The RC-S-P protocol is secure, w.r.t. Definition \ref{def::RC-S-P-Security}. 
\end{theorem}



 To prove the above theorem, we show that RC-S-P meets all security properties defined in Section \ref{sec::RC-S-P-Definition}.  We start by proving that RC-S-P satisfies security against a malicious server.  
 
 \begin{lemma}
 If SAP is secure and  VSID scheme supports correctness, soundness, and detectable abort, then RC-S-P is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}. 
 \end{lemma}
 
 
 
 \begin{proof}[sketch]
 We first consider event $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes the client withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. In this case, since the proof is valid, an honest client accepts it and does not raise any dispute. 
  However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved (through dispute resolution phase), or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key. Moreover,  due to the security of SAP, the server cannot persuade the contract to accept any statement other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision. Also, due to the correctness of VSID, the arbiter always accepts the honest client's accepting proof. 

We now move on to event $F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j})\neq h_{\scriptscriptstyle j} \ \wedge (d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal S}[j]=0 \ \vee (coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z} \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l))$ which captures the case where the server provides an invalid service proof but either persuades the client to accept the proof, or  (when the client raises a dispute)  persuades the arbiter to accept the proof or makes the client or arbiter withdraw an incorrect amount of coins, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ or $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively.   Nevertheless, due to the soundness of VSID, the probability that a corrupt server can convince an honest client to accept invalid proof (i.e. outputs $d_{\scriptscriptstyle j}=1$), is negligible, $\mu(\lambda)$. On the other hand, in the case where the client rejects the proof and raises a dispute, the server may try to convince the arbiter and make it output $y_{\scriptscriptstyle \mathcal S}[j]=0$, e.g. by sending a complaint right after the client does. But, for the adversary to win, it has to either provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the client (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification, which   requires finding the hash function's collision, and its probability of success is negligible, $\mu(\lambda)$. Or it makes the arbiter  accept an invalid proof, but due to the detectable abort property of VSID, its probability of success is also negligible, $\mu(\lambda)$. In the case where the adversary does not succeed in convincing the client or arbiter, it may still try to  make them withdraw an incorrect amount of coins. To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the client. But, it would succeed only with a negligible probability, $\mu(\lambda)$, due to the security of SAP. 

Furthermore, in   both  events above, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}



\begin{lemma}
 If SAP is secure and  VSID scheme supports correctness, inputs well-formedness, and detectable abort, then RC-S-P is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client}. 
\end{lemma}


\begin{proof}[sketch]
  First, we consider event  $(M(u^{\scriptscriptstyle *},k)= \sigma  \wedge Q(\text{aux},k)= \bm{q}_{\scriptscriptstyle j}) \wedge
  (coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)$ which captures the case where the client provides  accepting metadata and query  but makes the server withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$. In short, for the event to  happen with a high probability, a malicious client has to break the security of SAP. In particular, since the metadata and query's proofs are valid, an honest server accepts them and does not raise any dispute.  But, the client may want to  make the server  withdraw incorrect amounts of coins, if it manages to either convince the arbiter, in phase \ref{RCSP::Dispute-Resolution}, that the server has misbehaved, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$, in phase \ref{RCSP::CoinTransfer}. However, it cannot falsely accuse the server of misbehaviour. As,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key and pads, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with  probability $\mu(\lambda)$. This ensures that  the arbiter is given the honest server's messages (with a high probability). Moreover,  due to the security of SAP, the client cannot convince the contract to accept any accepting statement other than what was initially agreed  between the client and server, except with   probability $\mu(\lambda)$. Furthermore,   the correctness of VSID guarantees that  the arbiter always accepts the honest server's accepting proof. 
  
    We now turn our attention to $(M(u^{\scriptscriptstyle *},k)\neq \sigma \wedge a=1)\ \vee\ (Q(\text{aux},k)\neq \bm{q}_{\scriptscriptstyle j} \wedge b_{\scriptscriptstyle j}=1)$,   that captures the case where the server accepts an ill-formed metadata, or query. However, due to inputs well-formedness of VSID, the probability that either of the events happens is negligible, $\mu(\lambda)$. Next, we move of to      $Q(\text{aux},k)\neq \bm{q}_{\scriptscriptstyle j} \wedge
  (y_{\scriptscriptstyle\mathcal{C}}[j]=0 \ \vee  coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l)$.  It considers the case where the client provides an invalid query, but  either convinces the arbiter to accept it, or  makes the server or arbiter  withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ or  $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively. Note, when the server rejects the query and raises a dispute, the client may try to convince the arbiter, and make it output $y_{\scriptscriptstyle \mathcal C}[j]=0$, e.g. by sending a complaint right after the server does so. However, for the adversary to win, either it has to provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the server (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification. But,  due to the security of SAP, its probability of success is negligible, $\mu(\lambda)$. Or it has to make the arbiter  accept an invalid query, i.e. makes the arbiter output $y_{\scriptscriptstyle\mathcal{C}}[j]=0$. Nevertheless, due to the detectable abort property of VSID, its probability of success is  negligible, $\mu(\lambda)$. If the adversary does not succeed in convincing the server or arbiter, it may still try to  make them withdraw an incorrect amount of coins. To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the server. However, due to the security of SAP, its  success probability is negligible, $\mu(\lambda)$. Also, due to the security of SAP, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
 \hfill\(\Box\)\end{proof}
  
  
  


\begin{lemma}\label{lemma::encoded-coins} Let $\beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}$, price list be $\{(o_{\scriptscriptstyle 0},l_{\scriptscriptstyle 0}),(o_{\scriptscriptstyle 1},l_{\scriptscriptstyle 1})\}$, and encoded coin amounts be $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}= z\cdot(Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta},l_{\scriptscriptstyle|\beta-1|}))$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot(Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle |\beta-1|}))$. Then, given the price list, $z$, $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$, and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, an adversary $\mathcal{A}$ cannot tell the value of $\beta$ with probability significantly greater than $\frac{1}{2}$ (where the probability is taken over the choice of $\beta$ and the randomness of $\mathcal{A}$).
\end{lemma}



\begin{proof}
As it is evident, the list and $z$ contains no information about $\beta$. Also, since  $z$ is a public value, we could have   $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z} = Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle|\beta-1|})$. It is not hard to see $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ is a function of maximum value of $(o_{\scriptscriptstyle 0},o_{\scriptscriptstyle 1})$, and maximum value of $(l_{\scriptscriptstyle 0},l_{\scriptscriptstyle 1})$. It is also  independent of $\beta$. Therefore, given the list, $z$ and $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ the adversary learns nothing about $\beta$, unless it guesses the value,  with  success probability $\frac{1}{2}$. The same also holds for $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. 
 \hfill\(\Box\)\end{proof}


\begin{lemma} If SAP is secure and the encryption scheme is semantically secure, then RC-S-P preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

\begin{proof}[sketch]
Due to the privacy property of SAP, that stems from the  hiding property of the commitment scheme, given the commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$, (that are stored in the blockchain as result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}, pad_{\scriptscriptstyle q},$ and $\bar{k}$), except with negligible probability, $\mu_{\scriptscriptstyle 1}(\lambda)$.   Also, given encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, the adversary learns nothing about the actual price agreed between the server and client,  $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}. Now we analyse the privacy of padded encrypted proof vector $\bm{\pi}^{\scriptscriptstyle *}$. For the sake of simplicity, we focus on an element of the vector,  $\pi_{\scriptscriptstyle i}^{\scriptscriptstyle *}\in\bm{\pi}^{\scriptscriptstyle *}$, that is a padded encrypted proof for $j$-th verification. Let $\pi_{\scriptscriptstyle j,0}$ and $\pi_{\scriptscriptstyle j,1}$  be proofs, for $i$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$, where the inputs   are picked by the adversary, w.r.t. Definition  \ref{deff::RC-S-P-Privacy} in which  the experiment picks $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$. In the experiment, if $\pi_{\scriptscriptstyle j,\beta}$  is only   encrypted (but not padded), then given the ciphertext along with $\pi_{\scriptscriptstyle j,0}$ and $\pi_{\scriptscriptstyle j,1}$, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$,  under the assumption  that the two proofs have the same length, i.e. $|\pi_{\scriptscriptstyle j,0}|=|\pi_{\scriptscriptstyle j,1}|$.  The  assumption is  relaxed with the use of a pad. In particular, since each encrypted query is padded  to the proofs' maximum size, i.e. $Max(|\pi_{\scriptscriptstyle j,0}|,|\pi_{\scriptscriptstyle j,1}|)$, the adversary cannot tell with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$ if the  padded encrypted proof corresponds to  $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$. The same holds for every element of $\bm{c}^{\scriptscriptstyle *}$, as each element is encrypted and then padded too. Also, since the value of $a$ is independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, it leaks nothing about the service input $u_{\scriptscriptstyle\beta}$ and $\beta$. Moreover, since each padded encrypted proof leaks no information, an adversary cannot tell the status of a proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$, given  $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$ and $\bm{\pi}^{\scriptscriptstyle *},a$.
  \hfill\(\Box\)\end{proof}

%\begin{remark} In the case where each encrypted query/proof is a set (i.e. contain multiple encrypted values) and their number may  reveal something about the client's input, e.g. its size, they can simply pad them with some dummy values whose number and indices are fixed and  known only to them. To let the arbiter distinguish dummy values from real ones, the client and server can run the SAP in the setup  to provably agree on a statement containing the details of the pad. Later on, in the dispute resolution phase, the party who raises a dispute  also sends the statement to the arbiter who checks the validity of the statement, excludes the pad and then carries out the rest as before. 
%\end{remark}

\subsection{Reducing the Arbiter involvement}

{\color{blue}Explain how we can use the smart contracts of \cite{DongWAMM17} to delegate the arbiter task to smart contracts. In this case, only if the smart contracts do not reach a consensus the arbiter is involved. }
\input{PoR-protocol}




