% !TEX root =R-zkCSP.tex

\subsection{Verifiable Service (VS) Definition}\label{subsec:VS}
At a high-level, a verifiable service scheme is a two-party protocol in which a client chooses a function, $F$, and provides (an encoding of) $F$, and its input $u$, and a query $\bm{q}$ to a server.  The server is expected to evaluate $F$ on $u$ and $q$ and respond with the output. Then, the client  verifies that the output is indeed the output of the function computed on the provided input. In verifiable services, either the computation (on the input) or both the computation and storage of the input are delegated to the server. A verifiable service is defined as follows. 


\begin{definition}[VS Scheme]\label{service-def}
A verifiable service scheme VS $:=(\mathtt{VS.keyGen}, \mathtt{VS.setup},\mathtt{VS.genQuery},$ $\mathtt{VS.prove},\mathtt{VS.verify})$ consists of five algorithms defined as follows.


\begin{itemize}

\item[$\bullet$] $\mathtt{VS.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)$.  A probabilistic algorithm run by the client. It takes as input the security parameter $1^{\lambda}$ and a function, $F$, that will be run on the client's input by the server. It outputs a secret/public verification key pair $k$. 



\

\item[$\bullet$] $\mathtt{VS.setup}(1^{\lambda}, u,k, M)\rightarrow (u^{\scriptscriptstyle *},\sigma,{pp})$. It is run by the client. It takes as input the security parameter $1^{\lambda}$,  the service input $u$,    key pair $k$ and metadata generator deterministic function $M$, where $M$ is publicly known. If an encoding is needed, then it encodes $u$, that results $u^{\scriptscriptstyle *}$; otherwise, $u^*=u$. It outputs encoded input $u^{\scriptscriptstyle *}$, (possibly input dependent) public parameters {$pp$}, metadata $\sigma=M(u^{\scriptscriptstyle *},k,{pp})$. Right after that, the server is  given $u^{\scriptscriptstyle *}$,  $\sigma$, {$pp$}, and $pk$.




\

\item[$\bullet$] $\mathtt{VS.genQuery}(1^{\lambda}, \text{aux},k,Q,{pp})\rightarrow \bm{q}$. A probabilistic algorithm run by the client. It takes as input the security parameter $1^{\lambda}$, auxiliary information $\text{aux}$,   the key pair $k$,   query generator deterministic function $Q$ (where $Q$ is publicly known) and {public parameters $pp$}. It outputs  a query vector $\bm{q}=Q( \text{aux},k,{pp})$.  Depending on service types, $\bm{q}$ may be empty or contain only random strings. The output  is given to the server. 

\




\item[$\bullet$] $\mathtt{VS.prove}(u^{\scriptscriptstyle *},\sigma, \bm{q}, pk,{pp})\rightarrow \pi$. It is run by the server. It  takes as input the service encoded input $u^{\scriptscriptstyle *}$, metadata $\sigma$,   queries $\bm{q}$, public key $pk$, and { public parameters  $pp$}. It outputs a proof pair, $\pi :=(F(u^{\scriptscriptstyle *}, \bm{q},{pp}),\delta)$ containing the function evaluation for service input $u$, {public parameters $pp$}, and query $\bm{q}$, i.e. $h=F(u^{\scriptscriptstyle *},\bm{q},{pp})$, and a proof $\delta$ asserting the evaluation is performed correctly, where generating $\delta$ may involve $\sigma$. The output is given to the client. 

\

\item[$\bullet$] $\mathtt{VS.verify}(\pi, \bm{q}, k, {pp})\rightarrow d\in\{0,1\}$. It is run by the client. It takes as input the proof $\pi$,   query vector $\bm{q}$,   key  $k$, and {public parameters $pp$}.   In the case where $\mathtt{VS.verify}(.)$ is publicly verifiable then $k:=(\bot,pk)$,  and when it is privately verifiable $k:=(sk,pk)$. The algorithm  outputs $d=1$, if the proof is accepted; otherwise, it outputs $d=0$. 



\end{itemize}
\end{definition}


A verifiable service scheme has two main properties, \emph{correctness} and \emph{soundness}. Correctness requires that  the verification algorithm always accepts a proof generated by an honest prover.  It is formally stated below.

\begin{definition}[VS Correctness] A verifiable service scheme, VS, is  correct,  if for functions $F,Q,M$, and an auxiliary information $aux$, the key generation algorithm produces keys $\mathtt{VS.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)$ s.t. for any service input $u$, if $\ \mathtt{VS.setup}(1^{\lambda}, u,k,M)$ $\rightarrow (u^{\scriptscriptstyle *},\sigma, {pp})$,  $\mathtt{VS.genQuery}(1^{\lambda}, \text{aux},k,Q, {pp})\rightarrow \bm{q}$ and $\mathtt{VS.prove}(u^{\scriptscriptstyle *},\sigma, \bm{q},pk, {pp})\rightarrow \pi$, then $\mathtt{VS.verify}(\pi, \bm{q}, k, {pp})\rightarrow 1$
\end{definition}

Intuitively, a verifiable service is sound  if a malicious server cannot convince the verification algorithm to accept an incorrect output of $F$ except with negligible probability. Soundness is formally stated as follows.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[VS Soundness] A verifiable service VS is sound  for  functions $F,Q,M$, and an auxiliary information $aux$, if for any probabilistic polynomial time adversaries $\mathcal{A}$, there exists a negligible function $\mu(\cdot)$, such that for any security parameter $\lambda$: 
%\footnotesize{
\small{
$$ \Pr\left[
  \begin{array}{l}
F(u^{\scriptscriptstyle *},\bm{q},{pp})\neq h \wedge d=1
\end{array} \middle | 
    \begin{array} {l}
 \mathtt{VS.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)\\
 \mathcal{A}(1^{\scriptscriptstyle\lambda},pk, F)\rightarrow u\\
\mathtt{VS.setup}(1^{\lambda}, u,k,M)\rightarrow (u^{\scriptscriptstyle *},\sigma, {pp})\\
 \mathtt{VS.genQuery}(1^{\lambda}, \text{aux},k,Q,{pp})\rightarrow \bm{q}\\
 \mathcal{A}(\bm{q},u^{\scriptscriptstyle *},\sigma,{pp})\rightarrow \pi:=(h,\delta)\\
 \mathtt{VS.verify}(\pi,\bm{q},k,{pp})\rightarrow d\\
\end{array}    \right]\leq \mu(\lambda).$$
}
%where the probability is taken over uniform  choice of $k\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$  as well as the randomness of $\mathcal{A}$.
\end{definition}




The above generic definition captures the core requirements of a wide range of verifiable services such as verifiable outsourced storage, i.e. Proofs of Retrievability \cite{DBLP:journals/iacr/JuelsK07,DBLP:conf/asiacrypt/ShachamW08} or Provable Data Possession \cite{DBLP:conf/ccs/AtenieseBCHKPS07,ShenT11}, verifiable computation, verifiable searchable encryption, and verifiable information retrieval, to name a few. Other additional  security properties mandated by certain services can be added to the above definition. Depending on the properties,  they can be  plugged into  the above definition with minimal adjustment to the definition. Privacy is an example. Alternatively, the definition can be upgraded to capture the  additional requirements.  The verifiable service with identifiable abort (VSID) and recurring contingent service payment (RC-S-P) definitions presented in this paper are two examples. 


\begin{remark}
It is not hard to see that the original PoR definition (presented in Section \ref{PoR-def}) captures VS definition. In particular, PoR's $\epsilon$-soundness captures VS's soundness.  Because in the $\epsilon$-soundness, the extractor algorithm interacts (many times) with the cheating prover  who must not be able to persuade the extractor to accept an invalid proof with a high probability and should provide  accepting proofs for non-negligible $\epsilon$ fraction of verification challenges.  The former property is exactly what VS soundness states. Thus, any protocol that realises PoR definition, realises VS definition as well. 
\end{remark}



