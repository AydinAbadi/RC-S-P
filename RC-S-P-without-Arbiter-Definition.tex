% !TEX root =R-zkCSP.tex

\section{Definition of RC-S-P Without Arbiter's Involvement}\label{sec::RC-S-P-Definition2}
There are cases, in RC-S-P schemes, where the third-party arbiter's role  can be  efficiently delegated to a smart contract.  In this variant of RC-S-P scheme, denoted by ${\text{RC-}\overline{\text{S}}\text{-P}}$, the arbiter's involvement is not needed anymore. The primary difference between RC-S-P and ${\text{RC-}\overline{\text{S}}\text{-P}}$ is the way a party pays to resolve a dispute. In particular, in RC-S-P, the party who raises dispute does not pay the arbiter when it sends to it a dispute query. Instead, loosely speaking, the arbiter at coin distribution is paid by a misbehaving party. Whereas, in ${\text{RC-}\overline{\text{S}}\text{-P}}$, the party who raises dispute and sends a dispute query to the contract, (due to the nature of smart contracts' platform) has to pay the contract, before the contract processes its query.  In this section, we show how RC-S-P definition (presented in Section \ref{sec::RC-S-P-Definition}) can be  adjusted to  capture ${\text{RC-}\overline{\text{S}}\text{-P}}$. In the following, we highlight the main changes that should be applied to the RC-S-P definition. 

\begin{itemize}

\item[$\bullet$] In Definition \ref{RC-S-P-def}: 
\begin{itemize}



\item [$\bullet$]  Three parties are involved; namely, client, server and smart contract (so an arbiter is not involved anymore). 

\

\item [$\bullet$]  Vectors $(\bm{y}'_{\scriptscriptstyle\mathcal{C}},\bm{y}'_{\scriptscriptstyle\mathcal{S}})$ are not needed anymore. Because a misbehaving party, who unnecessarily invokes the contract, pays the contract ahead of time. Therefore, there is no need to keep track of unnecessary contract's invocation. 




\

\item [$\bullet$] $\mathtt{RCSP}.\mathtt{resolve}(.)$ is run by a smart contract. 

\

\item [$\bullet$] $\mathtt{RCSP}.\mathtt{pay}(.)$ outputs $({\bm{coin}}_{\scriptscriptstyle\mathcal C},{\bm{coin}}_{\scriptscriptstyle\mathcal S})$, so ${\bm{coin}}_{\scriptscriptstyle\mathcal{A}r}$ is excluded from the output, as a third-party arbiter plays no role anymore.
\end{itemize}

\

\item [$\bullet$] In Definition \ref{def::RC-S-P-Correctness}: only the above changes are applied to it. 

\

\item [$\bullet$] In Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}:  the above changes are applied to the algorithms' syntax in the experiment. Moreover, the events are slightly modified, i.e. the amount of coins each party receives. For the sake of clarity and completeness, we state the entire modified  definition below. 

\begin{definition}[${\text{RC-}\overline{\text{S}}\text{-P}}$ Security Against Malicious Server]\label{deff::RC-S-P-SecurityAgainstMaliciousServer-2}  A ${\text{RC-}\overline{\text{S}}\text{-P}}$  is secure against a malicious server  for a function $F$, if for any auxiliary information $\text{aux}$,  any price list $pl$, every $j$ (where $1\leq j\leq z$), any $Q,M, E, D$ and any PPT adversary $\mathcal{A}$, there exists a negligible function $\mu(\cdot)$, such that for any security parameter $\lambda$: 
{\small
$$ \Pr\left[
  \begin{array}{l}
  \Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j}, {pp})= h_{\scriptscriptstyle j}\ \wedge\\ (coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o)\Big)\ \vee\\ 
\Big(
F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j}, {pp})\neq h_{\scriptscriptstyle j} \ \wedge\\ (d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal{S},j}=0 \ \vee \   \\ {coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l} ) \Big)\\
\end{array} \middle |
    \begin{array}{l}
    \mathtt{RCSP.keyGen}(1^{\lambda}, F)\rightarrow \bm{k}\\
    \mathcal{A}(1^\lambda,pk, F)\rightarrow u\\
  
    \mathtt{RCSP}.\mathtt{cInit}(1^\lambda, u,\bm{k}, M,z,pl,enc)\rightarrow (u^{\scriptscriptstyle *},e,T, p_{\scriptscriptstyle\mathcal S},  \bm{y}, coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal C})\\ 
    \mathcal{A}(u^{\scriptscriptstyle *}, e, pk, z, T, p_{\scriptscriptstyle\mathcal S},\bm{y},enc)\rightarrow (coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a)\\
	\mathtt{RCSP}.\mathtt{genQuery}(1^\lambda, \text{aux},k,Q, T_{\scriptscriptstyle qp}, enc)\rightarrow c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\\
	
     \mathcal{A}(c^{\scriptscriptstyle *}_{\scriptscriptstyle j},\sigma, u^{\scriptscriptstyle *},enc,a)\rightarrow 
     (b_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j},h^{\scriptscriptstyle *}_{\scriptscriptstyle j},\delta^{\scriptscriptstyle *}_{\scriptscriptstyle j})\\      
\mathtt{RCSP}.\mathtt{verify}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k,T_{\scriptscriptstyle qp},enc)\rightarrow (d_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{C},j})\\
   \mathtt{RCSP}.\mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}},z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{c}}^{\scriptscriptstyle *},pk, T_{\scriptscriptstyle qp},enc)\rightarrow \bm{y}\\
   \mathtt{RCSP}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})\rightarrow ({\bm{coin}}_{\scriptscriptstyle\mathcal C},{\bm{coin}}_{\scriptscriptstyle\mathcal S})\\
\end{array}    \right]\leq \mu(\lambda).$$
}
where $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}:=(h^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \delta^{\scriptscriptstyle *}_{\scriptscriptstyle j}), h_{\scriptscriptstyle j}= D(h^{\scriptscriptstyle *}_{\scriptscriptstyle j},T_{\scriptscriptstyle qp})$, $
D\in enc$, $\sigma\in e$, $m_{\scriptscriptstyle \mathcal{C},j}\in m_{\scriptscriptstyle \mathcal{C}}, m_{\scriptscriptstyle \mathcal{S},j}\in m_{\scriptscriptstyle \mathcal{S}}$,   $y_{\scriptscriptstyle \mathcal{S},j}\in \bm{y}_{\scriptscriptstyle \mathcal{S}}\in\bm{y}$, and $ {pp}\in T_{\scriptscriptstyle qp}$. 
\end{definition}

\

 \item[$\bullet$] In Definition \ref{deff::RC-S-P-Security-Against Malicious-Client}: similar to the previous point, only the algorithms' syntax (in the experiment) and the amount of coins each party receives changes. Below, we state the entire modified definition. 
 
 \begin{definition}[${\text{RC-}\overline{\text{S}}\text{-P}}$ Security Against Malicious Client]\label{deff::RC-S-P-Security-Against Malicious-Client-2}  A  ${\text{RC-}\overline{\text{S}}\text{-P}}$  is secure against a malicious client  for a function $F$, for every $j$ (where $1\leq j\leq z$), any $Q,M,E,D$ and any probabilistic polynomial time adversary $\mathcal{A}$, there exists a negligible function $\mu(\cdot)$, such that for any security parameter $\lambda$: 

{\small
$$ \Pr\left[
  \begin{array}{l}
 \Big((M(u^{\scriptscriptstyle *},k, {pp})= \sigma  \wedge\\ Q(\text{aux},k, {pp})= \bm{q}_{\scriptscriptstyle j})\ \wedge\\
  (coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o )\Big)\ \vee
  \\
  
  
  \Big(M(u^{\scriptscriptstyle *}, k,  {pp})\neq \sigma \wedge a=1\Big) \ \vee\\ 


  \Big(Q(\text{aux},k,  {pp})\neq \bm{q}_{\scriptscriptstyle j}\ \wedge\\
  (b_{\scriptscriptstyle j}=1 \ \vee \ y_{\scriptscriptstyle\mathcal{C},j}=0 \ \vee \\ {coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac {coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o + l}) 
  \Big)
 \\
 
\end{array} \middle |
    \begin{array}{l}
   \mathcal{A}(1^{\lambda}, F)\rightarrow (u^{\scriptscriptstyle *},z,\bm{k},e,T, pl, p_{\scriptscriptstyle\mathcal{S}}, coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal C},enc, \text{aux},\bm{y}, enc, pk)\\
   
   \mathtt{RCSP}.\mathtt{sInit}(u^{\scriptscriptstyle *}, e, pk, z, T, p_{\scriptscriptstyle\mathcal S},\bm{y},enc)\rightarrow (coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a)\\
   
	\mathcal{A}(coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a, 1^\lambda, \text{aux},k,Q, T_{\scriptscriptstyle qp}, enc)\rightarrow c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\\

     \mathtt{RCSP}.\mathtt{prove}(u^{\scriptscriptstyle *},  \sigma,  c^{\scriptscriptstyle *}_{\scriptscriptstyle j}, pk, T_{\scriptscriptstyle qp},enc)\rightarrow (b_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j},\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j})\\
     
 \mathcal{A}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k,T_{\scriptscriptstyle qp},enc)\rightarrow (d_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j})\\
   
   
   \mathtt{RCSP}.\mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}},z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{c}}^{\scriptscriptstyle *}, pk, T_{\scriptscriptstyle qp},enc)\rightarrow \bm{y}\\
   \mathtt{RCSP}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})\rightarrow ({\bm{coin}}_{\scriptscriptstyle\mathcal C},{\bm{coin}}_{\scriptscriptstyle\mathcal S})\\
\end{array}    \right]\leq \mu(\lambda).$$
}
where $\bm{q}_{\scriptscriptstyle j}\in D(c^{\scriptscriptstyle *}_{\scriptscriptstyle j},t_{\scriptscriptstyle qp})$, $
D\in enc$, $\sigma\in e$,    $y_{\scriptscriptstyle \mathcal{C},j}\in \bm{y}_{\scriptscriptstyle \mathcal{C}}\in\bm{y}$, and ${pp}\in T_{\scriptscriptstyle qp}$.  
\end{definition}
\end{itemize}

Note that Definition \ref{deff::RC-S-P-Privacy} remains almost the same with a  minor change, that is vectors $(\bm{y}'_{\scriptscriptstyle\mathcal{C}},\bm{y}'_{\scriptscriptstyle\mathcal{S}})$ are excluded from the related algorithms input/output. 

 \begin{definition}\label{def::RC-S-P-Security-2} A ${\text{RC-}\overline{\text{S}}\text{-P}}$  is secure if it satisfies security against malicious server, security against malicious client, and preserves privacy, w.r.t. Definitions \ref{deff::RC-S-P-SecurityAgainstMaliciousServer-2},\ref{deff::RC-S-P-Security-Against Malicious-Client-2}, and \ref{deff::RC-S-P-Privacy}. 
 \end{definition}






%\small{
%$$ Pr\left[
%  \begin{array}{l}
% \Big((M(u^{\scriptscriptstyle *},k)= \sigma  \wedge Q(\text{aux},k)= q_{\scriptscriptstyle j}) \wedge\\
%  (coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)\Big) \vee
%  \\
%  \Big((M(u^{\scriptscriptstyle *},k)\neq \sigma \lor Q(\text{aux},k)\neq q_{\scriptscriptstyle j}) \wedge\\
%  (a=1 \ \vee b_{\scriptscriptstyle j}=1\ \vee y_{\scriptscriptstyle\mathcal{C}}[j]=0 \ \vee \\ coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l) 
%  \Big)
% \\
% 
%\end{array} \middle |
%    \begin{array}{l}
%   \mathcal{A}(1^{\lambda},F)\rightarrow (u^{\scriptscriptstyle *},z,\bm{k},e,t,coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal C},en, \text{aux},\bm{y}_{\scriptscriptstyle \mathcal  C},\bm{y}_{\scriptscriptstyle \mathcal  S})\\
%   
%   \mathtt{RCSP}.\mathtt{sInit}(u^{\scriptscriptstyle *},e, pk,z, t,\bm{y}_{\scriptscriptstyle \mathcal  C},\bm{y}_{\scriptscriptstyle \mathcal  S})\rightarrow (coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a)\\
%   
%	\mathcal{A}(coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a, \text{aux},\bm{k},Q,j, en)\rightarrow c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\\
%
%     \mathtt{RCSP}.\mathtt{prove}(u^{\scriptscriptstyle *},  \sigma,  c^{\scriptscriptstyle *}_{\scriptscriptstyle j},pk, en)\rightarrow (b_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j},\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j})\\
%     
% \mathcal{A}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, q,k,j,en)\rightarrow (d_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{A},j})\\
%   
%   
%   \mathtt{RCSP}.\mathtt{resolve}(\bm{m}_{\scriptscriptstyle \mathcal{A}},\bm{m}_{\scriptscriptstyle \mathcal{S}},z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{c}}^{\scriptscriptstyle *},pk,en)\rightarrow (\bm{y}_{\scriptscriptstyle \mathcal C},\bm{y}_{\scriptscriptstyle \mathcal S})\\
%   \mathtt{RCSP}.\mathtt{pay}(\bm{y}_{\scriptscriptstyle \mathcal C},\bm{y}_{\scriptscriptstyle \mathcal S},t_{\scriptscriptstyle cp},a,coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})\rightarrow ({\bm{coin}}_{\scriptscriptstyle\mathcal C},{\bm{coin}}_{\scriptscriptstyle\mathcal S},{\bm{coin}}_{\scriptscriptstyle\mathcal Ar})\\
%\end{array}    \right]\leq \mu(\lambda)$$
%}
%where $q_{\scriptscriptstyle j}\in D(c^{\scriptscriptstyle *}_{\scriptscriptstyle j},t_{\scriptscriptstyle qp})$, $
%D,t_{\scriptscriptstyle qp}\in en$, $\sigma\in e$, and   the probability is taken over the randomness used in witnesses $w_{\scriptscriptstyle cp},w_{\scriptscriptstyle qp}\in t$ as well as  the randomness used in proofs $w_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}}\in c_{\scriptscriptstyle j}$ and $w_{\scriptscriptstyle\sigma}\in e$ and  the randomness of $\mathcal{A}$.
%\end{definition}
% 
% Note, in the above definition, an honest server either does not deposit (e.g. when $a=0$) or if it deposits (i.e. agrees to serve) ultimately receives its deposit \emph{plus the service payment} (with a high probability). Informally, RC-S-P is privacy preserving if it guarantees the privacy of (a) the service input (e.g. outsourced file) and (b) the service proof's status during the private time bubble. In the following, we formally define privacy.
% 
%
%  \begin{definition}[RC-S-P Privacy]\label{deff::RC-S-P-Privacy}  A RC-S-P   preserves privacy, any auxiliary information $\text{aux}$, any number of verifications $z$, any price list $pl$, any $F, Q,M, E$ and $D$, the following hold: 
%\begin{enumerate}
%\item For any PPT adversary $\mathcal{A}_{\scriptscriptstyle 1}$ there exists a negligible function $\mu_{\scriptscriptstyle 1}(\cdot)$, such that for any security parameter $\lambda$:
% 
%{\small
%$$\Pr\left[
%  \begin{array}{l}
%  \mathcal{A}_{\scriptscriptstyle 1}(\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal  C}, g_{\scriptscriptstyle cp}, \\ g_{\scriptscriptstyle qp}, \bm{\pi}^{\scriptscriptstyle *}, pl, a)\rightarrow\beta\\
%\end{array} \middle |
%    \begin{array}{l}
%            \mathtt{RCSP.keyGen}(1^{\lambda}, F)\rightarrow \bm{k}\\
%        \mathcal{A}_{\scriptscriptstyle 1}(1^\lambda, pk, F)\rightarrow (u_{\scriptscriptstyle 0},u_{\scriptscriptstyle 1})\\
%    \beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}\\
%   \mathtt{RCSP}.\mathtt{cInit}(1^\lambda, u_{\scriptscriptstyle\beta},\bm{k}, M,z,pl,enc)\rightarrow (u^{\scriptscriptstyle *}_{\scriptscriptstyle\beta},e,T, p_{\scriptscriptstyle\mathcal S},  \bm{y}, coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal C})\\
%\mathtt{RCSP}.\mathtt{sInit}(u_{\scriptscriptstyle\beta}^{\scriptscriptstyle *}, e, pk, z, T, p_{\scriptscriptstyle\mathcal S},\bm{y},enc)\rightarrow (coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a)\\
%\forall j \in [z]:\\
%\Big(\mathtt{RCSP}.\mathtt{genQuery}(1^\lambda, \text{aux},k,Q_{\scriptscriptstyle\beta}, T_{\scriptscriptstyle qp}, enc)\rightarrow c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\\
%     \mathtt{RCSP}.\mathtt{prove}(u^{\scriptscriptstyle *}_{\scriptscriptstyle\beta},   \sigma,  c^{\scriptscriptstyle *}_{\scriptscriptstyle j}, pk, T_{\scriptscriptstyle qp},enc)\rightarrow (b_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j},\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j})\\  
%   \mathtt{RCSP}.\mathtt{verify}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k,T_{\scriptscriptstyle qp},enc)\rightarrow (d_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{C},j})\Big)\\
%\end{array}\right]\leq \frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda).$$
%}
%
%
%
%\item For any PPT adversary $\mathcal{A}_{\scriptscriptstyle 2}$ who plays the above game, there exists a negligible function $\mu_{\scriptscriptstyle 2}(\cdot)$ such that
%
%
%{\small
%$$ Pr\left[\mathcal{A}_{\scriptscriptstyle 2}(\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},\bm{\pi}^{\scriptscriptstyle *}, pl, a)\rightarrow (d_{\scriptscriptstyle j},j)\right]\leq \frac{1}{2}+ \mu_{\scriptscriptstyle 2}(\lambda)$$
%}
%
%where $\bm{c}^{\scriptscriptstyle *}=[{c}^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,{c}^{\scriptscriptstyle *}_{\scriptscriptstyle z}], \bm{\pi}^{\scriptscriptstyle *}=[\pi^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,\pi^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$, and $ {pp}\in T_{\scriptscriptstyle qp}$.  Also, depending on the choice of $\beta$, algorithm $\mathtt{RCSP}.\mathtt{genQuery}(.)$ outputs an encoded valid query, when the input is $Q_{\scriptscriptstyle 1}$, or outputs an encoded invalid query, when the input is $Q_{\scriptscriptstyle 0}$.
%% The probability is taken over uniform  choice of $k,k'\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$, where $k,k'\in\bm{k}$, the randomness of $\mathcal{A}_{\scriptscriptstyle 1}$ and $\mathcal{A}_{\scriptscriptstyle 2}$,  the randomness used in witnesses $g_{\scriptscriptstyle cp}, g_{\scriptscriptstyle qp}\in t$,  the randomness used in  $E$.
%\end{enumerate}
%\end{definition}
 
%In the above definition, the experiment is allowed to produce  invalid queries. It is required that  the privacy holds regardless of the queries status, i.e. whether they are valid or invalid, as long as the are encoded and provided.  
 
 
 
%  \begin{definition}[RC-S-P Service Proof Privacy]\label{deff::RC-S-P-ServiceProofPrivacy}  A RC-S-P   preserves the privacy of service proof (status), if for any security parameter $\lambda$, any auxiliary information $\text{aux}$, any $F,Q,M,E,D$ and any probabilistic polynomial time adversary $\mathcal{A}$ that plays the  game in Definition \ref{deff::RC-S-P-Input-Privacy}, there exists a negligible function $\mu(.)$, such that: 
%
%\small{
%$$ Pr\left[\mathcal{A}(\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},\bm{\pi}^{\scriptscriptstyle *},a)\rightarrow (d_{\scriptscriptstyle j},j)\right]\leq \frac{1}{2}+ \mu(\lambda)$$
%}
%where $\bm{c}^{\scriptscriptstyle *}=[{c}^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,{c}^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$ and $\bm{\pi}^{\scriptscriptstyle *}=[\pi^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,\pi^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$.  The probability is taken over uniform  choice of $k,k'\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$, where $k,k'\in\bm{k}$, the randomness of $\mathcal{A}$,  the randomness used in witnesses $g_{\scriptscriptstyle cp}, g_{\scriptscriptstyle qp}\in t$,  the randomness used in  $E$.
%\end{definition}
 
 
 
 %-----------------------------------
% \begin{definition}[RC-S-P Service Input Privacy]\label{deff::RC-S-P-Input-Privacy}  A RC-S-P   preserves the privacy of service input, if for any security parameter $\lambda$, any auxiliary information $\text{aux}$, any $F, Q,M, E,D$ and any probabilistic polynomial time adversary $\mathcal{A}$, there exists a negligible function $\mu(.)$, such that: 
%
%\small{
%$$ Pr\left[
%  \begin{array}{l}
%  \mathcal{A}(\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle C},g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},\bm{\pi}^{\scriptscriptstyle *},a)\rightarrow\beta\\
%
%
%\end{array} \middle |
%    \begin{array}{l}
%    \mathtt{RCSP.keyGen}(1^{\lambda},F)\rightarrow \bm{k}\\
%    \mathcal{A}(1^\lambda,pk, F)\rightarrow (u_{\scriptscriptstyle 0},u_{\scriptscriptstyle 1})\\
%    \beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}\\
%   
%   \mathtt{RCSP}.\mathtt{cInit}(1^\lambda, u_{\scriptscriptstyle\beta},\bm{k}, M,z,cp)\rightarrow (u_{\scriptscriptstyle\beta}^{\scriptscriptstyle *},e,t,coin^{\scriptscriptstyle*}_{\scriptscriptstyle\mathcal C}, \bm{y}_{\scriptscriptstyle \mathcal  C},\bm{y}_{\scriptscriptstyle \mathcal  S})\\
%
%\mathtt{RCSP}.\mathtt{sInit}(u_{\scriptscriptstyle\beta}^{\scriptscriptstyle *},e, pk,z, t,\bm{y}_{\scriptscriptstyle \mathcal  C},\bm{y}_{\scriptscriptstyle \mathcal  S})\rightarrow (coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S},a)\\
%
%\mathtt{RCSP}.\mathtt{genQuery}(1^\lambda, \text{aux},k,Q,j, en)\rightarrow c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\\
%	
%     
%     \mathtt{RCSP}.\mathtt{prove}(u^{\scriptscriptstyle *}_{\scriptscriptstyle\beta},  \sigma,  c^{\scriptscriptstyle *}_{\scriptscriptstyle j},pk, en)\rightarrow (b_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{S},j},\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j})\\
%     
%   \mathtt{RCSP}.\mathtt{verify}(\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \bm{q}_{\scriptscriptstyle j},k,en)\rightarrow (d_{\scriptscriptstyle j},m_{\scriptscriptstyle \mathcal{C},j})\\
%\end{array}    \right]\leq \frac{1}{2}+\mu(\lambda)$$
%}
%where $\bm{c}^{\scriptscriptstyle *}=[{c}^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,{c}^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$ and $\bm{\pi}^{\scriptscriptstyle *}=[\pi^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,\pi^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$.  The probability is taken over uniform  choice of $k,k'\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$, where $k,k'\in\bm{k}$, the randomness of $\mathcal{A}$,  the randomness used in witnesses $g_{\scriptscriptstyle cp},g_{\scriptscriptstyle qp}\in t$,  the randomness used in  $E$.
%
%\end{definition}
% 
% 
% 
%  \begin{definition}[RC-S-P Service Proof Privacy]\label{deff::RC-S-P-ServiceProofPrivacy}  A RC-S-P   preserves the privacy of service proof (status), if for any security parameter $\lambda$, any auxiliary information $\text{aux}$, any $F,Q,M,E,D$ and any probabilistic polynomial time adversary $\mathcal{A}$ that plays the  game in Definition \ref{deff::RC-S-P-Input-Privacy}, there exists a negligible function $\mu(.)$, such that: 
%
%\small{
%$$ Pr\left[\mathcal{A}(\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},\bm{\pi}^{\scriptscriptstyle *},a)\rightarrow (d_{\scriptscriptstyle j},j)\right]\leq \frac{1}{2}+ \mu(\lambda)$$
%}
%where $\bm{c}^{\scriptscriptstyle *}=[{c}^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,{c}^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$ and $\bm{\pi}^{\scriptscriptstyle *}=[\pi^{\scriptscriptstyle *}_{\scriptscriptstyle 1},...,\pi^{\scriptscriptstyle *}_{\scriptscriptstyle z}]$.  The probability is taken over uniform  choice of $k,k'\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$, where $k,k'\in\bm{k}$, the randomness of $\mathcal{A}$,  the randomness used in witnesses $g_{\scriptscriptstyle cp}, g_{\scriptscriptstyle qp}\in t$,  the randomness used in  $E$.
%\end{definition}
 %-------------------------
 
 
 
% \begin{definition}[RC-S-P Security]\label{def::RC-S-P-Security} A RC-S-P scheme is secure if it satisfies security against malicious server, security against malicious client, and preserves privacy, w.r.t. Definitions \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}-\ref{deff::RC-S-P-Privacy}. 
% \end{definition}
 

 
 
