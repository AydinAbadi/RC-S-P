% !TEX root =R-zkCSP.tex



\section{Recurring Contingent PoR Payment Protocol}
In this section, we present recurring contingent PoR payment (RC-PoR-P). Since proofs of  retrievability (PoR), whose definition was given in Section \ref{PoR-def}, is a concrete instantiation of the generic verifiable service, RC-PoR-P is a concrete instantiation of the generic recurring contingent service payment (RC-S-P), when the service is PoR. Nevertheless, RC-PoR-P offers  two primary added features. Specifically, unlike RC-S-P, it (a) does not use any zero-knowledge proofs (even though either client or server can still be  malicious) which significantly improves  costs, and (b)  does not involve a third-party arbiter, which ultimately minimises trust assumption and costs.  In the following, first we  explain how the features are satisfied.


\noindent\textit{\textbf{Avoiding the Use of Zero-knowledge Proofs}}. In general, the majority of  PoR's are in the security model where a client is honest while the server is potentially malicious. They rely on metadata that is either a set of tags (e.g. MAC's or signatures) or a root of a Merkle tree,  constructed on  file blocks to ensure the file's availability. In the case where a client can  be malicious too,  if tags are used then using zero-knowledge proofs seem  an obvious choice, as it allows the client to ensure the server that the tags have been constructed correctly without leaking verification keys. However, this imposes significant computation and communication costs. We observed that using a Merkle tree would benefit our protocol from a couple of perspectives; in short, it removes the need for zero-knowledge proofs and it supports proof of misbehaviour. Our first observation is that if a Merkle tree is used to generate a metadata, then   there would be no need for the client to use zero-knowledge proofs to prove the correctness of the metadata to the server. Instead, the server can efficiently check the metadata's correctness, by reconstructing the Merkle tree on top of the file blocks. 


\noindent\textit{\textbf{Efficiently Eliminating Arbiter's Involvement}}. To totally eliminate the involvement of a third-party arbiter, one could use the Merkle tree-based PoR in RC-S-P and let a smart contract play the arbiter's entire role. In this case, there will be two  naive approaches.  One approach is that for each verification, the client verifies the server's proofs\footnote{In a Merkle tree-based PoR, the number of proofs that are sent to a verifier for each verification is linear with the number of challenges, e.g. 460 challenges  to ensure 99\% of file blocks is retrievable. In contrast, in a tag-based PoR, in each verification, the verifier receives only a few proofs.} and if it rejects them, then it sends the proofs (after the private time bubble)  to the contract who verifies the proofs again. However, this requires the smart contract to verify \emph{all} proofs which imposes a high cost. Another approach is that for each verification, the server's proofs  are always checked only by the contract, without the client's involvement. But, this requires the contract to always perform the verification, even if both parties  behaved honestly, which imposes unnecessary hight computation cost too. To  achieve our goal, we use a Merkle tree-based PoR  and let the client  verify the server's proofs locally. However, we use the idea of proof of misbehaviour, put forth in \cite{}. In particular, if the client detects invalid proofs for each verification  it only sends one invalid proof to the contract  who  checks the validity of that single proof (as apposed to checking all proofs). Thus, this eliminates the involvement of the arbiter and has a much lower cost. 



To present RC-PoR-P protocol, we will use the same approach we used to present RC-S-P. In particular, first we present the verifiable service, that is a (modified) Merkle tree-based PoR. Then, we upgrade it to the one that supports  identifiable abort, denoted by PoRID. Next,   we use PoRID to build RC-PoR-P. 

\subsection{Modified Merkle tree-based PoR}

In this section, we present a modified version of the standard Merkle tree-based PoR. At a high level, the protocol works as follows. The client encodes its file using an error-correcting code, splits the encoded file into blocks, and constructs a Merkle tree on top of the blocks. It locally keeps the tree's root and sends the blocks to the server who rebuilds the tree on the blocks. At a verification time, the client sends a pseudorandom function's key to the server who derives a predetermined number of pseudorandom  indices of the blocks, that indicates which blocks have been challenged. The server for each challenged block generates a Merkle tree proof and sends all proofs to the client. The client, given the root and   key, verifies all  proofs. If all proofs are accepted, then the client outputs $1$ and concludes that its file is retrievable (with a high probability). However, if  it rejects a set of proofs, it outputs $0$ along with an index of the challenged block whose proof was rejected. In the following, we first present the protocol and then elaborate on the  modifications we have applied. 

%, i.e. a verifier outputs (the index of) a rejected proof.  Recall, that in the standard PoR protocol the client is honest and the server is potentially malicious. 

\begin{enumerate}

\item\textbf{Client-side Setup}. $\mathtt{PoR.setup}(1^{\lambda},u)$  
\begin{enumerate}
\item Uses an error correcting code, e.g. Reed-Solomon codes, to encode  the file: $u$. Let $u'$ be the encoded file. It splits $u'$  into  blocks as follows, $u^{\scriptscriptstyle *}=u^{\scriptscriptstyle '}_{\scriptscriptstyle 0}||0,...,u^{\scriptscriptstyle '}_{\scriptscriptstyle m}||m$
\item Generates  metadata: $\sigma$, by constructing Merkle tree on blocks of $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.genTree}(u^{\scriptscriptstyle *})$. Let $\sigma$ be the root of the resulting tree, and $\beta$ be a security parameter. It sets public  parameters as $pk: (\sigma,\beta,m,\zeta)$, where $\zeta:(\psi,\eta, \iota)$ is a $\mathtt{PRF}$'s description, as it was defined in Section \ref{preliminaries}
\item Sends $pk$ and $u^{\scriptscriptstyle *}$ to $\mathcal{S}$
\end{enumerate}

\item\textbf{Client-side Query Generation}. $\mathtt{PoR.genQuery}(1^{\scriptscriptstyle\lambda}, pk)$ 
\begin{enumerate}
\item\label{key-chalenge} Picks a random key $\hat{k}$ of a pseudorandom function $\mathtt{PRF}$, i.e. $\hat{k}\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}^{\scriptscriptstyle\psi}$. It ensures the function outputs distinct values, i.e. $\forall i,j\in [0,m]: (\mathtt{PRF}(\hat{k},i)\bmod m+1)\neq(\mathtt{PRF}(\hat{k},j)\bmod m+1)$, where $i\neq j$

\item It sends $\hat{k}$ to $\mathcal{S}$
 
 \end{enumerate}
\item\label{PoR-server-prove}\textbf{Server-side Proof Generation} $\mathtt{PoR.prove}(u^{\scriptscriptstyle *},\hat{k},pk)$ 
 \begin{enumerate}
\item Derives $\beta$ pseudorandom indices from $\hat{k}$ as follows. $\forall i,1\leq i\leq \beta: q_{\scriptscriptstyle i}=\mathtt{PRF}(\hat{k},i)\bmod m+1$. Let ${\bm{q}}=[q_{\scriptscriptstyle 1},..., q_{\scriptscriptstyle \beta}]$

\item For each random index $q_{\scriptscriptstyle i}$, generates a Merkle tree proof: $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$, by  running Merkle tree proof generator function on $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.prove}(u^{*},q_{\scriptscriptstyle i})$. The final result  is $ {\bm{\pi}}=[(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})]_{\scriptscriptstyle q_{\scriptscriptstyle i}\in {\bm{q}}}$, where $i$-th element in $ {\bm{\pi}}$ corresponds to $i$-th pseudorandom value: $q_{\scriptscriptstyle i}$ and   each $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$ is path in the tree that proves its corresponding block: $u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}$ is a leaf node of the  tree. 

\item Sends $ {\bm{\pi}}$ to $\mathcal{C}$
 \end{enumerate}
\item\label{PoR-verify}\textbf{Client-side Proof Verification}. $\mathtt{PoR.verify}( {\bm{\pi}},\hat{k},pk)$ 
\begin{enumerate}
\item Regenerates $\beta$ pseudorandom indices that are derived from $\hat{k}$ as follows. $\forall i,1\leq i\leq \beta: q_{\scriptscriptstyle i}=\mathtt{PRF}(\hat{k},i)\bmod m+1$. Let $ {\bm{q}}=[q_{\scriptscriptstyle 1},..., q_{\scriptscriptstyle \beta}]$
\item Checks if the server has sent proofs related to all challenged file blocks. To do that, for all $i$ (where $1\leq i\leq \beta$),  it first parses every  element of $\pi$ as follows, $\mathtt{parse}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})=u^{\scriptscriptstyle '}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}||q_{_{\scriptscriptstyle i}}$, and then checks if its index: $q_{_{\scriptscriptstyle i}}$ equals $i$-th element of $ {\bm{q}}$. If all checks pass, then it proceeds to the next step. Otherwise,  it outputs $ {\bm{d}}:[0,i]$, where $i$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 


\item Checks if every path in  $ {\bm{\pi}}$ is valid and corresponds to the root, by calling $\mathtt{MT.verify}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\sigma)$. If all checks pass, it outputs $ {\bm{d}}=[1,\bot]$ (where $\bot$ denotes empty); otherwise, it outputs $ {\bm{d}}:[0,i]$, where $i$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 
\end{enumerate}
\end{enumerate}



%------------------------------------------------------------
%\begin{enumerate}
%%\item \textbf{keyGen}. $\mathtt{PoR.keyGen}(1^{\lambda})$. $\mathcal{C}$ sets $pk$ as public key, initially empty.    
%\item\textbf{Client-side Setup}. $\mathtt{PoR.setup}(1^{\lambda},u,M)$  
%\begin{enumerate}
%\item Uses an error correcting code, e.g. Reed-Solomon codes, to encode  the file: $u$. Let $u'$ be the encoded file. It splits $u'$  into  blocks as follows, $u^{\scriptscriptstyle *}=u^{\scriptscriptstyle '}_{\scriptscriptstyle 0}||0,...,u^{\scriptscriptstyle '}_{\scriptscriptstyle m}||m$.
%\item Generates  metadata: $\sigma$, by constructing Merkle tree on blocks of $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.genTree}(u^{\scriptscriptstyle *})$. Let $\sigma$ be the root of the resulting tree, and $\beta$ be a security parameter. It sets public  parameters as $pk: (\sigma,\beta,m)$.
%\item Sends $pk$ and $u^{\scriptscriptstyle *}$ to $\mathcal{S}$. 
%\end{enumerate}
%
%\item\textbf{Client-side Query Generation}. $\mathtt{PoR.genQuery}(1^{\scriptscriptstyle\lambda}, pk)$ 
%\begin{enumerate}
%\item Given the maximum block's index number: $m\in pk$, generates $\beta$ distinct random indices, where each random index is in the range $[0,m]$. 
%Let vector $ {\bm{q}}$ contain the  random indices, $q_{\scriptscriptstyle i}$
%\item It sends $ {\bm{q}}$ to $\mathcal{S}$
% 
% \end{enumerate}
%\item\label{PoR-server-prove}\textbf{Server-side Proof Generation} $\mathtt{PoR.prove}(u^{\scriptscriptstyle *}, {\bm{q}},pk)$ 
%
%For each random index $q_{\scriptscriptstyle i}$, generates a Merkle tree proof: $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$, by  running Merkle tree proof generator function on $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.prove}(u^{*},q_{\scriptscriptstyle i})$. The final result  is $ {\bm{\pi}}=[(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})]_{\scriptscriptstyle q_{\scriptscriptstyle i}\in {\bm{q}}}$, where $i$-th element in $ {\bm{\pi}}$ corresponds to $i$-th element in $ {\bm{q}}$; also   each $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$ is path in the tree and proves its corresponding block: $u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}$ is a leaf node of the  tree. $\mathcal{S}$ sends $ {\bm{\pi}}$ to $\mathcal{C}$.
%
%\item\label{PoR-verify}\textbf{Client-side Proof Verification} $\mathtt{PoR.verify}( {\bm{\pi}}, {\bm{q}},pk)$. 
%\begin{enumerate}
%\item Checks if the server has sent proofs related to all challenged file blocks. To do that,  it parses every $i$-th element of $\pi$ as: $\mathtt{parse}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})=u^{\scriptscriptstyle '}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}||q_{_{\scriptscriptstyle i}}$, and then checks if its index: $q_{_{\scriptscriptstyle i}}$ equals $i$-th element in $ {\bm{q}}$, where $0\leq i\leq \beta$. If all checks pass, then it proceeds to the next step. Otherwise,  it outputs $d:(0,j)$, where $j$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 
%
%
%\item Checks if every path in  $ {\bm{\pi}}$ is valid and corresponds to the root, by calling $\mathtt{MT.verify}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\sigma)$. If all checks pass, it outputs $d=1$; otherwise, it outputs $d:(0,j)$, where $j$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 
%\end{enumerate}
%\end{enumerate}
%------------------------------------------------------------

 The above protocol differs from the standard Merkle tree-based PoR from two perspectives; First and far most,  in step \ref{PoR-verify} in addition to outputting a binary value, the client outputs only one index of a rejected proof. This will enable any third-party who is given that index (and vectors of proofs and challenges) to verify the client's claim by checking only that proof, i.e. proof of misbehaviour. Second,   in step \ref{key-chalenge} instead of sending $\beta$ challenges, we allow the client to send only a key of a pseudorandom function to the server who can derive a set of challenges form it. This will ultimately  lead to a decrease in costs too, i.e. the client's communication and a smart contract's storage costs.   
   
   \begin{remark}
   Recall,  the generic definition of a verifiable service scheme (i.e. Definition \ref{service-def}) involves three algorithms: $F$, $M$, and $Q$. However, the three algorithms are implicit in the original definition of  PoR and accordingly in  PoR protocols. In the following, we explain how each algorithm is defined in PoR context.  $M$ is an algorithm that processes a file and generates metadata. For instance, when PoR uses a Merkle tree (to ensure the file's integrity and availability), then $M$ refers to the Merkle tree's algorithm that constructs a tree on top of the file blocks. Also,  $F$ is an algorithm that, during generating a PoR proof, processes a subset of the outsourced file, given the client's query (or challenged file blocks). For instance, if a PoR  utilises a Merkle tree, then $F$ refers to the algorithm that generates Merkle tree's proofs, i.e.  membership of the challenged file blocks. Furthermore, $Q$ can be  a pseudorandom function that generates a set of pseudorandom strings in a certain range, e.g. file block's indices. 
  
   \end{remark}


\input{PoRID-protocol}
















