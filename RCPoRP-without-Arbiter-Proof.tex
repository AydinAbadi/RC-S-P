% !TEX root =R-zkCSP.tex

 \begin{lemma}
 If SAP and blockchain are secure and  PoRID scheme supports correctness, soundness, and detectable abort, then ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer-2}. 
 \end{lemma}
 

 \begin{proof}[sketch]
 First, we  consider event  
 
  $$\Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j},{pp})= h_{\scriptscriptstyle j}\ \wedge (coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o)\Big)$$
   that captures the case where the server provides an accepting  proof, i.e. PoR, but makes an honest client withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Note, in ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ protocol, the total coins the client should receive after $z$ verifications is   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal S}-y_{\scriptscriptstyle\mathcal C})$. Since we focus on  $j$-th verification, the amounts of  coin that should be credited to the client for $j$-th verification is
 
 
% 
% $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Recall, in the protocol, the total coins the client should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$. Since we focus on  $j$-th verification, the amount of  coins that should be credited to the client for that verification is
  
  \begin{equation}\label{equ::what-client-recives-in-j-2}
   coin_{\scriptscriptstyle\mathcal{C},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal {S},j})+l(y_{\scriptscriptstyle\mathcal {S},j}-y_{\scriptscriptstyle\mathcal {C},j})
     \end{equation}

    
As the  proof is valid, an honest client accepts it and does not raise any dispute. But, the server  would be able to make the client  withdraw incorrect amounts of coin, if it manages to either convince the contract that the client has misbehaved, by making the contract output  $y_{\scriptscriptstyle\mathcal {C},j}=1$ through dispute resolution phase, or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters, e.g. $l$ or $o$. Nevertheless, it cannot falsely accuse the client of misbehaviour. As,  due to the security of SAP, it cannot  convince the contract to accept different query's parameters other than what was agreed with the client in the initiation phase. In particular, it cannot persuade the contract to accept  $\ddot{x}'_{\scriptscriptstyle qp}$ such that $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$.  Furthermore, if the adversary provides a valid statement then, due to the correctness of PoRID, values  $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$. Also,  due to the security of SAP, the server cannot change the payment parameters by persuading the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$.  Therefore, according to Equation \ref{equ::what-client-recives-in-j-2}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for $j$-th verification, with a high probability.  We now move on to event 
     
    
    
  $$  \Big(F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j}, {pp})\neq h_{\scriptscriptstyle j} \ \wedge (d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal{S},j}=0 \ \vee \  {coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l} ) \Big)$$
    
    
    
     
     It captures the case where the server provides an invalid  proof but either persuades the client to accept the proof, or  persuades the contract to set $y_{\scriptscriptstyle \mathcal{S},j}=0$  or makes the client  withdraw incorrect amounts of coin, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l$.   Nevertheless, due to the soundness of PoRID, the probability that a corrupt server can convince an honest client to accept invalid proof, i.e. outputs $d_{\scriptscriptstyle j}=1$, is negligible, $\mu(\lambda)$. So, the client detects it with a high probability and raises a dispute.  Also, the server may try to make the contract keep $y_{\scriptscriptstyle \mathcal {S},j}=0$. For $y_{\scriptscriptstyle \mathcal {S},j}=0$ to happen, it has to make the contract  recognise the client as the misbehaving party, i.e. makes the contract output $y_{\scriptscriptstyle \mathcal {C},j}=1$. In this case, the client's complaint would not be processed by the contract; therefore,  $y_{\scriptscriptstyle \mathcal {S},j}$ remains $0$.   Nevertheless, as we discussed above, the probability that the adversary makes the contract  recognise the client as misbehaving is negligible, $\mu(\lambda)$. Therefore, with a high probability  $y_{\scriptscriptstyle \mathcal {S},j}=1$ and $y_{\scriptscriptstyle \mathcal {C},j}=0$, after the contract  is invoked by the client or  server. The adversary may  try to  make the client withdraw  incorrect amounts of coin, e.g. in the case where it does not succeed in convincing the client or contract. To do so,  at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the client. But, it would succeed only with a negligible   probability, $\mu(\lambda)$, due to the security of SAP.   So, according to Equation \ref{equ::what-client-recives-in-j-2}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l$ coins for $j$-th verification, with a high probability. Furthermore, in   general, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}

%We first consider event $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Since the proof is valid, an honest client accepts it and does not raise any dispute. 
%  However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved (by making the arbiter increment $y_{\scriptscriptstyle\mathcal {C}}$  by $1$ through dispute resolution phase), or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key.  On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of VSID, algorithm $\mathtt{VSID.identify}()$ outputs $I_{\scriptscriptstyle j}=\bot$. Therefore, due to the security of SAP and correctness of VSID,   $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$.  Moreover,  due to the security of SAP, the server cannot persuade the contract to accept any statement other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision. Recall, in the protocol, the total coins the client receives after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$. Since we focus on each $j$-th verification, the amount of  coins credited to the client for that verification is
%  
%  \begin{equation}\label{equ::what-client-recives-in-j}
%   \frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal S}[j])-l\cdot y_{\scriptscriptstyle\mathcal C}[j]
%     \end{equation}
%     
%     In the above event, as we discussed,  with a high probability $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$ , so the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for that verification. 
%     
   

Next, we prove that ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ satisfies security against a malicious client. The proof is also slightly simpler than that  of RC-PoR-P against a malicious client (i.e. proof of Lemma \ref{lemma::RC-PoR-P-SecurityAgainstMaliciousClient}) as it does not involve any third-party arbiter. 


\begin{lemma}
 If SAP and blockchain are secure and  PoRID scheme supports correctness, inputs well-formedness, and detectable abort, then ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client-2}. 
\end{lemma}


\begin{proof}[sketch]
  First, we consider event 
  
   $$\Big((M(u^{\scriptscriptstyle *},k,{pp})= \sigma \  \wedge \ Q(\text{aux},k, {pp})= \bm{q}_{\scriptscriptstyle j})\ \wedge \
(coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)\Big)$$
  
  
  It captures the case where the client provides  accepting metadata and query  but makes the server withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$. According to  ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ protocol, the total coins the server should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal C}-y_{\scriptscriptstyle\mathcal S})$. As we focus on  $j$-th verification, the amount of  coins that should be credited to the server for $j$-th verification is
  
  \begin{equation}\label{equ::what-server-recives-in-j-2}
   coin_{\scriptscriptstyle\mathcal{S},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}}{z}+o(1-y_{\scriptscriptstyle\mathcal {S},j})+l(y_{\scriptscriptstyle\mathcal {C},j}-y_{\scriptscriptstyle\mathcal {S},j})
     \end{equation}
  
  
  
  Since the metadata and query are valid, an honest server accepts them and does not raise any dispute, so we have $y_{\scriptscriptstyle\mathcal{C},j}=0$.  The client however could  make the server  withdraw incorrect amounts of coin, if it manages to either convince the contract, in the dispute resolution phase,  that the server has misbehaved, i.e. makes the contract output $y_{\scriptscriptstyle\mathcal{S},j}=1$, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$, in the coin transfer phase. But, it cannot falsely accuse the server of misbehaviour, because due to the security of SAP, it cannot  convince the contract to accept different decryption key and pads' detail, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with a negligible  probability, $\mu(\lambda)$.  So, with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of PoRID, algorithm $\mathtt{PoRID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. Thus, due to the security of SAP and correctness of PoRID,  we would have $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$ with a high probability.    Also,  due to the security of SAP, the client cannot change the payment parameters by convincing the contract to accept any accepting statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was initially agreed  between the client and server (i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq \ddot{x}_{\scriptscriptstyle cp}$), except with a negligible  probability, $\mu(\lambda)$. That means, according to  Equation \ref{equ::what-server-recives-in-j-2}, the server is credited $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ coins for that verification, with a  high probability.  We now move on  to 
  
  $$\Big(M(u^{\scriptscriptstyle *},k,{pp})\neq \sigma\ \wedge \ a=1\Big)$$
     
     
    It captures the case where the server accepts  ill-formed metadata. But, due to PoRID's inputs well-formedness, the probability the event happens is negligible,  $\mu(\lambda)$. So, with a high probability $a=0$; in this case  the server does not raise any dispute, instead it avoids serving the client.    Next, we turn our attention   to 
     
     $$\Big(Q(\text{aux},k,{pp})\neq \bm{q}_{\scriptscriptstyle j})\ \wedge \ (b_{\scriptscriptstyle j}=1\ \vee \ y_{\scriptscriptstyle\mathcal{C},j}=0 \ \vee \ coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l)\Big)$$
     
       It considers the case where the client provides an invalid query, but  either convinces the server or contract to accept it, or  makes the server   withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l$. Due to inputs well-formedness of PoRID, the probability that the server outputs $b_{\scriptscriptstyle j}=1$ is negligible, $\mu(\lambda)$.  When the honest server rejects the query and raises a dispute, the contract checks the server's query and sets $y_{\scriptscriptstyle\mathcal{C},j}=1$. After that, due to the security of blockchain the client cannot make the contract to set $y_{\scriptscriptstyle\mathcal{C},j}=0$ except with probability $\mu(\lambda)$. Also, as discussed above, the client cannot make the contract recognise the  honest server as a misbehaving party with a probability significantly greater than $\mu(\lambda)$. That means with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$.  The adversary may still try to  make the server withdraw   incorrect amounts of coin (e.g. if the adversary does not succeed in convincing the server). To this end, at the coin transfer phase, it has to convince the contract to accept a  different  statement  than what was initially agreed with the server. However, due to the security of SAP, its  success probability is negligible, $\mu(\lambda)$.     Hence, according to Equation \ref{equ::what-server-recives-in-j-2}, the server is credited  $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l$ coins for $j$-th verification.   Also, due to the security of SAP, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
 \hfill\(\Box\)\end{proof}
  
  





In the following, we provide a lemma for  ${\text{RC-}\overline{\text{PoR}}\text{-P}}$'s privacy. For the lemma's  proof, we refer readers to the proof of Lemma \ref{lemma::RC-PoR-P-privacy}. 


\begin{lemma} If SAP is secure and the encryption scheme is semantically secure, then ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

%
%\begin{proof}[sketch] Briefly, due to SAP's privacy property, given  commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$ (stored in the blockchain as a result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}$ and $\bar{k}$), except with negligible probability $\mu(\lambda)$. Moreover, given  price list $pl$, and the parties' encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, the adversary learns nothing about the actual price agreed between the server and client, i.e. $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}.  Also, since each proof $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is encrypted and then padded, given $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ the adversary cannot tell  whether $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is associated with $u_{\scriptscriptstyle 0}$ or with $u_{\scriptscriptstyle 1}$ (i.e. where $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$ are the adversary's choice of files), with probability significantly greater than $\frac{1}{2}+\mu(\lambda)$. As each ciphertext $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is an output a semantically secure symmetric key encryption scheme, it leaks noting to the adversary.  The value of $a$ is also independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, so it leaks nothing about the service input $u_{\scriptscriptstyle\beta}$ and $\beta\in\{0,1\}$. Hence, the adversary cannot tell with a probability significantly greater than $\frac{1}{2}+\mu(\lambda)$ which file of its choice has been used as the server input. 
%
%Furthermore, since each query and padded encrypted proof leak no information and always contain a fixed number of elements, an adversary cannot tell the status of  proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu(\lambda)$, given  $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$.
%  \hfill\(\Box\)\end{proof}
%

