% !TEX root =R-zkCSP.tex



\subsection{Verifiable Service with Identifiable Abort (VSID) Definition}\label{subsec:VSID}


A protocol that realises only VS's definition, would be merely secure against a malicious server and  assumes the client is honest.  Although this  assumption would suffice in certain settings and has been used before (e.g. in \cite{}), it is rather strong and not suitable in the real world, especially when there are monetary incentives (e.g. service payment)  that encourage a client to misbehave. Therefore, in the following we enhance VS's definition to allow  (a) either party to be malicious and (b) a trusted third-party, \emph{arbiter}, to identify a corrupt party. We call an upgraded verifiable service scheme with that features ``verifiable service with identifiable abort'' (VSID), inspired by the notion of secure multi-party computation with identifiable abort \cite{DBLP:conf/crypto/IshaiOZ14}. 




\



\begin{definition}[VSID Scheme]\label{service-def} A verifiable service with identifiable abort  VSID $:=(\mathtt{VSID.keyGen}, $ $\mathtt{VSID.setup}, $ $\mathtt{VSID.serve},\mathtt{VSID.genQuery}$,$\mathtt{VSID.checkQuery},$ $\mathtt{VSID.prove},$ $\mathtt{VSID.verify}, \mathtt{VSID.identify})$ consists of eight algorithms defined below.


\begin{itemize}
\item[$\bullet$] $\mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)$.  A probabilistic algorithm run by the client. It takes as input the security parameter $1^{\lambda}$ and a function, $F$, that will be run on the client's input by the server. It outputs a secret/public verification key pair $k$. %$k$ containing a secret key $sk$ and a set of public parameters  $pk$.




\

\item[$\bullet$] $\mathtt{VSID.setup}(1^{\lambda}, u,k,M)\rightarrow (u^{\scriptscriptstyle *}, {pp},e)$. It is run by the client. It takes as input the security parameter $1^{\lambda}$,  the service  input $u$,  the key pair $k$, and metadata generator deterministic function $M$, where $M$ is publicly known. If an encoding is needed, then it encodes $u$, that results $u^{\scriptscriptstyle *}$; otherwise, $u^{\scriptscriptstyle *}=u$. It outputs  $u^{\scriptscriptstyle *}$, {(possibly file dependent) public parameters $pp$} and $e:=(\sigma,w_{\sigma})$, where $\sigma=M(u^{\scriptscriptstyle *},k, {pp})$ is a metadata and $w_{\sigma}$ is a proof asserting the metadata is well-structured.  

\

\item[$\bullet$] $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk, {pp})\rightarrow a\in\{0,1\}$. It is run by the server. It takes as input the encoded service input $u^{\scriptscriptstyle *}$, the pair $e:=(\sigma,w_{\sigma})$, public key $pk$, and {public parameters $pp$}. It outputs $a=1$, if the proof $w_{\sigma}$ is accepted, i.e. if the metadata is well-formed. Otherwise, it outputs $a=0$. 

\

\item[$\bullet$] $\mathtt{VSID.genQuery}(1^{\lambda},  \text{aux}, k,Q,{pp})\rightarrow c:=(\bm{q},\bm{w}_{\scriptscriptstyle q})$. A probabilistic algorithm run by the client. It takes as input the security parameter $1^{\lambda}$, auxiliary information $ \text{aux}$,  the key pair $k$,    query generator deterministic function $Q$ (where $Q$ is publicly known), and { public parameters $pp$}. It outputs a pair $c$ containing a query vector, $\bm{q}=Q( \text{aux},k,{pp})$,  and proofs, $\bm{w}_{\scriptscriptstyle q}$, proving the queries are well-structured. Depending on service types, $c$ might be  empty or  contain only random strings.





\

\item[$\bullet$] $\mathtt{VSID.checkQuery}(c, pk,{pp})\rightarrow b\in\{0,1\}$. It is run by the server. It takes as input a pair $c:=(\bm{q}, \bm{w}_{\scriptscriptstyle q})$ including queries and their proofs, as well as public key $pk$, and {public parameters $pp$}. It outputs $b = 1$ if the proofs $\bm{w}_{\scriptscriptstyle\sigma}$ are accepted, i.e. the queries are well-structured. Otherwise, it outputs $b = 0$.

\

\item[$\bullet$] $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c,pk, { pp})\rightarrow \pi$. It is run by the server. It takes as input the  encoded service input $u^{\scriptscriptstyle *}$, metadata $\sigma$, a pair $c:=(\bm{q},\bm{w}_{\scriptscriptstyle q})$,  public key $pk$, and { public parameters $pp$}. It outputs a proof pair, $\pi:=(F(u^{\scriptscriptstyle *},\bm{q},{ pp}),\delta)$ containing the function evaluation, i.e. $h=F(u^{\scriptscriptstyle *},\bm{q},{ pp})$, and a proof $\delta$ asserting the evaluation is performed correctly, where computing $h$ may involve $pk$ and computing $\delta$ may involve $\sigma$.



\

\item[$\bullet$] $\mathtt{VSID.verify}(\pi, \bm{q}, k, { pp})\rightarrow d\in\{0,1\}$. It is run by the client. It takes as input the proof $\pi$, queries $\bm{q}$,  key pair $k$, and  { public parameters pp}. If the proof is accepted, it outputs $d=1$; otherwise, it outputs $d=0$. 

\

\item[$\bullet$]  $\mathtt{VSID.identify}(\pi,c,k,e,u^{\scriptscriptstyle *}, { pp})\rightarrow I\in \{ \mathcal{C},\mathcal{S},\bot\}$. It is run by a third-party arbiter. It takes as input the proof $\pi$, query pair $c:=(\bm{q},\bm{w}_{\scriptscriptstyle q})$,  key pair $k$, metadata pair  $e:=(\sigma,w_{\sigma})$,  $u^{\scriptscriptstyle *}$, and { public parameters pp}. If   proof $w_{\scriptscriptstyle\sigma}$ or $\bm{w}_{\scriptscriptstyle q}$  is rejected, then it outputs $I=\mathcal C$; otherwise, if proof $\pi$ is rejected it outputs $I=\mathcal S$.  Otherwise, if  $w_{\scriptscriptstyle\sigma}, \bm{w}_{\scriptscriptstyle q}$, and $\pi$ are accepted, it outputs   $I=\bot$. 



\end{itemize}
\end{definition}


A VSID scheme  has four main properties; namely, it is (a) correct, (b) sound, (c)  inputs of clients are well-formed, and (d) a corrupt party can be identified by an arbiter. In the following, we formally define each of them.  Correctness requires that  the verification algorithm always accepts a proof generated by an honest prover and both parties are identified as honest.  It is formally stated as follows.

\begin{definition}[VSID Correctness] A verifiable service with identifiable abort scheme  is  correct   if for any functions $F,M,Q$, and any auxiliary information $\text{aux}$, the key generation algorithm produces keys $\mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)$ such that for any service input $u$, if $\mathtt{VSID.setup}(1^{\lambda}, u,k,M)$ $\rightarrow (u^{\scriptscriptstyle *},{pp},e)$, $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk,{pp})\rightarrow a$, $\mathtt{VSID.genQuery}(1^{\lambda}, $ $ \text{aux},k,Q,{pp})$ $ \rightarrow$ $ c$, $\mathtt{VSID.checkQuery}$ $(c, $ $pk,{pp})\rightarrow b,$  $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c,pk,{pp})\rightarrow \pi$, and \\$\mathtt{VSID.verify}(\pi,\bm{q},k,{pp})\rightarrow d$, then  $\mathtt{VSID.identify}(\pi,c,k,e,u^{\scriptscriptstyle *},{pp})\rightarrow I=\bot \  \  \wedge \ \ a=1 \ \ \wedge \  b=1 \ \ \wedge \  d=1$
\end{definition}



Intuitively, a VSID is sound  if a malicious server cannot convince the client to accept an incorrect output of $F$ except with negligible probability.  It is  formally stated as follows.

\begin{definition}[VSID Soundness]\label{deff::VSID-Soundness}  A VSID  is sound for functions $F,Q,M$, and an auxiliary information $aux$, if for any probabilistic polynomial time adversary $\mathcal{A}_{\scriptscriptstyle 1}$, there exists a negligible function $\mu(\cdot)$, such that for any security parameter $\lambda$: 
%\footnotesize{
\small{
$$ \Pr\left[
  \begin{array}{l}
F(u^{\scriptscriptstyle *}, \bm{q},{pp})\neq h \wedge d=1
\end{array} \middle |
    \begin{array}{l}
    \mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)\\
    \mathcal{A}_{\scriptscriptstyle 1}(1^{\scriptscriptstyle\lambda},pk, F)\rightarrow u\\
    \mathtt{VSID.setup}(1^{\lambda}, u, k, M)\rightarrow (u^{\scriptscriptstyle *},e,{pp})\\
    \mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q,{pp})\rightarrow c:=(\bm{q}, \bm{w}_{q})\\
     \mathcal{A}_{\scriptscriptstyle 1}(c,e, u^{\scriptscriptstyle *},{pp})\rightarrow \pi:=(h,\delta)\\
     \mathtt{VSID.verify}(\pi,\bm{q},k,{pp})\rightarrow d\\
\end{array}    \right]\leq \mu(\lambda).$$
}
%where the probability is taken over uniform  choice of $k\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}^{\scriptscriptstyle\lambda}$ as well as the randomness of $\mathcal{A}_{\scriptscriptstyle 1}$.
\end{definition}


A VSID has   well-formed inputs, if a malicious client cannot persuade a server to serve it on  ill-structured inputs (i.e. to accept  incorrect outputs of $M$ or $Q$). Below, we state the property formally.

\begin{definition}[VSID Inputs Well-formedness]\label{deff::VSID-Inputs-Well-formedess}  A  VSID  has  well-formed inputs for functions $F,Q,M$, and an auxiliary information $aux$,  if for  any probabilistic polynomial time adversary $\mathcal{A}_{\scriptscriptstyle 2}$, there exists a negligible function $\mu(\cdot)$, such that for any security parameter $\lambda$: 
%\footnotesize{
\small{
$$ \Pr\left[
  \begin{array}{l}
  (M(u^{\scriptscriptstyle *},k,{pp})\neq \sigma \wedge a=1) \vee\\ (Q(\text{aux},k,{pp})\neq \bm{q}) \wedge  b=1)\\
%(M(u^{\scriptscriptstyle *},k)\neq \sigma \lor Q(\text{aux},k)\neq q) \wedge\\ (a=1 \ \vee b=1)
\end{array} \middle |
    \begin{array}{l}
    
    \mathcal{A}_{\scriptscriptstyle 2}(1^{\scriptscriptstyle\lambda},F,M,Q)\rightarrow (u^{\scriptscriptstyle *},k:=(sk,pk),e:=(\sigma,w_{\sigma}),{pp})\\
    \mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk,{pp})\rightarrow a\\
       \mathcal{A}_{\scriptscriptstyle 2}(\text{aux},k)\rightarrow c:=(\bm{q},\bm{w}_{\scriptscriptstyle q})\\
    \mathtt{VSID.checkQuery}(c, pk,{pp})\rightarrow b\\
\end{array}    \right]\leq \mu(\lambda).$$
}
%where the probability is taken over the randomness used in  proofs $w_{\scriptscriptstyle q}$ and $w_{\scriptscriptstyle\sigma}$  as well as  the randomness of $\mathcal{A}_{\scriptscriptstyle 2}$.

\end{definition}

The   above property ensures an honest server can detect  a malicious client if the client provides ill-structured inputs. It is further required that a malicious party to be identified by an honest third-party, arbiter. This ensures that in the case of dispute (or false accusation) a malicious party can be pinpointed. A VSID supports  detectable abort if a corrupt party can escape from being identified, by the arbiter,  with only negligible probability.  Formally:



\begin{definition}[VSID Detectable Abort]\label{def::VSID-Identifiable-Abort}  A  VSID  supports  detectable for functions $F,Q,M$, and an auxiliary information $aux$, if  the following hold: 

\begin{enumerate}
\item For any PPT adversary $\mathcal{A}_{\scriptscriptstyle 1}$ there exists a negligible function $\mu_{\scriptscriptstyle 1}(\cdot)$ such that for any  security parameter $\lambda$:
{\small
$$ \Pr\left[
  \begin{array}{l}
 d=0 \wedge I\neq\mathcal{S}
\end{array} \middle |
    \begin{array}{l}
    \mathtt{VSID.keyGen}(1^{\lambda},F)\rightarrow k:=(sk,pk)\\
    \mathcal{A}_{\scriptscriptstyle 1}(1^{\scriptscriptstyle\lambda},pk, F)\rightarrow u\\
    \mathtt{VSID.setup}(1^{\lambda}, u, k, M,{pp})\rightarrow (u^{\scriptscriptstyle *},e)\\
    \mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q,{pp})\rightarrow c:=(\bm{q}, \bm{w}_{q})\\
     \mathcal{A}_{\scriptscriptstyle 1}(c,e, u^{\scriptscriptstyle *},{pp})\rightarrow \pi:=(h,\delta)\\
     \mathtt{VSID.verify}(\pi,\bm{q},k,{pp})\rightarrow d\\
     \mathtt{VSID.identify}(\pi,c,k,e,u^{\scriptscriptstyle *},{pp})\rightarrow I\\
\end{array}    \right]\leq \mu(\lambda).$$
}
%\normalsize

\item For any PPT adversary $\mathcal{A}_{\scriptscriptstyle 2}$ there exists a negligible function $\mu_{\scriptscriptstyle 2}(\cdot)$ such that for any  security parameter $\lambda$:
{\small
$$ \Pr\left[
  \begin{array}{l}
 (a=0 \vee b=0)\wedge I\neq\mathcal{C}
\end{array} \middle |
    \begin{array}{l}
    
    \mathcal{A}_{\scriptscriptstyle 2}(1^{\scriptscriptstyle\lambda},F,M,Q)\rightarrow (u^{\scriptscriptstyle *},k:=(sk,pk),e:=(\sigma,w_{\sigma}),{pp})\\
    \mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk,{pp})\rightarrow a\\
       \mathcal{A}_{\scriptscriptstyle 2}(\text{aux},k)\rightarrow c:=(\bm{q},\bm{w}_{\scriptscriptstyle q})\\
    \mathtt{VSID.checkQuery}(c, pk,{pp})\rightarrow b\\
    \mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c,pk,{pp})\rightarrow \pi\\
    \mathtt{VSID.identify}(\pi,c,k,e,u^{\scriptscriptstyle *},{pp})\rightarrow I\\
\end{array}    \right]\leq \mu(\lambda).$$
}

\end{enumerate}
\end{definition}


\subsubsection{Lighter VSID Scheme ($\text{VSID}_{\scriptscriptstyle\text{light}}$)}\label{remark::light-VSID}
In the VSID  definition, algorithm  $\mathtt{VSID.identify}(.)$    allows an arbiter  to identify a misbehaving party even in the setup phase. Nevertheless, often it is sufficient  to let the arbiter pinpoint a corrupt party \emph{after} the client and server agree to deal with each other, i.e. after the setup when the server runs  $\mathtt{VSID.serve}(.)$ and outputs $1$. A VSID protocol that meets the latter (lighter) requirements, denoted by $\text{VSID}_{\scriptscriptstyle \text{light}}$, would impose lower costs  especially when $u$ and elements of $e$ are of large size. In $\text{VSID}_{\scriptscriptstyle\text{light}}$  the arbiter algorithm, i.e. $\mathtt{VSID.identify}(.)$, needs to take only $(\pi, c, k, e',{pp})$ as input, where $e'\subset e$. Note also $u^{\scriptscriptstyle *}$ is not given to the arbiter. In the light version, the arbiter   skips  checking the correctness of metadata. So, this requires two changes to the VSID definition, (a) the arbiter algorithm would be   $\mathtt{VSID.identify}(\pi,c,k,e',{pp})\rightarrow I$, and (b) in case 2, in Definition \ref{def::VSID-Identifiable-Abort} we would have $b=0\wedge I\neq \mathcal C$, so event $a=0$ is excluded. In this paper, any time we refer to $\text{VSID}_{\scriptscriptstyle\text{light}}$, we assume the above minor adjustments are applied to the VSID definition. 






