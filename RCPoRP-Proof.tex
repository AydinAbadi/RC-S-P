% !TEX root =R-zkCSP.tex

\subsection{Security Analysis of RC-PoR-P}

In this section, we analyse the security of RC-PoR-P protocol, presented in Section \ref{sec::RC-PoR-P-protocol}. We first present the protocol's primary security theorem. 



\begin{theorem}
The RC-PoR-P protocol is secure, w.r.t. Definition \ref{def::RC-S-P-Security}, if PoRID, SAP, and signature scheme are secure and the encryption scheme is semantically secure. 
\end{theorem}


 To prove the above theorem, we show that RC-PoR-P meets all security properties defined in Section \ref{sec::RC-S-P-Definition}.  Since RC-PoR-P is instantiation of RC-S-P, its proof has  similarities with the latter one. Nevertheless, for the sake of completeness we provide its proof. We start by proving that RC-PoR-P satisfies security against a malicious server.   


 \begin{lemma}\label{lemma::RC-PoR-P-SecurityAgainstMaliciousServer}
 If SAP and signature scheme are secure and  PoRID scheme supports correctness, soundness, and detectable abort, then RC-PoR-P is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}. 
 \end{lemma}
 

 \begin{proof}[sketch] First, we  consider event    $\Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j},{pp})= h_{\scriptscriptstyle j}\ \wedge \Big((coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o)  \vee (coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\ \wedge\  y'_{\scriptscriptstyle \mathcal {S},j}=1)\Big)\Big)$ that captures the case where the server provides an accepting  proof, i.e. PoR, but makes an honest client withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$, or it makes the arbiter withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$, if it unnecessarily invokes the arbiter. Because the  proof is valid, an honest client accepts it and does not raise a dispute. But, the server  could make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved, by making the arbiter output  $y_{\scriptscriptstyle\mathcal {C},j}=1$ through the dispute resolution phase, or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters, or send a message on the client's behalf to unnecessarily invoke the arbiter. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept a different decryption key (that will be used to decrypt queries) other than what was agreed with the client in the initiation phase. In particular,  it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's queries are accessed by  the arbiter with a high probability.   Furthermore, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to PoRID's correctness, algorithm $\mathtt{PoRID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. Therefore, due to the security of SAP and correctness of PoRID,   the following holds  $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$. Furthermore,  because of SAP's security, the server cannot change the payment parameters by convincing the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with a negligible probability, $\mu(\lambda)$. Also, due to the signature's  security, the adversary  cannot send a message on behalf of the client, to unnecessarily invoke the arbiter and make  it output $y'_{\scriptscriptstyle\mathcal {C},j}=1$, except with   a negligible probability $\mu(\lambda)$; so with a high probability $y'_{\scriptscriptstyle\mathcal {C},j}=0$.  Recall, in RC-PoR-S or RC-S-P  protocol, according to Equation \ref{equ::what-client-recives-in-j}, the amounts of  coin that should be credited to the client for $j$-th verification is $coin_{\scriptscriptstyle\mathcal{C},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal {S},j})-l(y_{\scriptscriptstyle\mathcal {C},j}+y'_{\scriptscriptstyle\mathcal {C},j})$. Since it holds that $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=y'_{\scriptscriptstyle\mathcal {C},j}=0$,  the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for $j$-th verification, with a high probability.   Furthermore, as stated above, if the adversary invokes the arbiter, the arbiter with a high probability outputs $I_{\scriptscriptstyle j}=\bot$ that yields  $y'_{\scriptscriptstyle\mathcal{S},j}=1$. In  RC-PoR-P or RC-S-P protocol, according to Equation \ref{equ::arbiter}, the amounts of coin the arbiter should be credited for $j$-th verification is $coin_{\scriptscriptstyle\mathcal{A}r,j}= l(y_{\scriptscriptstyle\mathcal {S},j}+y_{\scriptscriptstyle\mathcal {C},j}+y'_{\scriptscriptstyle\mathcal {S},j}+y'_{\scriptscriptstyle\mathcal {C},j})$. As shown above $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=y'_{\scriptscriptstyle\mathcal{C},j}=0$ and $y'_{\scriptscriptstyle\mathcal{S},j}=1$, which   means $l$ coins  is credited to the arbiter for $j$-th verification if it is unnecessarily invoked by the adversary.  In this case, for the server to make the arbiter withdraw other than that amounts, it has to send to the contract (at the coin transfer phase) an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters. But, as stated above, it cannot succeed with a probability significantly greater than $\mu(\lambda)$. 
 

 
 We now move on to event  $\Big(\Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j}, {pp})\neq h_{\scriptscriptstyle j}\Big) \ \wedge \Big(d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal {S},j}=0 \ \vee coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z} \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\Big)\Big)$  which captures the case where the server provides an invalid  proof (i.e. PoR) but it either convinces the client to accept the proof, or  persuades the arbiter to accept it  or makes the client or arbiter withdraw  incorrect amounts of coin, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ or $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively.   Due to the soundness of PoRID, the probability that the adversary can convince an honest client to accept invalid proof is negligible, $\mu(\lambda)$. Therefore, the client outputs $d_{\scriptscriptstyle j}=0$  with a high probability and raises a dispute. Furthermore, the server may try to make the arbiter keep $y_{\scriptscriptstyle \mathcal {S},j}=0$. For the adversary to succeed, it has to make the arbiter  identify the client as the misbehaving party, and output $y_{\scriptscriptstyle \mathcal {C},j}=1$. In this case, according to RC-PoR-P protocol, the client's complaint (for $j$-th verification) would not be processed by the arbiter. This  allows   $y_{\scriptscriptstyle \mathcal {S},j}$ to remain $0$.   But, as we argued above, the probability that the adversary makes the arbiter  recognise the client as misbehaving is at most $\mu(\lambda)$. So, with a high probability  $y_{\scriptscriptstyle \mathcal {S},j}=1$ and $y_{\scriptscriptstyle \mathcal {C},j}=0$, after the arbiter  is invoked by the client or  server. It also holds that $y'_{\scriptscriptstyle \mathcal {C},j}=y'_{\scriptscriptstyle \mathcal {S},j}=0$, because  the arbiter has already identified a misbehaving party. Moreover, due to SAP's security, the probability that the adversary succeeds in changing the payment parameters to  make the client or arbiter withdraw  incorrect amounts of coin is negligible too.    So, according to Equations \ref{equ::what-client-recives-in-j} and \ref{equ::arbiter}  the client and arbiter are credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ and $l$ coins for $j$-th verification respectively.   Also, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}


Next, we provide a lemma which formally states  RC-PoR-P is secure against a malicious client and then we prove the lemma. 


\begin{lemma}\label{lemma::RC-PoR-P-SecurityAgainstMaliciousClient}
 If SAP and signature scheme are secure and  PoRID scheme supports correctness, inputs well-formedness, and detectable abort, then RC-PoR-P is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client}. 
\end{lemma}


\begin{proof}[sketch] We first consider event $\Big(\Big(M(u^{\scriptscriptstyle *},k,{pp})= \sigma   \wedge  Q(\text{aux},k, {pp})= \bm{q}_{\scriptscriptstyle j}\Big) \wedge \Big((coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)\vee  (coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l \wedge  y'_{\scriptscriptstyle \mathcal {C},j}=1)\Big)\Big)$. It captures the case where the client provides  accepting metadata (i.e. a Merkle tree and its root) and query  but makes the server withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$, or makes the arbiter withdraw incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$, if it unnecessarily invokes the arbiter.  Since the metadata and queries  are valid and correctly structured, an honest server accepts them and does not raise a dispute, so $y_{\scriptscriptstyle\mathcal{C},j}=0$.  However, the client could  make the server  withdraw incorrect amounts of coin, if it manages to either persuade the arbiter to recognise the server as misbehaving, i.e. makes the arbiter output $y_{\scriptscriptstyle\mathcal{S},j}=1$, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$ or send a message on the client's behalf to unnecessarily invoke the arbiter.  Nevertheless, it cannot falsely accuse the server of misbehaviour. Because,  due to SAP's security, it cannot  convince the arbiter to accept different decryption key and pads' detail, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with a negligible probability, $\mu(\lambda)$. This ensures   the arbiter is given the honest server's messages, with a high probability. Therefore, with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. Also, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of PoRID, algorithm $\mathtt{PoRID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. So, due to the security of SAP and correctness of PoRID, the following holds $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$ with a high probability.  Moreover,  it holds that $y'_{\scriptscriptstyle\mathcal{S}} = 0$ because the honest server never invokes the arbiter when the client's queries are well-structured and due to the signature scheme's security, the client cannot send a message on the server's behalf to unnecessarily invoke the arbiter.  Note,  due to SAP's security, the client cannot change the payment parameters by convincing the contract to accept any  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was initially agreed  between the client and server (i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq \ddot{x}_{\scriptscriptstyle cp}$) except with a negligible  probability, $\mu(\lambda)$. Recall, according to Equation \ref{equ::what-server-recives-in-j}, in RC-PoR-P or RC-S-P protocol, the total coins the server should be credited for $j$-th verification is $coin_{\scriptscriptstyle\mathcal{S},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}}{z}+o(1-y_{\scriptscriptstyle\mathcal {S},j})-l(y_{\scriptscriptstyle\mathcal {S},j}+y'_{\scriptscriptstyle\mathcal {S},j})$. Therefore, given $y_{\scriptscriptstyle\mathcal{S},j}=y'_{\scriptscriptstyle\mathcal{S},j}=0$,  the server is credited $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ coins for $j$-th verification, with a  high probability.  Furthermore, as stated above, if the adversary invokes the arbiter, the arbiter with a high probability outputs $I_{\scriptscriptstyle j}=\bot$ which yields  $y'_{\scriptscriptstyle\mathcal{C},j}=1$. Hence, according to Equation \ref{equ::arbiter}, the arbiter for $j$-th verification is credited $l$ coins, with a high probability.  As previously stated,  due to the security of SAP, the client cannot make the arbiter withdraw incorrect coin amounts  by changing the payment parameters  and persuading the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$. We now turn our attention to $\Big(M(u^{\scriptscriptstyle *},k,{pp})\neq \sigma\ \wedge \ a=1\Big)$   which captures the case where the server accepts an ill-formed metadata. But, due to PoRID's inputs well-formedness, the probability the event happens is negligible, $\mu(\lambda)$; therefore, with a high probability $a=0$. In this  case,  the server does not raise any dispute, instead it avoids serving the client. 

Next, we move on to  $\Big((Q(\text{aux},k,{pp})\neq \bm{q}_{\scriptscriptstyle j}) \wedge  (b_{\scriptscriptstyle j}=1 \vee  y_{\scriptscriptstyle\mathcal{C},j}=0  \vee  coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o  \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l )\Big)$    which considers the case where the client provides an invalid query, but  either convinces the server or arbiter to accept it, or  makes the server or arbiter  withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ or  $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively. But, due to PoRID's inputs well-formedness, the probability that the server outputs $b_{\scriptscriptstyle j}=1$ is negligible $\mu(\lambda)$. Note, when the honest server rejects the query and raises a dispute, the arbiter checks the query and sets $y_{\scriptscriptstyle\mathcal{C},j}=1$. After that, due to  RC-PoR-P design, the client cannot make the arbiter set $y_{\scriptscriptstyle\mathcal{C},j}=0$ (unless it manages to modify the blockchain's content later on, but its probability of success is negligible due to the security of blockchain).  As already stated, the client cannot make the arbiter recognise the  honest server as a misbehaving party with a probability significantly greater than $\mu(\lambda)$. That means, with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. Furthermore, since the arbiter  has identified a misbehaving party, the following holds   $y'_{\scriptscriptstyle\mathcal{C},j}=y'_{\scriptscriptstyle\mathcal{S},j}=0$.  The adversary may still try to  make them withdraw  incorrect amounts of coin. To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the server. But, due to SAP's  security, its  success probability is  $\mu(\lambda)$.  Hence, according to Equations \ref{equ::what-server-recives-in-j} and \ref{equ::arbiter} the server and arbiter are credited $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ and $l$ coins respectively for $j$-th verification, with a high probability.  Furthermore, due to SAP's  security, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase. \hfill\(\Box\)\end{proof}
  
 

In the following, we prove  RC-PoR-P's privacy. Since the  proof has many similarities with  the  proof of RC-S-P's privacy (i.e. proof of Lemma \ref{lem::RC-S-P-Privacy}) in the following we provide only the proof's outline.  



\begin{lemma}\label{lemma::RC-PoR-P-privacy} If SAP is secure and the encryption scheme is semantically secure, then RC-PoR-P preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

\begin{proof}[sketch] Briefly, due to SAP's privacy property, given  commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$ (stored in the blockchain as a result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}$ and $\bar{k}$), except with negligible probability $\mu(\lambda)$. Moreover, given  price list $pl$, and the parties' encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, the adversary learns nothing about the actual price agreed between the server and client, i.e. $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}.  Also, since each proof $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is encrypted and then padded, given $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ the adversary cannot tell  whether $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is associated with $u_{\scriptscriptstyle 0}$ or with $u_{\scriptscriptstyle 1}$ (i.e. where $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$ are the adversary's choice of files), with probability significantly greater than $\frac{1}{2}+\mu(\lambda)$. As each $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ is an output of semantically secure symmetric key encryption and its size is fixed, it  leaks noting to the adversary.  The value of $a$ is also independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, so it leaks nothing about the choice of  input file $u_{\scriptscriptstyle\beta}$ and $\beta\in\{0,1\}$. Hence, the adversary cannot tell with a probability significantly greater than $\frac{1}{2}+\mu(\lambda)$ which file of its choice has been used as the server input. 

Furthermore, since each query and padded encrypted proof leak no information and always contain a fixed number of elements, an adversary cannot tell the status of  proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu(\lambda)$, given  $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$.
  \hfill\(\Box\)\end{proof}


