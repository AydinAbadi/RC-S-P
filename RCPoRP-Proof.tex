% !TEX root =R-zkCSP.tex

 \begin{lemma}
 If SAP and blockchain are secure and  PoRID scheme supports correctness, soundness, and detectable abort, then RC-PoR-P is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer-2}. 
 \end{lemma}
 

 \begin{proof}[sketch]
 First, we  consider event  
 
  $$\Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j},{pp})= h_{\scriptscriptstyle j}\ \wedge (coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o)\Big)$$
   that captures the case where the server provides an accepting  proof, i.e. PoR, but makes an honest client withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Note, in RC-PoR-P protocol, the total coins the client should receive after $z$ verifications is   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal S}-y_{\scriptscriptstyle\mathcal C})$. Since we focus on  $j$-th verification, the amounts of  coin that should be credited to the client for $j$-th verification is
 
 
% 
% $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Recall, in the protocol, the total coins the client should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$. Since we focus on  $j$-th verification, the amount of  coins that should be credited to the client for that verification is
  
  \begin{equation}\label{equ::what-client-recives-in-j-2}
   coin_{\scriptscriptstyle\mathcal{C},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal {S},j})+l(y_{\scriptscriptstyle\mathcal {S},j}-y_{\scriptscriptstyle\mathcal {C},j})
     \end{equation}

    
As the  proof is valid, an honest client accepts it and does not raise any dispute. But, the server  would be able to make the client  withdraw incorrect amounts of coin, if it manages to either convince the contract that the client has misbehaved, by making the contract output  $y_{\scriptscriptstyle\mathcal {C},j}=1$ through dispute resolution phase, or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters, e.g. $l$ or $o$. Nevertheless, it cannot falsely accuse the client of misbehaviour. As,  due to the security of SAP, it cannot  convince the contract to accept different query's parameters other than what was agreed with the client in the initiation phase. In particular, it cannot persuade the contract to accept  $\ddot{x}'_{\scriptscriptstyle qp}$ such that $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$.  Furthermore, if the adversary provides a valid statement then, due to the correctness of PoRID, values  $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$. Therefore, according to Equation \ref{equ::what-client-recives-in-j-2}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for that verification, with a high probability. Note,  due to the security of SAP, the server cannot change the payment parameters by persuading the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with  probability $\mu(\lambda)$.  We now move on to event 
     
    
    
  $$  \Big(F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j}, {pp})\neq h_{\scriptscriptstyle j} \ \wedge (d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal{S},j}=0 \ \vee \  {coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l} ) \Big)$$
    
    
    
     
     It captures the case where the server provides an invalid  proof but either persuades the client to accept the proof, or  persuades the contract to accept the proof  or makes the client  withdraw incorrect amounts of coin, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l$.   Nevertheless, due to the soundness of PoRID, the probability that a corrupt server can convince an honest client to accept invalid proof, i.e. outputs $d_{\scriptscriptstyle j}=1$, is  $\mu(\lambda)$. So, the client detects it with a high probability and raises a dispute. 
     
     \
     
     \
     
     Also, the server may try to make the contract keep $y_{\scriptscriptstyle \mathcal {S},j}=0$. For $y_{\scriptscriptstyle \mathcal {S},j}=0$ to happen, it has to make the contract  recognise the client as the misbehaving party, i.e. makes the contract output $y_{\scriptscriptstyle \mathcal {C},j}=0$. In this case, the client's complaint would not be processed by the contract; therefore,  $y_{\scriptscriptstyle \mathcal {S},j}$ remains $0$.   Nevertheless, as we discussed above, the probability that the adversary makes the contract  recognise the client as misbehaving is  $\mu(\lambda)$. Therefore, with a high probability  $y_{\scriptscriptstyle \mathcal {S},j}=1$ and $y_{\scriptscriptstyle \mathcal {C},j}=0$, after the contract  is invoked by the client or  server.  So, according to Equation \ref{equ::what-client-recives-in-j-2}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}+l$ coins for $j$-th verification, with a high probability. The adversary may  try to  make the client withdraw  incorrect amounts of coin, e.g. in the case where it does not succeed in convincing the client or contract. To this end,  at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the client. But, it would succeed only with  probability $\mu(\lambda)$, due to the security of SAP. Furthermore, in   general, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}

%We first consider event $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Since the proof is valid, an honest client accepts it and does not raise any dispute. 
%  However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved (by making the arbiter increment $y_{\scriptscriptstyle\mathcal {C}}$  by $1$ through dispute resolution phase), or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key.  On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of VSID, algorithm $\mathtt{VSID.identify}()$ outputs $I_{\scriptscriptstyle j}=\bot$. Therefore, due to the security of SAP and correctness of VSID,   $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$.  Moreover,  due to the security of SAP, the server cannot persuade the contract to accept any statement other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision. Recall, in the protocol, the total coins the client receives after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$. Since we focus on each $j$-th verification, the amount of  coins credited to the client for that verification is
%  
%  \begin{equation}\label{equ::what-client-recives-in-j}
%   \frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal S}[j])-l\cdot y_{\scriptscriptstyle\mathcal C}[j]
%     \end{equation}
%     
%     In the above event, as we discussed,  with a high probability $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$ , so the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for that verification. 
%     
   




\begin{lemma}
 If SAP and blockchain are secure and  PoRID scheme supports correctness, inputs well-formedness, and detectable abort, then RC-PoR-P is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client-2}. 
\end{lemma}


\begin{proof}[sketch]
  First, we consider event 
  
   $$\Big((M(u^{\scriptscriptstyle *},k,{pp})= \sigma \  \wedge \ Q(\text{aux},k, {pp})= \bm{q}_{\scriptscriptstyle j})\ \wedge \
(coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)\Big)$$
  
  
  It captures the case where the client provides  accepting metadata and query  but makes the server withdraw an incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$. According to  RC-PoR-P protocol, the total coins the server should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal C}-y_{\scriptscriptstyle\mathcal S})$. As we focus on  $j$-th verification, the amount of  coins that should be credited to the server for $j$-th verification is
  
  \begin{equation}\label{equ::what-server-recives-in-j-2}
   coin_{\scriptscriptstyle\mathcal{S},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}}{z}+o(1-y_{\scriptscriptstyle\mathcal {S},j})+l(y_{\scriptscriptstyle\mathcal {C},j}-y_{\scriptscriptstyle\mathcal {S},j})
     \end{equation}
  
  
  
  Since the metadata and query's proofs are valid, an honest server accepts them and does not raise any dispute, so we have $y_{\scriptscriptstyle\mathcal{C},j}=0$.  The client can  make the server  withdraw incorrect amounts of coins, if it manages to either convince the contract, in the dispute resolution phase,  that the server has misbehaved, i.e. makes the contract output $y_{\scriptscriptstyle\mathcal{S},j}=1$, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$, in the coin transfer phase. But, it cannot falsely accuse the server of misbehaviour, because due to the security of SAP, it cannot  convince the contract to accept different decryption key and pads, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with  probability $\mu(\lambda)$.  So, with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of PoRID, algorithm $\mathtt{PoRID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. Thus, due to the security of SAP and correctness of PoRID,  we would have $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$ with a high probability.    That means, according to  Equation \ref{equ::what-server-recives-in-j-2}, the server is credited $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ coins for that verification, with a  high probability. Note,  due to the security of SAP, the client cannot convince the contract to accept any accepting statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was initially agreed  between the client and server (i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq \ddot{x}_{\scriptscriptstyle cp}$), except with   probability $\mu(\lambda)$. We now move on  to 
  
  $$\Big(M(u^{\scriptscriptstyle *},k,{pp})\neq \sigma\ \wedge \ a=1\Big)$$
     
     
    It captures the case where the server accepts  ill-formed metadata. But, due to PoRID's inputs well-formedness the probability the event happens is  $\mu(\lambda)$. So, with a high probability $a=0$. In the case where the server does not raise any dispute, instead it avoids serving the client.    Next, we turn our attention   to 
     
     $$\Big(Q(\text{aux},k,{pp})\neq \bm{q}_{\scriptscriptstyle j})\ \wedge \ (b_{\scriptscriptstyle j}=1\ \vee \ y_{\scriptscriptstyle\mathcal{C},j}=0 \ \vee \ coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l)\Big)$$
     
       It considers the case where the client provides an invalid query, but  either convinces the server or contract to accept it, or  makes the server   withdraw  incorrect amounts of coin, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l$. Due to inputs well-formedness of PoRID, the probability that the server outputs $b_{\scriptscriptstyle j}=1$, in this case is $\mu(\lambda)$.  When the server rejects the query and raises a dispute, the client may try to convince the contract, and make it output $y_{\scriptscriptstyle \mathcal {C},j}=0$, e.g. by sending a complaint. For the adversary to succeed, first it has to send a message on the server's behalf at time $\texttt{k}_{\scriptscriptstyle 1}$, but due to the security of blockchain its winning probability is at most $\mu(\lambda)$. Also,   either it has to provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the server (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification. But,  due to the security of SAP, its probability of success is $\mu(\lambda)$. Or it has to make the contract  accept an invalid query, i.e. makes the contract output $y_{\scriptscriptstyle\mathcal{C},j}=0$, but due to the detectable abort property of PoRID, its probability of success is  $\mu(\lambda)$ too. Therefore, with a high probability we have $y_{\scriptscriptstyle\mathcal{C},j}=1$. Also, as discussed above, the client cannot make the contract recognise the  honest server as a misbehaving party with a probability significantly greater than $\mu(\lambda)$. That means with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. Hence, according to Equation \ref{equ::what-server-recives-in-j-2} the server is credited  $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o+l$ coins for $j$-th verification.   The adversary may still try to  make the server withdraw   incorrect amounts of coin (e.g. if the adversary does not succeed in convincing the server). To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the server. However, due to the security of SAP, its  success probability is  $\mu(\lambda)$. Also, due to the security of SAP, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
 \hfill\(\Box\)\end{proof}
  
  
  Prior to proving  RC-S-P's privacy, we provide a lemma that will be used in the privacy's proof. Informally, the lemma states that encoded coins leaks no information about the actual amounts of coin $(o,l)$, agreed between the client and server. 


\begin{lemma}\label{lemma::encoded-coins} Let $\beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}$, price list be $\{(o_{\scriptscriptstyle 0},l_{\scriptscriptstyle 0}),(o_{\scriptscriptstyle 1},l_{\scriptscriptstyle 1})\}$, and encoded coin amounts be $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}= z\cdot(Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta},l_{\scriptscriptstyle|\beta-1|}))$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot(Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle |\beta-1|}))$. Then, given the price list, $z$, $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$, and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, an adversary $\mathcal{A}$ cannot tell the value of $\beta$ with probability significantly greater than $\frac{1}{2}$ (where the probability is taken over the choice of $\beta$ and the randomness of $\mathcal{A}$).
\end{lemma}



\begin{proof}
As it is evident, the list and $z$ contains no information about $\beta$. Also, since  $z$ is a public value, we could have   $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z} = Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle|\beta-1|})$. It is not hard to see $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ is a function of maximum value of $(o_{\scriptscriptstyle 0},o_{\scriptscriptstyle 1})$, and maximum value of $(l_{\scriptscriptstyle 0},l_{\scriptscriptstyle 1})$. It is also  independent of $\beta$. Therefore, given the list, $z$ and $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ the adversary learns nothing about $\beta$, unless it guesses the value,  with  success probability $\frac{1}{2}$. The same also holds for $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. 
 \hfill\(\Box\)\end{proof}


\begin{lemma} If SAP is secure and the encryption scheme is semantically secure, then RC-S-P preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

\begin{proof}[sketch]
Due to the privacy property of SAP, that stems from the  hiding property of the commitment scheme, given the commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$, (that are stored in the blockchain as result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}, pad_{\scriptscriptstyle q},$ and $\bar{k}$), except with negligible probability, $\mu_{\scriptscriptstyle 1}(\lambda)$.   Also, given  price list $pl$, encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, the adversary learns nothing about the actual price agreed between the server and client,  $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}. Next we analyse the privacy of padded encrypted query vector $\bm{c}^{\scriptscriptstyle *}$. For  the sake of simplicity, we focus on   $\bm{q}^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$, that is a padded encrypted query vector for $j$-th verification. Let $\bm{q}_{\scriptscriptstyle j,0}$ and $\bm{q}_{\scriptscriptstyle j,1}$  be query vectors, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$ that    are picked by the adversary according to  Definition  \ref{deff::RC-S-P-Privacy} which lets  the environment pick $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$. Also, let $\{\bm{q}_{\scriptscriptstyle j,0},...,\bm{q}_{\scriptscriptstyle j,m}\}$ be a  list of all queries of different sizes. In the experiment, if $\bm{q}_{\scriptscriptstyle j,\beta}$  is only   encrypted (but not padded), then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$,  under the assumption  that $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)=|\bm{q}_{\scriptscriptstyle j,\beta}|$. The  assumption is  relaxed with the use of a pad; as each encrypted query is padded  to the queries' maximum size, i.e. $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)$, the adversary cannot tell with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$ if the  padded encrypted proof corresponds to  $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$, as the padded encrypted query \emph{always has the same size} and the pad values are picked from the same range as the encryption's ciphertext are defined. The same argument holds for $\bm{w}^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$. 

Next we analyse the privacy of padded encrypted proof vector $\bm{\pi}^{\scriptscriptstyle *}$. The argument is similar to the one presented above; however, for  the sake of completeness we provide it.  We focus on an element of the vector,  $\pi_{\scriptscriptstyle j}^{\scriptscriptstyle *}\in\bm{\pi}^{\scriptscriptstyle *}$, that is a padded encrypted proof for $j$-th verification. Let $\pi_{\scriptscriptstyle j,0}$ and $\pi_{\scriptscriptstyle j,1}$  be proofs, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$, where the inputs   are picked by the adversary, w.r.t. Definition  \ref{deff::RC-S-P-Privacy} in which  the environment picks $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$.  Let $\{\pi_{\scriptscriptstyle j,0},...,\pi_{\scriptscriptstyle j,m}\}$ be proof list including all proofs of different sizes. In the experiment, if $\pi_{\scriptscriptstyle j,\beta}$  is only   encrypted, then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$,  if $Max(|\pi_{\scriptscriptstyle j,0}|,...,|\pi_{\scriptscriptstyle j,m}|)=|\pi_{\scriptscriptstyle j,\beta}|$. However, the  assumption is  relaxed with the use of a pad. In particular, since each encrypted proof is padded  to the proofs' maximum size, the adversary cannot tell with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$ if the  padded encrypted proof corresponds to  $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$. 


Also, since the value of $a$ is independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, it leaks nothing about the service input $u_{\scriptscriptstyle\beta}$ and $\beta$. Moreover, since each padded encrypted query and proof leak no information and always contains a fixed number of elements, an adversary cannot tell the status of a proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$, given  $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$.
  \hfill\(\Box\)\end{proof}


