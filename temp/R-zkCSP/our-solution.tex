% !TEX root =R-zkCSP.tex

\subsection{Overview of Our Solution}

\noindent\underline{\textit{Addressing Issue 1}}. To address issue 1, we use a combination of the following techniques (over simplified). First, we require a client to deposit its coins to the contract right before it starts using the service, e.g. in the case of PoR before it uploaded its data to the server. Second, we upgrade a verifiable service to a '' verifiable service with identifiable abort'' (VSIA). This guarantees that not only the service  takes into the consideration that the client can be malicious as well, but also the public can identify the misbehaving party (i.e. client or server).  Third, we allow a trusted third party, arbiter, to resolve dispute between the parties. Now we explain how the solution (using the above techniques) works. The client before using the service deposit  a fixed amount of coins in the contract, where the deposit mount includes the service payment $e$ and $p$ coins to cover  dispute resolutions' cost. Also, the sever deposits $p$ coins for  covering the cost of future disputes. Then, the client and server  run   VSIA protocol such that (representation of) all messages exchanged between the parties, i.e. the service challenges and  proofs, are put in the contract.  The parties perform the verifications locally, off-chain.   The client  has a chance to rise a dispute if it detects any misbehaviour. In this case, it invokes the arbiter who  re-runs the verification and checks the client's claim. The arbiter sends the output of the verification to the contract. If the client's claim is  valid, then it can withdraw its coins and the arbiter is paid from the server's deposit.  However, if the client's claim is invalid, then the server gets back it deposit and along with the coins the client deposited for the service payment. In this case, the arbiter is paid from the client's deposit. If both the client and server behave honestly, then  after a certain time, the server gets its deposit back and is paid for the service, and  the client gets $p$ coins back.  The reason why the above approach solves problem 1, is that the client pay deposit before it starts using the service, and if acts nothing at the payment time, it is assumed that it has accepted the proof. Also, VSIA allows the arbiter to detect the client  if it lies about the verification result; but the server still receives the payment.  As evident, if the client and server act honestly/rationally, then there will be no need to involve the arbiter.  Later, we will show, in general cases, we can further reduce the involvement of the arbiter (even if a dispute is raised) and in a certain case, i.e. PoR setting, its role can be efficiently played by a smart contract. 

\noindent\underline{\textit{Addressing Issue 2}}. We use the following ideas to address issue 2. Instead of trying to hide the information from the public \emph{forever}, we let it become \emph{stale}, to lose its sensitivity, and then it will become publicly accessible. In particular, the client and server agree on the period in which the data should remain hidden, ``private time bubble''. This requires, the parties to postpone calling the above pay function, or raising any dispute to the time when the private time bubble ends (or the bubble bursts). However, the client can still find out if the proof is valid as soon as the server provides it, because the verification is locally performed.  To further hide the amount of deposit, we let each party to mask their coins. But this raises another challenge: \textit{how can the (mutually untrusted) parties claim back their masking coins after the bubble bursts, while hiding the coins amount from the public in the private time bubble?} Note that it would not work if they explicitly encode in the contract the amount of masking, as it would reveal the masking coins amount to the public in the beginning of the protocol. To address the challenge, we let the client and server, mutually untrusted, to agree on a private statement specifying the deposit details (e.g. parties' coins amount for the service, penalty, or masking). Later, when they call pay function to claim their coins, they also provide the statement to the contract which first  checks the validity of the statement and if it is accepted, it distributes coins according to the statement (and status of the contract). We will show how they can  efficiently agree on a statement, without using any zero knowledge proofs.
 
 
 
 
