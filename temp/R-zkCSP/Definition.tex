% !TEX root =R-zkCSP.tex

\section{Definition}\label{Definition}

At a high-level, a verifiable service scheme is a two-party protocol in which a client chooses a function, $F$, and provides (an encoding of) $F$, and its input, $u$, to a server.  The server is expected to evaluate $F$ on $u$ and respond with the output. Then, the client  verifies that the output is indeed the output of the function computed on the provided input. 


\begin{definition}[Verifiable Service Scheme]\label{service-def}
A verifiable service scheme VS $=(\mathtt{VS.KeyGen}, \mathtt{VS.setup},\mathtt{VS.genChall},$ $\mathtt{VS.prove},\mathtt{VS.verify})$ consists of five algorithms defined as follows.

\begin{itemize}

\item[$\bullet$] $\mathtt{VS.KeyGen}(1^{\lambda},F)\rightarrow k:(sk,pk)$.  A probabilistic algorithm run by the client. It takes as input security parameter and a function, $F$, that will be run on the client's input by the server. It outputs a secret/public verification key: $k$. 

\item[$\bullet$] $\mathtt{VS.setup}(1^{\lambda}, u,k)\rightarrow \sigma$. A probabilistic algorithm run by the client. It takes as input security parameter,  the service input: $u$, and the key pair: $k$. It outputs  a set of metadata: $\sigma$.


\item[$\bullet$] $\mathtt{VS.genChall}(1^{\lambda}, aux,k)\rightarrow c$. A probabilistic algorithm run by the client. It takes as input security parameter and auxiliary information: $aux$, and the key pair: $k$. It outputs a set of (random) challenges $c$ or empty set if the proving/verification  algorithms do not require any challenges. %The challenges set is published to a bulletin board.


\item[$\bullet$] $\mathtt{VS.prove}(u,\sigma,c,pk)\rightarrow \pi$. A probabilistic algorithm run by the server. It  takes service input: $u$, metadata: $u\sigma$,  random challenges $c$ and public key: $pk$. It outputs a proof pair, $\pi=(F(u),\delta)$ containing the function evaluation at  input $u$, i.e. $F(u)$ and a proof $\delta$ asserting the evaluation is performed correctly. %The proof pair: $\pi$ is published to a bulletin board. 

\item[$\bullet$] $\mathtt{VS.verify}(\pi,c,k)\rightarrow \{0,1\}$. A deterministic algorithm run by the client. It takes the proof: $\pi$,  random challenges $c$, and key pair $k$. If the proof is accepted, it outputs $1$; otherwise, it outputs $0$. 
\end{itemize}
\end{definition}


Informally, a verifiable service scheme has two main properties: correctness and soundness. The correctness requires that  the verification algorithm always accepts a proof generated by an honest prover.  It is formally stated below.

\begin{definition}[Correctness] A verifiable service scheme VS is correct correct for a class of functions $\mathcal{F}$, if for any $F \in \mathcal{F}$, the key generation algorithm produces keys $\mathtt{VS.KeyGen}(1^{\lambda},F)\rightarrow k:(sk,pk)$ such that  $\forall u \in \mathtt{Domain}(F)$, if $\mathtt{VS.setup}(1^{\lambda}, u,k)\rightarrow \sigma$, and $\mathtt{VS.genChall}(1^{\lambda}, aux,k)\rightarrow c$ and $\mathtt{VS.prove}(u,\sigma,c,pk)\rightarrow \pi$, then $\mathtt{VS.verify}(\pi,c,k)\rightarrow 1$.
\end{definition}

Intuitively, a verifiable service is soundness  if a malicious server cannot convince the verification algorithm to accept an incorrect output. In other words, if a prover persuades the verifier with a high probability, then the service has been provided by the prover. It is  formally stated as follows.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Soundness] A verifiable service VS is sound for a class of functions $\mathcal{F}$, if for any $F \in \mathcal{F}$, any input $u^*$, all probabilistic polynomial time adversaries $\mathcal{A}=(\mathcal{A}_{\scriptscriptstyle 1},\mathcal{A}_{\scriptscriptstyle 2})$, there exists a negligible function $\mu(.)$, such that: 
%\footnotesize{
\small{
$$ Pr\left[
  \begin{array}{l}
F(u^*)\neq y \wedge b=1
\end{array} \middle |
    \begin{array}{l}
    \mathtt{VS.KeyGen}(1^{\lambda},F)\rightarrow k:(sk,pk)\\
    \mathcal{A}_{\scriptscriptstyle 1}(1^{\scriptscriptstyle\lambda},pk, F)\rightarrow (u^*,\text{state})\\
    \mathtt{VS.setup}(1^{\lambda}, u^*,k)\rightarrow \sigma\\
    \mathtt{VS.genChall}(1^{\lambda}, aux,k)\rightarrow c\\
     \mathcal{A}_{\scriptscriptstyle 2}(\text{state},c,\sigma)\rightarrow \pi:(y,\delta)\\
     \mathtt{VS.verify}(\pi,c,k)\rightarrow b\\
\end{array}    \right]\leq \mu(\lambda)$$
}
\end{definition}


The above generic definition captures the core requirements of a wide range of verifiable services such as verifiable outsourced storage, i.e. PoR/PDP schemes, verifiable computation, verifiable searchable encryption, verifiable information retrieval, and verifiable delegated (private) set intersection, to name a few. Any additional security properties mandated by certain services, e.g.  privacy or extractability, can be easily plugged into the above definition.  However,  the above definition and the aforementioned verifiable schemes,  assume that the server is potentially malicious while the client is trusted. 



\



In the following, we provide a formal definition of  a service scheme (e.g. PoR)  run between the client and server, mutually distrusted. 

\begin{definition}\label{service-def}
A service scheme consists of six algorithms defined as follows.

\begin{itemize}
\item[$\bullet$] $\mathtt{Service.setup}(1^{\lambda}, u)\rightarrow (k,\sigma,\theta)$. A probabilistic algorithm run by the client. It takes as input security parameter and the service input: $u$. It outputs a secret/public verification key and a set of metadata: $\sigma$, and proof: $\theta$ asserting  $\sigma$ is a well-constructed metadata on $u$.

\item[$\bullet$] $\mathtt{Service.serve}(u,\sigma,\mu)\rightarrow \{0,1\}$. A deterministic algorithm run by the server. It takes the service input $u$, metadata $\sigma$ and proof $\mu$. It checks if $\sigma$ has been well-constructed and the client knows the verification key. It outputs 1, if both proofs are accepted and wants to serve the client; otherwise, it outputs 0. 

\item[$\bullet$] $\mathtt{Service.genChall}(1^{\lambda}, aux)\rightarrow c$. A probabilistic algorithm run by the client. It takes as input security parameter and auxiliary information (e.g. size of $u$). It outputs a set of random challenges $c$ (or empty set if  proving/verification algorithms do not require any challenges). %The challenges set is published to a bulletin board.


\item[$\bullet$] $\mathtt{Service.prove}(u,\sigma,c)\rightarrow \pi$. A probabilistic algorithm run by the server. It  takes service input, $u$, metadata $u$, and  random challenges $c$. It outputs a proof, $\pi$. %The proof pair: $\pi$ is published to a bulletin board. 


%\item[$\bullet$] Prove$(u,\sigma,c)\rightarrow \pi$. A probabilistic algorithm run by the server. It that takes service input, $u$, metadata $u$, and  random challenges $c$. It outputs a proof $\pi=(\pi',sig(\pi'))$, that includes proof of service and its signature. 

%\item[$\bullet$] Verify$(\pi,k,c, d)\rightarrow \{0,1\}$. A deterministic algorithm run by the client or a third party auditor. It takes the proof: $\pi=(\pi',com(\pi'))$, verification key $k$,  random challenges $c$ and $d=(\mu',u',\sigma', o)$, such that $\mu'\subset\mu, u'\subset u$, $\sigma'\subset \sigma$ and $o$ is the commitment opening. If the client runs the algorithm then $d$ is empty and only checks the proof $\pi$. If a third party runs it then, given $u'$ and $\sigma'$, it also  verifies $\mu'$  (similar to  Serve algorithm) and checks if the commitment matches the opening. The algorithm outputs $1$ if all proofs are accepted; otherwise, it outputs $0$. 

\item[$\bullet$] $\mathtt{Service.verify}(\pi,k,c)\rightarrow \{0,1\}$. A deterministic algorithm run by the client. It takes the proof: $\pi$, verification key $k$, and random challenges $c$. If the proof is accepted, it outputs $1$; otherwise, it outputs $0$. 

\item[$\bullet$]  $\mathtt{Service.resolve}(\pi,k,c,d)\rightarrow \{0,1\}$. A deterministic algorithm run by a third-party arbiter. It takes the proof: $\pi$, verification key $k$,  random challenges $c$ and $d=(\theta',u',\sigma')$, such that $\theta'\subset\theta, u'\subset u$, and $\sigma'\subset \sigma$.  If  $\pi$ and  $\sigma'$ are accepted, then it outputs $1$; otherwise, it outputs $0$. 

\end{itemize}
\end{definition}

In the above definition,  $\mathtt{Service.verify}()$ algorithm  allows a verifier to detect only a misbehaving server; nevertheless, it is not suitable to  detect a misbehaving client who may try to falsely accuse the server.  Thus, $\mathtt{Service.resolve()}$ algorithm has also been incorporated in the definition, to allow an arbiter to detect either party's misbehaviour and resolve any dispute between them.  Informally, a service scheme has two main properties: correctness and soundness. The correctness requires that for any key, the verification algorithm accepts a proof generated by an honest prover. The soundness requires that if a prover convinces the verifier (i.e. client or arbiter), with a high probability, then the service has been provided by the prover. {\color {blue} it seems undeniability and accountability/liability, i.e. a malicious party can be identified and held accountable, are needed too. Thin if it's needed here on in the main payment protocol.}
The exact formalisation of soundness however totally depends on the kind of service provided. 



%Thus, since the two party are mutually distrusted, the above definition has also incorporated Service.resolve() algorithm that  allows an arbiter to resolve any dispute between client and server. 


