% !TEX root =R-zkCSP.tex

\subsection{Statement Agreement Protocol (SAP)}\label{SAP}



In this section, we explain how a client and server, mutually distrusted, can efficiently agree on a private statement, e.g.  a string or tuple, that will be used to reclaim clients' masking coins when the private bubble bursts. Informally, there are two security properties that must be met. Firstly, neither party can prove to the verifier that they have agreed on an invalid statement (i.e. statement that both parties have not agreed). Secondly,  either no party can successfully prove they have an agreement, or either party can prove it to the verifier.
 To that end, we use a combination of smart contract and commitment scheme. The idea is as follows. The server picks a random value and commitment to the agreed statement. It sends the commitment to the contract and the commitment opening (i.e. statement and the random value) to the client. The client checks if the opening matches the commitment and if so, it commits to the statement using the same random value and sends its commitment to the contract. Later on, for a party to prove to the contract  that it has an agreed on the statement with the other party, it only sends the opening of the commitment.  The contract checks if the opening matches both commitments and accepts if it matches. 




 \begin{enumerate}
 \item\textbf{Setup}.  Both parties agree on the SAP smart contract and deploy it.

  
  \item\textbf{Agreement}.
  \begin{enumerate}
   \item The server picks a random value: $r$, and commits to the statement: $\mathtt{H}(x||r)=y_{\scriptscriptstyle S}$.
   \item The server sends $r$  to the client and sends $y_{\scriptscriptstyle S}$ to the contract. 
   \item The client checks: $\mathtt{H}(x||r)\stackrel{?}=y_{\scriptscriptstyle S}$. If the equation  holds, it computes $\mathtt{H}(x||r)=y_{\scriptscriptstyle C}$.
   \item The client   stores $y_{\scriptscriptstyle C}$ in the contract. 
    \end{enumerate}
   \item\textbf{Prove}. For either $C$ or $S$ to prove, it has agreement on $s$ with its counter-party, it sends $\mu=(x, r)$  to the contract. 
 \item\textbf{Verify}. Given $\mu$, the contract does the following. 
   \begin{enumerate}

   \item checks if $\mathtt{H}(x||r)=y_{\scriptscriptstyle C}=y_{\scriptscriptstyle S}$.
   \item outputs 1, if the above equation holds; otherwise, it outputs 0.
    \end{enumerate}
 \end{enumerate}



%
% \begin{enumerate}
% \item\textbf{Setup}.  Both parties agree on a  smart contract and deploy it, such that the parties public keys, $pk_{\scriptscriptstyle C}$ and $pk_{\scriptscriptstyle S}$, are encoded in the contract.
%
%  
%  \item\textbf{Agreement}.
%  \begin{enumerate}
%   \item The server picks a random value: $r$, and commits to the statement: $H(s||r)=y_{\scriptscriptstyle S}$.
%   \item The server sends $r$  to the client and sends $y_{\scriptscriptstyle S}$ to the contract. 
%   \item The client checks: $H(s||r)\stackrel{?}=y_{\scriptscriptstyle S}$. If the equation  holds, it computes $H(s||r)=y_{\scriptscriptstyle C}$.
%   \item The client   stores $y_{\scriptscriptstyle C}$ in the contract. 
%    \end{enumerate}
%   \item\textbf{Prove}. For either $C$ or $S$ to prove, it has agreement on $s$ with its counter-party, it sends $\mu=(s, r)$, in a signed transaction, to the contract. 
% \item\textbf{Verify}. Given $\mu$, the contract does the following. 
%   \begin{enumerate}
%   \item verifies the public keys related to  signatures of $y_{\scriptscriptstyle C}$ and $y_{\scriptscriptstyle S}$ match $pk_{\scriptscriptstyle C}$ and $pk_{ \scriptscriptstyle S}$ respectively.
%   \item checks if $H(s||r)=y_{\scriptscriptstyle C}=y_{\scriptscriptstyle S}$.
%   \item outputs 1, if the above equation holds; otherwise, it outputs 0.
%    \end{enumerate}
% \end{enumerate}
 
 %Note that the above protocol is one-off, which means after first party
 
 
 
 \noindent\textbf{Strawman solutions}: One may simply let each party  sign the statement and send it to the other party, so later on each party can send both signatures to the contract who verifies them. However, this would not work,  as the party who first receives the other parties signature  may refuse  to send its own signature, that prevents the other party to prove it has an agreed on the statement with its counter-party. Therefore, one may want to use a protocol for fair exchange of digital signature (or fair contract signing), such as \cite{BonehN00,DBLP:conf/fc/GarayJ02}. In this case, after both parties have the other party's signature, they can sign the statement themselves and send the two signatures to the contract; who first checks the validity of the signatures and then distribute the coins as constructed in the statement. However, this approach leads to two main efficiency and practical issues: (a) It imposes very high computation costs, as  protocols for fair exchange of signature involve generic zero knowledge proofs and a high number of modular exponentiations. And (b) It is impractical, because protocols for fair exchange of signature protocol support only certain signature schemes (e.g. RSA, Rabin, Schnorr) not supported by the most predominant  smart contract framework,  Ethereum, as it only supports  Elliptic Curve Digital Signature Algorithm (EDCSA).

