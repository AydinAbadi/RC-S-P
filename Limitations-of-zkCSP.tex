% !TEX root =R-zkCSP.tex

\subsection{Limitations of zkCSP}

As stated in Section \ref{Related-Work},  the main purpose of zero-knowledge contingent service payment (zkCSP) protocol \cite{CampanelliGGN17}  is to minimise the role of smart contract as much as possible, so  (a) the verification's cost would be much lower, if a Turing-complete smart contract framework (e.g. Ethereum) is used, or (b) it can be implemented on  a non-Turing-complete contract framework (e.g. Bitcoin).   


Nevertheless, as we will show,  zkCSP suffers from  serious issues; namely, it allows a malicious client to waste the server resources and  it leaks non-trivial information in real-time to the public. Also, when the payment is recurring (i.e. the server interacts with a client multiple times and/or the server interact with multiple clients), a malicious client can get a free ride from the server, in the sense that it can collect enough fresh information convincing him that the server is behaving honestly, without paying the server. In the following, we elaborate on the  above issues and explain where the issues stem from.

\begin{itemize}


\item[$\bullet$]\textit{Issue 1: Discrepancies between the Security Guarantees of Verifiable  Service and Fair Exchange Schemes}. zkCSP combines a certain verifiable service scheme (i.e. PoR) secure against only a malicious server (where a client is assumed to be fully trusted) with a fair exchange protocol that takes into the consideration that either server or client might be malicious.  This mismatch allows the client to avoid paying the server in different ways. The client can simply avoid participating in the payment phase despite it has been using the server, e.g. using the server storage. Moreover, the client  may engage in the payment protocol but  falsely accuses the server for behaving maliciously, or  makes the server generate invalid proofs.  At a first glance it seems the client can only  waste the server's resource without gaining anything. However, as we will show shortly, in the recurring payment (when the server deals with multiple clients) the client  can collect  convincing background information about an honest server. The information   allows the client to conclude that it has been  served honestly; even though, it does not pay the server and does not check the proof. Thus, it can  get a free ride from the server. 










%The mismatch leads to serious consequences when the client misbehaves. For instance, in zkCSP the transfer of the deposit requires the client's engagement and approval, after it receives a proof from the server. This allows  a malicious client who has been using the service,  to avoid sending its approval to the contract or falsely claims the proofs are invalid at the payment time. So, an honest server's resources (e.g. the storage space allocated to the client's data) are wasted. As we will show shortly, in recurring payments (when the server deals with multiple clients) a malicious client can collect  convincing information about an honest server  that allows it to conclude that it has been  served honestly; even though, it does not pay the server and does not check the proof. Thus, it can  get a free ride from the server. 



%\item\textit{Coins Transfer is Public and Immediate}. 

\

\item[$\bullet$]\textit{Issue 2: Real-time Leakage of Verification Outputs and Deposit Amount}. zkCSP leaks in real-time non-trivial fresh information,  about  the server and clients, to the public. The leakage includes:

\
\begin{itemize}
 \item\textit{proofs' status}: it is visible in the real-time to everyone that a proof has been accepted or reject, that reflects whether  the server has successfully delivered the agreed-upon service or failed to do so. This can have serious immediate consequences for both the server and clients, e.g. lost revenue, negative press, stock value drop, or opening doors for attackers to exploit such incident. As an example, observing  proof's verification outputs (when a server deals with multiple clients) allows a malicious client to immediately construct a comprehensive background knowledge on the server's current behaviour and status, e.g. the server has been  acting honestly.  Such auxiliary information can assist the  client to more wisely exploit the above deposit issue (that can avoid sending the deposit); for instance, when the sever always acts honestly towards its clients, the client refuses to send the deposit and still  has  high confidence that the server has delivered the service. As another example, in the case of PoR, a malicious observer can  simply find out that the service is suffering hardware/software failure and exploit such vulnerability to  mount   social engineering attacks on clients or penetrate to the system. 

 \
 
\item \textit{deposit amount}: the amount of deposit placed on the contract,  swiftly leaks non-trivial  information about the client to the public. For instance, in the case of PoR, an observer can learn the size of data outsourced to the server, service type or level of data sensitivity. The situation gets even worse if the client updates its data (e.g. delete or append) or asks the server for additional service (e.g. S3 Glacier or S3 Glacier Deep Archive\footnote{https://aws.amazon.com/s3/pricing/}), as an observer can learn such changes immediately by just observing the amount of deposit put by the client for each payment.  
\end{itemize}
%For instance, the deposit transfer is public and takes place as soon as the client declares to the contract that it accepted the proof. An adversary can take advantage of this data leakage in certain cases. For instance,  observing the outputs of zkCSP invoked by the server and other clients,  allows a malicious client to eventually construct a comprehensive background knowledge on the server's current behaviour, e.g. the server has been  acting honestly. Note, the server (or its address) is fixed and known to the public, so the background knowledge can be linked to it. The amount of deposit placed on the contract,  immediately leaks non-trivial  information to the public that includes, data size, service type or level of data sensitivity. Since usually proof of services (and a bill) is provided by a server on a regular basis (e.g. every month) an adversary can learn in the \emph{real time} what kinds of service are being used by the client. Furthermore, the immediate transfer of coins, leaks to the public that whether the service delivered the agreed service or failed doing so. This also can have serious consequences, for instance in the case of PoR, a malicious observer can  simply find out that the service is suffering hardware/software failure and exploit such vulnerability to  mount certain  attacks, e.g. social engineering attacks on clients or penetrating to the system. 


\end{itemize}


\noindent\textbf{{Strawman Solutions for the Two Problems}}. To address  Problem 1, one may slightly adjust the zkCSP protocol such that it would require  the client to deposit coins (long) before the server provides the ZK to it, with the hope that the client cannot avoid depositing after the server  provides ZK proofs. Nevertheless, this would not work, as the client after accepting the ZK proof, needs to send a confirmation message/transaction to the contract. But a malicious client can avoid doing so or  make the server compute invalid proofs, that ultimately allows the client to get its deposit back.  Alternatively, one may let a smart contract  perform the verification on the client's behalf, such that the client deposits its coins in the contract when it starts using the service. Then, the server sends its proof to the contract who performs the verification and pays the server if the proof is accepted. Even though this approach would solve (only) problem 1 above, it imposes  high costs and defeats the purpose of zkCSP design. The reason is that the contract has to \emph{always} be involved to run the verification algorithm that  has to be a publicly verifiable one, which  usually imposes high computation cost. Moreover, one might want to let the server pick a fresh address for each verifier/verification, to  preserver its pseudonymity with the hope that an observer cannot link clients to a server (so both problems can be addressed). However, for this to work, we have to assume multiple service providers  use the same protocol on the blockchain and all of them are pseudonymous. But, this is a strong assumption and may  not be always feasible. 

















