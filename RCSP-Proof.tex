% !TEX root =R-zkCSP.tex

 \begin{lemma}\label{lem::RC-S-P-SecurityAgainstMaliciousServer}
 If SAP and signature scheme are secure and  VSID scheme supports correctness, soundness, and detectable abort, then RC-S-P is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}. 
 \end{lemma}
 

 \begin{proof}[sketch]
 We first consider event  
 
  $$\Bigg(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j},{pp})= h_{\scriptscriptstyle j}\ \wedge \Big((coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o)  \vee (coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\ \wedge\  y'_{\scriptscriptstyle \mathcal {S},j}=1)\Big)\Bigg)$$
   that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$, or it makes the arbiter withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$, if it unnecessarily invokes the arbiter.  As the service proof is valid, an honest client accepts it and does not raise any dispute. However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved, by making the arbiter output  $y_{\scriptscriptstyle\mathcal {C},j}=1$ through the dispute resolution phase, or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters (e.g. $l$ or $o$) or send a message on the client's behalf to invoke the arbiter unnecessarily. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key.  On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of VSID, algorithm $\mathtt{VSID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. Therefore, due to the security of SAP and correctness of VSID,   $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$.   Also,  due to the security of SAP, the server cannot change the payment parameters by persuading the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision.   Moreover, since the proof is valid the client never raises a dispute, also due to the digital signature's  unforgeability, the server  cannot send a message on behalf of the client (to unnecessarily invoke the arbiter), and make  the arbiter output $y'_{\scriptscriptstyle\mathcal {C},j}=1$ for $j$-th verification, except with a negligible probability $\mu(\lambda)$. So with a high probability $y'_{\scriptscriptstyle\mathcal {C},j}=0$. Recall, in the protocol, the total coins the client should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l (y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})$. Since we focus on  $j$-th verification, the amount of  coins that should be credited to the client for that verification is
 
 

  
  \begin{equation}\label{equ::what-client-recives-in-j}
   coin_{\scriptscriptstyle\mathcal{C},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal {S},j})-l(y_{\scriptscriptstyle\mathcal {C},j}+y'_{\scriptscriptstyle\mathcal {C},j})
     \end{equation}


As shown above $y_{\scriptscriptstyle\mathcal{C},j}=y'_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$.  Therefore, according to Equation \ref{equ::what-client-recives-in-j}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for $j$-th verification, with a high probability.  On the other hand, as stated above, if the adversary invokes the arbiter, the arbiter with a high probability outputs $I_{\scriptscriptstyle j}=\bot$ which results in $y'_{\scriptscriptstyle\mathcal{S},j}=1$. Recall, in the RC-S-P protocol, the total coins the arbiter should receive for $z$ verifications is $l(y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal C})$, so for the $j$-th the credited coins should be: 
     
     
     \begin{equation}\label{equ::arbiter}
    coin_{\scriptscriptstyle\mathcal{A}r,j}= l(y_{\scriptscriptstyle\mathcal {S},j}+y_{\scriptscriptstyle\mathcal {C},j}+y'_{\scriptscriptstyle\mathcal {S},j}+y'_{\scriptscriptstyle\mathcal {C},j})
     \end{equation}

As already shown, in the case where arbiter is unnecessarily invoked by the server, it holds that $y'_{\scriptscriptstyle\mathcal{S},j}=1$; So,  according to Equation \ref{equ::arbiter}, $l$ coins is credited to the arbiter for $j$-th verification.  For the server to make the arbiter to withdraw other than that amounts (for $j$-th verification), at the coin transfer phase, it has to send to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq\ddot{x}_{\scriptscriptstyle cp}$, so it can change the payments' parameters, e.g. $l$ or $o$. However, as argued above, it cannot succeed with probability significantly greater than $\mu(\lambda)$. We now move on to event 
     
     $$\Bigg(\Big(F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j}, {pp})\neq h_{\scriptscriptstyle j}\Big) \ \wedge \Big(d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal {S},j}=0 \ \vee coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z} \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\Big)\Bigg)$$
     
     It captures the case where the server provides an invalid service proof but either persuades the client to accept the proof, or  persuades the arbiter to accept the proof (e.g. when the client raises a dispute) or makes the client or arbiter withdraw an incorrect amount of coins, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ or $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively.   Nevertheless, due to the soundness of VSID, the probability that a corrupt server can convince an honest client to accept invalid proof (i.e. outputs $d_{\scriptscriptstyle j}=1$), is negligible, $\mu(\lambda)$. So, the client detects it with a high probability and raises a dispute.  On the other hand, the server may try to convince the arbiter, and make it output $y_{\scriptscriptstyle \mathcal {S},j}=0$, e.g. by sending a complaint. For $y_{\scriptscriptstyle \mathcal {S},j}=0$ to happen, it has to either provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the client (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification, which   requires finding the hash function's collision, and its probability of success is   $\mu(\lambda)$. Or it makes the arbiter  accept an invalid proof, but due to the detectable abort property of VSID, its probability of success is also  $\mu(\lambda)$. Also, as we discussed above, the probability that the adversary makes the arbiter to recognise the client as misbehaving, and output $y_{\scriptscriptstyle \mathcal {C},j}=1$ is  $\mu(\lambda)$ too. Therefore, the arbiter outputs $y_{\scriptscriptstyle \mathcal {S},j}=1$ and $y_{\scriptscriptstyle \mathcal {C},j}=0$  with a high probability, in both events when it is invoked by the client or  server. Also,  in this case, $y'_{\scriptscriptstyle \mathcal {C},j}=y'_{\scriptscriptstyle \mathcal {S},j}=0$ as the arbiter has already identified a misbehaving party. So, according to Equation \ref{equ::what-client-recives-in-j}, the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ coins for that verification, with a high probability.      Moreover, according to Equation \ref{equ::arbiter}, the arbiter is credited $l$ coins for that verification, with a high probability.  The adversary may  try to  make them withdraw an incorrect amount of coins, e.g. in the case where it does not succeed in convincing the client or arbiter. To this end,  at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the client. But, it would succeed only with a negligible probability, $\mu(\lambda)$, due to the security of SAP. Furthermore, in   general, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}

%We first consider event $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes an honest client withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. Since the proof is valid, an honest client accepts it and does not raise any dispute. 
%  However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved (by making the arbiter increment $y_{\scriptscriptstyle\mathcal {C}}$  by $1$ through dispute resolution phase), or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key.  On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of VSID, algorithm $\mathtt{VSID.identify}()$ outputs $I_{\scriptscriptstyle j}=\bot$. Therefore, due to the security of SAP and correctness of VSID,   $y_{\scriptscriptstyle\mathcal {C}}$ and $y_{\scriptscriptstyle\mathcal {S}}$ are not incremented by $1$  in $j$-th verification, i.e. $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$.  Moreover,  due to the security of SAP, the server cannot persuade the contract to accept any statement other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision. Recall, in the protocol, the total coins the client receives after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal C}$. Since we focus on each $j$-th verification, the amount of  coins credited to the client for that verification is
%  
%  \begin{equation}\label{equ::what-client-recives-in-j}
%   \frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z}-o(1-y_{\scriptscriptstyle\mathcal S}[j])-l\cdot y_{\scriptscriptstyle\mathcal C}[j]
%     \end{equation}
%     
%     In the above event, as we discussed,  with a high probability $y_{\scriptscriptstyle\mathcal{C}}[j]=y_{\scriptscriptstyle\mathcal{S}}[j]=0$ , so the client is credited $\frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ coins for that verification. 
%     
   




\begin{lemma}\label{lem::RC-S-P-Security-Against Malicious-Client}
 If SAP and signature scheme are secure and  VSID scheme supports correctness, inputs well-formedness, and detectable abort, then RC-S-P is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client}. 
\end{lemma}


\begin{proof}[sketch] First, we consider event 
  
   $$\Bigg(\Big(M(u^{\scriptscriptstyle *},k,{pp})= \sigma \  \wedge \ Q(\text{aux},k, {pp})= \bm{q}_{\scriptscriptstyle j}\Big)\ \wedge \
  \Big((coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)\ \vee \ (coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\ \wedge\  y'_{\scriptscriptstyle \mathcal {C},j}=1)\Big)\Bigg)$$
  
  
  It captures the case where the client provides  accepting metadata and query  but makes the server withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$, or makes the arbiter withdraw incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$, if it unnecessarily invokes the arbiter.  Since the metadata and query's proofs are valid, an honest server accepts them and does not raise any dispute, so we have $y_{\scriptscriptstyle\mathcal{C},j}=0$.  The client could  make the server  withdraw incorrect amounts of coins, if it manages to either convince the arbiter, in phase \ref{RCSP::Dispute-Resolution}, that the server has misbehaved, i.e. makes the arbiter output $y_{\scriptscriptstyle\mathcal{S},j}=1$, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$, in phase \ref{RCSP::CoinTransfer}, or send a message on the server's behalf to invoke the arbiter unnecessarily. However, it cannot falsely accuse the server of misbehaviour. As,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key and pads' detail, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with  probability $\mu(\lambda)$. This ensures   the arbiter is given the honest server's messages, with a high probability. So, with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. On the other hand, if the adversary provides a valid statement, i.e. $\ddot{x}_{\scriptscriptstyle qp}$, then due to the correctness of VSID, algorithm $\mathtt{VSID.identify}(.)$ outputs $I_{\scriptscriptstyle j}=\bot$. So, due to the security of SAP and correctness of VSID,  we would have $y_{\scriptscriptstyle\mathcal{C},j}=y_{\scriptscriptstyle\mathcal{S},j}=0$ with a high probability. Moreover, due to the security of SAP, the client cannot convince the contract to accept any accepting statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was initially agreed  between the client and server (i.e. $\ddot{x}'_{\scriptscriptstyle cp}\neq \ddot{x}_{\scriptscriptstyle cp}$), except with   probability $\mu(\lambda)$. Also, it holds that  $y'_{\scriptscriptstyle\mathcal{S},j}=0$ because an honest server never invokes the arbiter when the client's messages are well-structured and due to  the signature's unforgeability, the client cannot send a signed message on the server's behalf to unnecessarily invoke the arbiter.  According to  RC-S-P protocol, the total coins the server should receive after $z$ verifications is $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal S})$. Since we focus on  $j$-th verification, the amounts of  coin that should be credited to the server for $j$-th verification is
  
  \begin{equation}\label{equ::what-server-recives-in-j}
   coin_{\scriptscriptstyle\mathcal{S},j}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}}{z}+o(1-y_{\scriptscriptstyle\mathcal {S},j})-l(y_{\scriptscriptstyle\mathcal {S},j}+y'_{\scriptscriptstyle\mathcal {S},j})
     \end{equation}

 
 
 
  As shown above, the following holds $y_{\scriptscriptstyle\mathcal{S},j}=y'_{\scriptscriptstyle\mathcal{S},j}=0$, which   means, according to  Equation \ref{equ::what-server-recives-in-j}, the server is credited $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ coins for $j$-th verification, with a  high probability.  Furthermore, if the adversary invokes the arbiter, the arbiter with a high probability outputs $I_{\scriptscriptstyle j}=\bot$ which yields  $y'_{\scriptscriptstyle\mathcal{C},j}=1$. Also, as stated above,   $y'_{\scriptscriptstyle\mathcal{S},j}=0$.   Hence, according to Equation \ref{equ::arbiter}, the arbiter for $j$-th verification is credited $l$ coins, if it is unnecessarily invoked.  As previously stated,  due to the security of SAP, the client cannot make the arbiter withdraw incorrect amounts of coin by changing the payment parameters  and persuading the contract to accept any statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed initially between the client and server, except with  probability $\mu(\lambda)$. We now turn our attention to 
  
  $$\Big(M(u^{\scriptscriptstyle *},k,{pp})\neq \sigma\ \wedge \ a=1\Big)$$
     that captures the case where the server accepts an ill-formed metadata. However, due to inputs well-formedness of VSID, the probability that event happens is negligible, $\mu(\lambda)$. So, with a high probability $a=0$.  Note, in the  case where $a=0$, the server does not raise any dispute, instead it avoids serving the client. Next, we move on to 
     
     $$\Bigg(\Big(Q(\text{aux},k,{pp})\neq \bm{q}_{\scriptscriptstyle j}\Big)\ \wedge \ \Big(b_{\scriptscriptstyle j}=1\ \vee \ y_{\scriptscriptstyle\mathcal{C},j}=0 \ \vee \ coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o \ \vee \ coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l\Big)\Bigg)$$
     
       It considers the case where the client provides an invalid query, but  either convinces the server or arbiter to accept it, or  makes the server or arbiter  withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ or  $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively. Nevertheless, due to inputs well-formedness of VSID, the probability that the server outputs $b_{\scriptscriptstyle j}=1$, in this case is negligible, $\mu(\lambda)$. When the server rejects the query and raises a dispute, the client may try to convince the arbiter, and make it output $y_{\scriptscriptstyle \mathcal {C},j}=0$, e.g. by sending a complaint. However, for the adversary to win, either it has to provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the server (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification. But,  due to the security of SAP, its probability of success is negligible, $\mu(\lambda)$. Or it has to make the arbiter  accept an invalid query, i.e. makes the arbiter output $y_{\scriptscriptstyle\mathcal{C},j}=0$. Due to the detectable abort property of VSID, its probability of success is  $\mu(\lambda)$ too. Therefore, with a high probability we have $y_{\scriptscriptstyle\mathcal{C},j}=1$. Also, as discussed above, the client cannot make the arbiter recognise the  honest server as a misbehaving party with a probability significantly greater than $\mu(\lambda)$. That means with a high probability $y_{\scriptscriptstyle\mathcal{S},j}=0$. Furthermore, as we already discussed, since the arbiter 
has identified a misbehaving party, the following holds $y'_{\scriptscriptstyle\mathcal{C},j}=y'_{\scriptscriptstyle\mathcal{S},j}=0$.  Hence, according to Equation \ref{equ::what-server-recives-in-j} the server is credited  $\frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ coins for this verification; and also the arbiter is credited $l$ coins, according to Equation \ref{equ::arbiter}.  Note,  the adversary may still try to  make them withdraw an incorrect amount of coins (e.g. if the adversary does not succeed in convincing the server or arbiter). To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the server. However, due to the security of SAP, its  success probability is  $\mu(\lambda)$. Also, due to the security of SAP, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
 \hfill\(\Box\)\end{proof}
  
  
  Prior to proving  RC-S-P's privacy, we provide a lemma that will be used in the privacy's proof. Informally, the lemma states that encoded coins leaks no information about the actual amount of coins $(o,l)$, agreed between the client and server. 


\begin{lemma}\label{lemma::encoded-coins} Let $\beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}$, price list be $\{(o_{\scriptscriptstyle 0},l_{\scriptscriptstyle 0}),(o_{\scriptscriptstyle 1},l_{\scriptscriptstyle 1})\}$, and encoded coin amounts be $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}= z\cdot(Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta},l_{\scriptscriptstyle|\beta-1|}))$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot(Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle |\beta-1|}))$. Then, given the price list, $z$, $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$, and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, an adversary $\mathcal{A}$ cannot tell the value of $\beta$ with probability significantly greater than $\frac{1}{2}$ (where the probability is taken over the choice of $\beta$ and the randomness of $\mathcal{A}$).
\end{lemma}



\begin{proof}
As it is evident, the list and $z$ contains no information about $\beta$. Also, since  $z$ is a public value, it holds that   $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z} = Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle|\beta-1|})$. It is not hard to see $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ is a function of maximum value of $(o_{\scriptscriptstyle 0},o_{\scriptscriptstyle 1})$, and maximum value of $(l_{\scriptscriptstyle 0},l_{\scriptscriptstyle 1})$. It is also  independent of $\beta$. Therefore (given the list, $z$ and $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$) the adversary learns nothing about $\beta$, unless it guesses the value,  with  success probability $\frac{1}{2}$. The same also holds for $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. 
 \hfill\(\Box\)\end{proof}


\begin{lemma}\label{lem::RC-S-P-Privacy} If SAP is secure and the encryption scheme is semantically secure, then RC-S-P preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

\begin{proof}[sketch] We start with  case $1$, i.e. the privacy of service input. Due to the privacy property of SAP, that stems from the  hiding property of the commitment scheme, given the commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$, (that are stored in the blockchain as a result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}, pad_{\scriptscriptstyle q},$ and $\bar{k}$), except with a negligible probability, $\mu(\lambda)$.   Also, given  price list $pl$, encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, the adversary learns nothing about the actual price that was agreed between the server and client,  $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}. Next we analyse the privacy of padded encrypted query vector $\bm{c}^{\scriptscriptstyle *}$. For  the sake of simplicity, we focus on   $\bm{q}^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$, that is a padded encrypted query vector for $j$-th verification. Let $\bm{q}_{\scriptscriptstyle j,0}$ and $\bm{q}_{\scriptscriptstyle j,1}$  be query vectors, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$ that    are picked by the adversary according to  Definition  \ref{deff::RC-S-P-Privacy} which lets  the environment pick $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$. Also, let $\{\bm{q}_{\scriptscriptstyle j,0},...,\bm{q}_{\scriptscriptstyle j,m}\}$ be a  list of all queries of different sizes. In the experiment, if $\bm{q}_{\scriptscriptstyle j,\beta}$  is only   encrypted (but not padded), then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability significantly greater than $\frac{1}{2}+\mu(\lambda)$,  under the assumption  that the size of $\bm{q}_{\scriptscriptstyle j,\beta}$ is equal to the size of largest query size \footnote{The assumption that all queries have the same size is subsumed under the above assumption.}, i.e.  $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)=|\bm{q}_{\scriptscriptstyle j,\beta}|$. The  above assumption is  relaxed with the use of a pad; as each encrypted query is padded  to the queries' maximum size, i.e. $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)$, the adversary cannot tell with a probability greater than $\frac{1}{2}+\mu(\lambda)$ if the  padded encrypted proof corresponds to  $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$, as the padded encrypted query \emph{always has the same size} and the pad values are picked from the same range as the encryption's ciphertext are defined. The same argument holds for $\bm{w}^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$.  Next we analyse the privacy of padded encrypted proof vector $\bm{\pi}^{\scriptscriptstyle *}$. The argument is similar to the one presented above; however, for  the sake of completeness we provide it.  We focus on an element of the vector,  $\pi_{\scriptscriptstyle j}^{\scriptscriptstyle *}\in\bm{\pi}^{\scriptscriptstyle *}$, that is a padded encrypted proof for $j$-th verification. Let $\pi_{\scriptscriptstyle j,0}$ and $\pi_{\scriptscriptstyle j,1}$  be proofs, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$, where the inputs   are picked by the adversary, w.r.t. Definition  \ref{deff::RC-S-P-Privacy} in which  the environment picks $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$.  Let $\{\pi_{\scriptscriptstyle j,0},...,\pi_{\scriptscriptstyle j,m}\}$ be proof list including all proofs of different sizes. In the experiment, if $\pi_{\scriptscriptstyle j,\beta}$  is only   encrypted, then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with a probability significantly greater than $\frac{1}{2}+\mu(\lambda)$,  if $Max(|\pi_{\scriptscriptstyle j,0}|,...,|\pi_{\scriptscriptstyle j,m}|)=|\pi_{\scriptscriptstyle j,\beta}|$. However, the  assumption is  relaxed with the use of a pad. In particular, since each encrypted proof is padded  to the proofs' maximum size, the adversary cannot tell with a probability greater than $\frac{1}{2}+\mu(\lambda)$ if the  padded encrypted proof corresponds to  $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$. Also, since the value of $a$ is independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, it leaks nothing about the service input $u_{\scriptscriptstyle\beta}$, $\beta$, the query-proof pair and service proof. Thus (given  $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$) the probability that adversary can tell the value of $\beta$ is at most $\frac{1}{2}+\mu(\lambda)$. 



Now we move on to  case 2, i.e. the privacy of proof's status. Recall, the experiment  picks $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$ and then, if $\beta=0$ it  generates invalid query-proof pair which leads to an \emph{invalid} service proof; otherwise (if $\beta=0$), it  generates a valid query-proof that  yields a \emph{valid} service proof.  As stated above, each encoded query-proof pair $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$ has a fixed size and contains random elements of $U$, i.e. they are uniformly random elements in the symmetric key encryption scheme's output range. Also, it is assumed that for each $j$-th verification, an encoded query-proof is always provided to the contract. Therefore, each encoded pair leaks nothing, not even the query's status to the adversary. On the other hand, for each $j$-th verification, an encoded service proof $\pi_{\scriptscriptstyle j}^{\scriptscriptstyle *}\in\bm{\pi}^{\scriptscriptstyle *}$ is always provided to the contract, regardless of the query's status. As stated above, each $\pi_{\scriptscriptstyle j}^{\scriptscriptstyle *}$ has a fixed size and contains random element of $U$ too.   As we showed above, $g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},pl$, and $a$ leak no information about the service input, except with a negligible probability, $\mu(\lambda)$. They are also independent of the query-proof pair and service proof, so they leak no information about the pair and service proof too. Therefore, given   $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$, an adversary has to learn a proof's status from the aforementioned values or by guessing the value of $\beta$. In other words, its probability of learning a proof' status is at most $\frac{1}{2}+\mu(\lambda)$.
 \hfill\(\Box\)\end{proof}



%\
%
%\
%
%
%Moreover, since each padded encrypted query and proof leak no information and always contains a fixed number of elements, an adversary cannot tell the status of  proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu(\lambda)$, given  $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *},pl$, and $a$.
%  \hfill\(\Box\)\end{proof}


