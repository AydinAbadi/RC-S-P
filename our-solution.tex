% !TEX root =R-zkCSP.tex

\subsection{Overview of Our Solution}\label{sec::Overview-of-Our-Solution}

\noindent\underline{\textit{Addressing Issue 1}}. To address issue 1, we use a combination of the following techniques, that are oversimplified.  First, we upgrade a verifiable service scheme to a ``verifiable service with identifiable abort'' (VSID). This guarantees that not only the service  takes into  consideration that the client can  be malicious too, but also the public or an arbiter can identify the misbehaving party and resolve any potential disputes between the two. Second, we require a client to deposit its coins to the contract right before it starts using the service (e.g. in the case of PoR before it uploaded its data to the server) and it is forced to provide correct inputs; otherwise, its deposit is sent to the server.  Third, we allow the party who resolves disputes to get paid by a corrupt party. Now we explain how the solution works. The client before using the service, deposits  a fixed amount of coins in a smart contract, where the deposit amount covers the service payment: $o$ coins, and dispute resolutions' cost: $l$ coins. Also, the sever deposits  $l$ coins. Then, the client and server  engage in the   VSID protocol such that (the encryption of)  messages exchanged between the parties are put in the contract.  The parties perform the verifications locally, off-chain.  In the case where a party detects misbehavior, it  has a chance to raise a dispute that invokes the arbiter who  checks the party's claim, off-chain. The arbiter sends the output of the verification to the contract. If the party's claim is  valid, then it can withdraw its coins and the arbiter is paid by the misbehaving party, i.e. $l$ coins from the misbehaving party's deposit are transferred to the arbiter.  If the party's claim is invalid, then that party has to pay the arbiter and the other party can withdraw its deposit. In the case where both the client and server behave honestly, then the arbiter is never invoked;  in this case, the server (after a fixed time) gets its deposit back and is paid for the service, while  the client gets $l$ coins back.  Later, we will show in a certain case, i.e. PoR setting, the arbiter's role can be efficiently played by a smart contract, so its involvement is not needed in that case. 

\

\noindent\underline{\textit{Addressing Issue 2}}. We use the following ideas to address issue 2. Instead of trying to hide the information from the public \emph{forever}, we let it become \emph{stale}, to lose its sensitivity, and then it will become publicly accessible. In particular, the client and server agree on the period in which the data should remain hidden, ``private time bubble''. During that period, all messages sent to the contract are encrypted and the parties do not raise any dispute. They postpone raising any dispute to the time when the private time bubble ends (or the bubble bursts). Nevertheless, the client/server can still find out if a proof is valid as soon as it is provided by its counter-party, because it can locally verify the proof.  To further hide the amount of deposit, we let each party  mask its coins such that no one other than the two parties knows the amount of masking coins.  But this raises another challenge: \textit{how can the (mutually untrusted) parties claim back their masking coins after the bubble bursts, while hiding the coins amount from the public in the private time bubble?} One may want to  explicitly encode in the contract the amount of masking coins, but this would not suffice. As it would reveal the masking coins' amount to the public at the beginning of the protocol. To address the challenge, we let the client and server, at the beginning of the protocol, (efficiently)  agree on a private statement specifying the deposit details, e.g. parties' coins amount for the service, dispute resolution, or masking. Later, when they want to claim their coins, they also provide the statement to the contract which first  checks the validity of the statement and if it is accepted, it distributes coins according to the statement (and status of the contract). We will show how they can  efficiently agree on such statement, by using a statement agreement protocol (SAP).
 
 Our generic framework that offers the above features is called ``recurring contingent service payment'' (RC-S-P). 
 
 
