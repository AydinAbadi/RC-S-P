% !TEX root =R-zkCSP.tex



\subsection{Modified Merkle tree-based PoR}\label{protocol::PoR}

In this section, we present a modified version of the standard Merkle tree-based PoR, detonated by PoR. At a high level, the protocol works as follows. The client encodes its file using an error-correcting code, splits the encoded file into blocks, and constructs a Merkle tree on top of the blocks. It locally keeps the tree's root and sends the blocks to the server who rebuilds the tree on the blocks. At a verification time, the client sends a pseudorandom function's key to the server who derives a predetermined number of pseudorandom  indices of the blocks, that indicates which blocks have been challenged. The server for each challenged block generates a Merkle tree proof and sends all proofs to the client. The client, given the root and   key, verifies all  proofs. If all proofs are accepted, then the client outputs $1$ and concludes that its file is retrievable (with a high probability). However, if  it rejects a set of proofs, it outputs $0$ along with an index of the challenged block whose proof was rejected. In the following, we first present the protocol and then elaborate on the  modifications we have applied. 

%, i.e. a verifier outputs (the index of) a rejected proof.  Recall, that in the standard PoR protocol the client is honest and the server is potentially malicious. 

\begin{enumerate}

\item\textbf{Client-side Setup}. $\mathtt{PoR.setup}(1^{\lambda},u)$  
\begin{enumerate}
\item Uses an error correcting code, e.g. Reed-Solomon codes, to encode  the file: $u$. Let $u'$ be the encoded file. It splits $u'$  into  blocks as follows, $u^{\scriptscriptstyle *}=u^{\scriptscriptstyle '}_{\scriptscriptstyle 0}||0,...,u^{\scriptscriptstyle '}_{\scriptscriptstyle m}||m$
\item Generates  metadata: $\sigma$, by constructing Merkle tree on blocks of $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.genTree}(u^{\scriptscriptstyle *})$. Let $\sigma$ be the root of the resulting tree, and $\beta$ be a security parameter. It sets public  parameters as $pp:= (\sigma,\beta,m,\zeta)$, where $\zeta:=(\psi,\eta, \iota)$ is a $\mathtt{PRF}$'s description, as it was defined in Section \ref{preliminaries}
\item Sends $pp$ and $u^{\scriptscriptstyle *}$ to $\mathcal{S}$
\end{enumerate}

\

\item\textbf{Client-side Query Generation}. $\mathtt{PoR.genQuery}(1^{\scriptscriptstyle\lambda}, pp)$ 
\begin{enumerate}
\item\label{key-chalenge} Picks a random key $\hat{k}$ of a pseudorandom function $\mathtt{PRF}$, i.e. $\hat{k}\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}^{\scriptscriptstyle\psi}$. It ensures the function outputs distinct values, i.e. $\forall i,j\in [0,m]: (\mathtt{PRF}(\hat{k},i)\bmod m+1)\neq(\mathtt{PRF}(\hat{k},j)\bmod m+1)$, where $i\neq j$

\item It sends $\hat{k}$ to $\mathcal{S}$
 
 \end{enumerate}
 
 \
 
\item\label{PoR-server-prove}\textbf{Server-side Proof Generation}. $\mathtt{PoR.prove}(u^{\scriptscriptstyle *},\hat{k},pp)$ 
 \begin{enumerate}
\item Derives $\beta$ pseudorandom indices from $\hat{k}$ as follows. $\forall i,1\leq i\leq \beta: q_{\scriptscriptstyle i}=\mathtt{PRF}(\hat{k},i)\bmod m+1$. Let ${\bm{q}}=[q_{\scriptscriptstyle 1},..., q_{\scriptscriptstyle \beta}]$

\item For each random index $q_{\scriptscriptstyle i}$, generates a Merkle tree proof: $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$, by  running Merkle tree proof generator function on $u^{\scriptscriptstyle *}$, i.e. $\mathtt{MT.prove}(u^{*},q_{\scriptscriptstyle i})$. The final result  is $ {\bm{\pi}}=[(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})]_{\scriptscriptstyle q_{\scriptscriptstyle i}\in {\bm{q}}}$, where $i$-th element in $ {\bm{\pi}}$ corresponds to $i$-th pseudorandom value: $q_{\scriptscriptstyle i}$ and   each $\pi_{\scriptscriptstyle{q_{_{\scriptscriptstyle i}}}}$ is path in the tree that proves its corresponding block: $u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}$ is a leaf node of the  tree. 

\item Sends $ {\bm{\pi}}$ to $\mathcal{C}$
 \end{enumerate}
 
 \
 
\item\label{PoR-verify}\textbf{Client-side Proof Verification}. $\mathtt{PoR.verify}( {\bm{\pi}},\bm{q},pp)$ 
\begin{enumerate}

\item If $|\bm{\pi}|=|\bm{q}|=1$, then set $\beta=1$. This step is taken only in the case where single proof and query is provided to a third-party verifier (e.g. in the case of proof of misbehaviour). 
%\item Regenerates $\beta$ pseudorandom indices that are derived from $\hat{k}$ as follows. $\forall i,1\leq i\leq \beta: q_{\scriptscriptstyle i}=\mathtt{PRF}(\hat{k},i)\bmod m+1$. Let $ {\bm{q}}=[q_{\scriptscriptstyle 1},..., q_{\scriptscriptstyle \beta}]$
\item Checks if the server has sent proofs related to all challenged file blocks. To do that, for all $i$ (where $1\leq i\leq \beta$),  it first parses every  element of $\pi$ as follows, $\mathtt{parse}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}})=u^{\scriptscriptstyle '}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}}||q_{_{\scriptscriptstyle i}}$, and then checks if its index: $q_{_{\scriptscriptstyle i}}$ equals $i$-th element of $ {\bm{q}}$. If all checks pass, then it proceeds to the next step. Otherwise,  it outputs $ {\bm{d}}:[0,i]$, where $i$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 


\item Checks if every path in  $ {\bm{\pi}}$ is valid and corresponds to the root, by calling $\mathtt{MT.verify}(u^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\pi_{\scriptscriptstyle q_{_{\scriptscriptstyle i}}},\sigma)$. If all checks pass, it outputs $ {\bm{d}}=[1,\bot]$ (where $\bot$ denotes empty); otherwise, it outputs $ {\bm{d}}:[0,i]$, where $i$ refers to the index of the  element in $ {\bm{\pi}}$ that does not pass the check. 
\end{enumerate}
\end{enumerate}



\begin{theorem}
The PoR scheme, presented in Section \ref{protocol::PoR}, is $\epsilon$-sound, w.r.t. Definitions \ref{extractable}, if Merkle tree and pseudorandom function $\mathtt{PRF}$, are secure. 

\end{theorem}


 The above protocol differs from the standard Merkle tree-based PoR from two perspectives; First and far most,  in step \ref{PoR-verify} in addition to outputting a binary value, the client outputs only one index of a rejected proof. This will enable any third-party who is given that index (and vectors of proofs and challenges) to verify the client's claim by checking only that proof, i.e. proof of misbehaviour. Second,   in step \ref{key-chalenge} instead of sending $\beta$ challenges, we allow the client to send only a key of a pseudorandom function to the server who can derive a set of challenges form it. This will ultimately  lead to a decrease in costs too, i.e. the client's communication and a smart contract's storage costs.   
 
 \begin{proof}[sketch]
 As stated above, the proposed PoR differs from the standard Merkle tree-based PoR from a couple of perspectives. However, the changes do not affect the security and soundness of the proposed PoR and its security proof is similar to the existing Merkle tree-based PoR schemes, e.g. \cite{DBLP:conf/ccs/HaleviHPS11,MillerPermacoin,DBLP:journals/iacr/JuelsK07}. Alternatively, our protocol can be proven based on the security analysis of the PoR schemes that use  MACs or BLS signatures, e.g. \cite{DBLP:conf/asiacrypt/ShachamW08}. In this case, the extractor design (in the Merkle tree-based PoR)  would be simpler as it does not need to extract blocks from a linear combination of MAC's or signatures, as the  blocks are included in PoR proofs, i.e. they are part of the Merkle tree proofs. 
 
 Intuitively, in either case, the extractor interacts with any adversarial prover that passes non-negligible $\epsilon$ fraction of audits. It initialises an empty array. Then it  challenges a subset of file blocks and asks the prover to generate a proof.  If the received proof passes the verification, then it adds the related block (in the proof) to the array. It then rewinds the prover and challenges a fresh set of blocks, and repeats the process  many times. Since, the prover has a good chance of passing the audit, it is easy to show that the extractor can eventually extract a large fraction of the entire file. Due to the security, i.e. authenticity, of the Merkle tree, the retrieved values are the valid and correct file blocks and due to security of the pseudorandom function, the challenges (or the function's outputs) are not predictable. After collecting sufficient number of blocks, the extractor can use the error correcting code to decode and recover the entire file blocks, given the retrieved ones. 
 \hfill\(\Box\)\end{proof}
   
   \begin{remark}
   Recall,  the generic definition of a verifiable service scheme (i.e. Definition \ref{service-def}) involves three algorithms: $F$, $M$, and $Q$. However, the three algorithms are implicit in the original definition of  PoR and accordingly in  PoR protocols. In the following, we explain how each algorithm is defined in PoR context.  $M$ is an algorithm that processes a file and generates metadata. For instance, when PoR uses a Merkle tree (to ensure the file's integrity and availability), then $M$ refers to the Merkle tree's algorithm that constructs a tree on top of the file blocks. Also,  $F$ is an algorithm that, during generating a PoR proof, processes a subset of the outsourced file, given the client's query (or challenged file blocks). For instance, if a PoR  utilises a Merkle tree, then $F$ refers to the algorithm that generates Merkle tree's proofs, i.e.  membership of the challenged file blocks. Furthermore, $Q$ can be  a pseudorandom function that generates a set of pseudorandom strings in a certain range, e.g. file block's indices.   
   \end{remark}

