% !TEX root =R-zkCSP.tex

\section{Protocol For RC-PoR-P Without Arbiter's Involvement}\label{sec::R-PoR-P-protocol-Withohut-Arbiter}

In this section, we elaborate on how the original recurring contingent PoR payment (RC-PoR-P) protocol, presented in Section \ref{sec::RC-PoR-P-protocol}, can be adjusted such that the third-party arbiter's role, i.e. resolving disputes, is totally delegated to the smart contract, SC.  The new variant is denoted by  ${\text{RC-}\overline{\text{PoR}}\text{-P}}$. Briefly, Phases \ref{RC-PoR-P::KeyGen}-\ref{Client-sideProofVerification} remain  unchanged, with an exception. Namely,   in step \ref{setcounters}, only two counters $y_{\scriptscriptstyle\mathcal{C}}$ and $y_{\scriptscriptstyle\mathcal{S}}$ are created, instead of four counters; accordingly, in the same step,  vector $\bm{y}$ is now   $\bm{y}: [y_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  \texttt{Time},adr_{\scriptscriptstyle \text{SC}}]$, so counters $y'_{\scriptscriptstyle\mathcal{C}}$ and $y'_{\scriptscriptstyle\mathcal{S}}$  are excluded from the vector. At a high level,  the changes applied to phase \ref{RCPoRP::Dispute-Resolution} include that the parties send their complaints to SC now, SC does not maintain $y'_{\scriptscriptstyle\mathcal{C}}$ and $y'_{\scriptscriptstyle\mathcal{S}}$ anymore, SC takes the related steps  (on the arbiter's behalf), and it reads its internal state any time it needs to read data already stored on the contract. Moreover, the main adjustment to phase  \ref{RCPoRP::CoinTransfer} is that the amounts of coin each party receives  changes. For the sake of clarity, we  present  the modified version of  phases \ref{RCPoRP::Dispute-Resolution} and \ref{RCPoRP::CoinTransfer}, below. 




\begin{enumerate}
\item[\ref{RCPoRP::Dispute-Resolution}.] \textbf{Dispute Resolution}. \label{RCPoRP2::Dispute-Resolution2} $\mathtt{RCPoRP}. \mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}}, z, {\bm{\pi}}^{\scriptscriptstyle *}, \bm{q}^{\scriptscriptstyle *},  T_{\scriptscriptstyle qp})$


The phase takes place only in  case of dispute, i.e. when $\mathcal C$ rejects service proofs or $\mathcal S$ rejects the queries. %or either party does 

\begin{enumerate}

\item $\mathcal S$  sends ${m}_{\scriptscriptstyle\mathcal S}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to SC, at time $\texttt{K}_{\scriptscriptstyle 1}$, where $\texttt{K}_{\scriptscriptstyle 1}>\texttt{G}_{\scriptscriptstyle z,2} + \texttt{H}$

\item SC upon receiving ${m}_{\scriptscriptstyle\mathcal S}$ does the following a time $\texttt{K}_{\scriptscriptstyle 2}$. 
\begin{enumerate}

\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by  sending it to SAP contract which  returns   $1$ or $0$. If the output is $0$, then SC discards the server's complaint, $m_{\scriptscriptstyle\mathcal S}$, and does not take steps \ref{RCPoRP::check-v} and \ref{sc-check-server-claim}. Otherwise, it proceeds to the next step.


\item\label{RCPoRP2::check-v} Removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ any element that is duplicated or is not in the range $[1,z]$. It also constructs an empty vector $ {\bm{v}}$.

\item\label{sc-check-server-claim2}  For any element $i\in {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$:
\begin{itemize}

\item[$\bullet$] Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$
 
\item[$\bullet$]Checks if  the query is well-formed, by calling $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle i}, pp)\rightarrow b_{\scriptscriptstyle i}$. If the query is rejected, i.e. $ b_{\scriptscriptstyle i}=0$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by 1 and appends $i$ to $ {\bm{v}}$
\end{itemize}
Let $\texttt{K}_{\scriptscriptstyle 3}$ be the time SC finishes the above checks.
\end{enumerate}


\item $\mathcal C$  sends $m_{\scriptscriptstyle\mathcal C}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to SC, at time $\texttt{K}_{\scriptscriptstyle 4}$


\item SC upon receiving $m_{\scriptscriptstyle\mathcal C}$, does the following at time $\texttt{K}_{\scriptscriptstyle 5}$. 
\begin{enumerate}
\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by   sending $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. If the output is $0$, then SC discards the client's complaint, ${m}_{\scriptscriptstyle\mathcal C}$, and does not take steps \ref{sc-checks-client-claim}-\ref{the-contract-loop}. Otherwise, it proceeds to the next step. 

 \item\label{sc-checks-client-claim2} Ensures each vector   $ {\bm{m}}\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. In particular, it verifies there exist no two vectors: $ {\bm{m}}, {\bm{m}}'\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ such that $ {\bm{m}}[0]= {\bm{m}}'[0]$.  If such vectors  exist, it deletes the redundant ones from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$. This ensures no two claims refer to the same verification.  Also, it removes any vector $ {\bm{m}}$ from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ if $ {\bm{m}}[0]$ is not in the range $[1,z]$ or if $ {\bm{m}}[0]\in  {\bm{v}}$. Note the latter check  (i.e. $ {\bm{m}}[0]\in  {\bm{v}}$) ensures $\mathcal C$ cannot hold $\mathcal S$ accountable if $\mathcal C$ has generated an ill-formed query for the same verification.   

%\item Uses secret key $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$

\item\label{the-contract-loop2} For every  vector $ {\bm{m}}\in {\bm{m}}_{\scriptscriptstyle \mathcal{C}}$:
\begin{itemize}
\item[$\bullet$]  Retrieves details of a proof that was rejected in each $i$-th verification.  In particular, it sets   $i= {\bm{m}}[0]$ and $g= {\bm{m}}[1]$. Recall that $g$ refers to the index of a rejected proof in the proof vector which was generated for $i$-th verification, i.e. $ {\bm{\pi}}_{\scriptscriptstyle i}$ 


\item[$\bullet$]  Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$


\item[$\bullet$]  Removes the pads only from $g$-th padded encrypted proof. Let $ {\bm{\pi}}'_{\scriptscriptstyle i}[g]$ be the result. Next, it decrypts the  encrypted proof, $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle i}[g]))= {\bm{\pi}}_{\scriptscriptstyle i}[g]$

\item[$\bullet$] \label{dummy-vector2} Constructs a fresh vector: $ {\bm{\pi}}''_{\scriptscriptstyle i}$, such that  its $g$-th element equals $ {\bm{\pi}}_{\scriptscriptstyle i}[g]$ (i.e. $ {\bm{\pi}}''_{\scriptscriptstyle i}[g]=  {\bm{\pi}}_{\scriptscriptstyle i}[g] \text{ and } | {\bm{\pi}}''_{\scriptscriptstyle i}|= | {\bm{\pi}}_{\scriptscriptstyle i}|$) and the rest of its elements are dummy values. 

\item[$\bullet$] Calls   $\mathtt{PoRID.identify}( {\bm{\pi}}''_{\scriptscriptstyle i},g,\hat{k}_{\scriptscriptstyle i},pp)\rightarrow I_{\scriptscriptstyle i}$. If $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$  by $1$. Otherwise, it does nothing. 

\end{itemize}
\end{enumerate}
Let $\texttt{K}_{\scriptscriptstyle 6}$ be the time that SC finishes all the above checks.% in step \ref{the-contract-loop}

\end{enumerate} %%%%%%%%%

\

\item[\ref{RCPoRP::CoinTransfer}.] \textbf{Coin Transfer}. \label{RCPoRP::CoinTransfer2} $\mathtt{\mathtt{RCPoRP}}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})$
\begin{enumerate}


 \item If SC  receives  ``pay'' message  at time $\texttt{T}_{\scriptscriptstyle 2}$, where $a=0$ or $coins^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}<p_{\scriptscriptstyle\mathcal{S}}$, then it sends $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins to $\mathcal C$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$. Otherwise (i.e. they reach an agreement), they take the following step. 

\item Either $\mathcal C$ or $\mathcal S$ sends ``pay'' message and  statement $\ddot{x}_{\scriptscriptstyle cp}\in T_{\scriptscriptstyle cp}$ to SC at time $\texttt{L}>\texttt{K}_{\scriptscriptstyle 6}$
\item SC checks the validity of the statement by sending it  to SAP contract that  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal S}-y_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$

\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l( y_{\scriptscriptstyle\mathcal C}-y_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$

 
\end{itemize}

\end{enumerate}
\end{enumerate}




\begin{theorem}
The ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ protocol is secure, w.r.t. Definition \ref{def::RC-S-P-Security-2}, if PoRID, SAP, and blockchain are secure and the encryption scheme is semantically secure. 
\end{theorem}



 To prove the above theorem, we show that ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ meets all security properties defined in Appendix \ref{sec::RC-S-P-Definition2}.  We start by proving that ${\text{RC-}\overline{\text{PoR}}\text{-P}}$ meets security against a malicious server.   The proof to some extent is  simpler to that  of RC-PoR-P against a malicious server (i.e. proof of Lemma \ref{lemma::RC-PoR-P-SecurityAgainstMaliciousServer})  as it does not involve any third-party arbiter. 

 
 \input{RCPoRP-without-Arbiter-Proof}


%\in[ut{RC-PoR-P-Definition}

%\input{RC-PoR-P-Proof}



