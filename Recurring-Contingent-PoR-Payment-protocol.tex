% !TEX root =R-zkCSP.tex

\subsection{Recurring Contingent PoR Payment (RC-PoR-P) Protocol}
This section presents recurring contingent PoR payment (RC-PoR-P) protocol. It is built upon PoRID protocol and is in the same security model as RC-S-P is. RC-PoR-P inherits the features of PoRID and RC-PoR-P; however, unlike RC-PoR-P, it does not use any zero-knowledge proofs and there is no third-party arbiter involved. Even though RC-PoR-P and RC-S-P have some overlaps, they have many differences too. Therefore, we provide the protocol’s overview and its detailed description below.
At a high level the protocol works as follows. The client and server utilise SAP to provably agree on two private statements, one statement includes payment details, and another one specifies a secret key, $k$, and a pad's length. Moreover, they  agree on public parameters such as the private time bubble's length (that is the total number of billing cycles: $z$, plus a waiting period, $H$) and a smart contract that specifies $z$ and the total amount of masked coins each party should deposit. They deploy the contract. Each party deposits its masked coins in the contract within a fixed time. If any party does not deposit enough coins on time, then the parties have a chance to withdraw their coins and terminate the contract after a certain time. To start using/providing the service, the client invokes $\mathtt{PoRID.setup}()$ to encode the file and generate  metadata and public parameters. It sends  encryption of the metadata and public parameters to the smart contract and sends the encoded file to the server who decrypts them and using the encoded file checks their correctness by calling $\mathtt{PoRID.server}()$. If the server decides not to serve, it sends to the contract $0$ within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract. Otherwise, the server sends $1$ to the contract. 
At the end of each billing cycle, the client generates an encrypted query, by calling $\mathtt{PoRID.genQuery()}$ and encrypting its output using the key, $k$. It sends the result to the contract. In the same cycle, the server retrieves the query, and decrypts it. Then, it locally checks its correctness, by calling $\mathtt{PoRID.checkQuery()}$. If the query is rejected, the server locally stores the index of that billing cycle and generates a dummy PoR proofs. However, if the server accepts the query, it generates PoR proofs by calling $\mathtt{PoRID.prove()}$. Then, in either case, the server encrypts the proofs, pads them and sends the result to the contract. After that, the client removes the pads, decrypts the proofs and locally verifies them, by calling $\mathtt{PoRID.verify()}$. If the verification is passed, then the client knows the file is retrievable with a high probability. But, if the proof is rejected, then it locally stores the index of that billing cycle and waits until the private time bubble passes and dispute resolution time arrives. 

During the dispute resolution period, in case the server rejects the query or the client rejects the PoR proofs, that party sends to the contract (a) the indices of the billing cycles in which its counterparty provided invalid values, and (b)  the statement that contains the decryption key and padding detail. The contract checks the validity of the statement first. If it accepts the statement, then it removes the pads and decrypts the values whose indices were provided by the parties. Then, the contract checks the party’s claim by calling $\mathtt{PoRID.checkQuery ()}$ and $\mathtt{PoRID.identify ()}$ if the server or client calls the contract respectively. The contract also keeps track of the number of times each party provided invalid queries or PoR proofs.  
In the next phase, to distribute the coins, either client or server sends to the contract: (a) “pay” message, (b) the agreed statement that specifies the payment details, and (c) the statement’s proof. The contract verifies the statement and if it is approved, then the contract distributes the coins according to the statement’s detail, and the number of times each party misbehaved. 





\begin{enumerate}
\item \textbf{Key Generation}. 
\begin{enumerate}

\item  $\mathcal C$  picks a random secret key  $\bar{k}$ for a symmetric key encryption. Also, it sets  parameter $pad_{\scriptscriptstyle \pi}$ which is the number of  dummy values that will be used to pad encrypted proofs,  let $qp:=(pad_{\scriptscriptstyle \pi}, \bar{k})$. The key's size is part of the security parameter. 




\item  $\mathcal C$ sets coin parameters as   follows,   $o$: the amount of coins for each accepting proof,  as well as $l$ and $l'$ which are the amount of coins $\mathcal C$ and $\mathcal S$ respectively need to send to a smart contract to resolve a potential dispute.  Let $k':=\{o,l,l',qp\}$. 


\end{enumerate}

\item \textbf{Initiation}. 
\begin{enumerate}

\item For $\mathcal C$ and $\mathcal S$ to provably agree on $qp$, $\mathcal C$ sends $qp$ to  $\mathcal S$.  Next (if the $\mathcal S$ agrees on the parameters) they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $t_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp})$ be proof encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 


\item Let  $cp:=(o,o_{\scriptscriptstyle max},l,l',l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. For $\mathcal C$ and $\mathcal S$ to provably agree on $cp$, similar to the previous step, they invoke SAP, at time $T_{\scriptscriptstyle 1}$.  Let $t_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}$ is the opening and $g_{\scriptscriptstyle cp}$ is the commitment stored on the contract as a result of executing the  SAP. 


\item $\mathcal C$ sets   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ are   the total number of masked coins that $\mathcal C$ and $\mathcal S$ should deposit respectively. $\mathcal C$ signs and deploys  a smart contract, SC, that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. It deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract.

\item $\mathcal C$ constructs  vector $\bm{w}_{\scriptscriptstyle\mathcal C}$, also $\mathcal S$  constructs $\bm{v}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty. 


\item $\mathcal C$ runs $\mathtt{PoRID.setup}(1^{\lambda}, u)\rightarrow (u^{\scriptscriptstyle *},pk)$.  It sends  encoded file $u^{\scriptscriptstyle *}$ to $\mathcal S$, and sends the public key's encryption: $\mathtt{Enc}(\bar{k},pk)$ to SC at time $T_{\scriptscriptstyle 2}$

\item $\mathcal S$ checks the above parameters, and ensures sufficient amount of coins has been deposited.  If any check is rejected, then it sets $a=0$. Otherwise, it decrypts the public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$. It runs $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *},pk)\rightarrow a$. Next, it sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to SC at time $T_{\scriptscriptstyle 3}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$



\item $\mathcal C$  and  $\mathcal S$ can withdraw their coins at time $T_{\scriptscriptstyle 4}$, if the server sends $a=0$, fewer coins than $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$, or nothing to the SC


%
%
%\item $\mathcal C$ constructs  vector  $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$ and $\mathcal S$  constructs $ {\bm{v}}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty.   
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters, $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, $l$ and $l'$ which are the amount of coins $\mathcal C$ and $\mathcal S$ respectively need to send to a smart contract to resolve a dispute. Furthermore, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins $\mathcal C$ and $\mathcal S$ will use respectively. 


%where $l_{\scriptscriptstyle\mathcal C}$ and $l_{\scriptscriptstyle\mathcal S}$ cover the costs of a light verification of the client's and server's inputs respectively, while $l'_{\scriptscriptstyle\mathcal S}$ covers the cost of a more involved verification of the server's input.  

%\item $\mathcal C$ and $\mathcal S$ construct  a statement of the  form: $x=(o,l,l', f_{\scriptscriptstyle\mathcal C},f_{\scriptscriptstyle\mathcal S},z)$   
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_0$. Let $\mu$ be the statement's proof. 
%


%\item $\mathcal S$ picks and sends to $\mathcal C$ a random key, $\bar{k}$

%\item  $\mathcal C$ sends to $\mathcal S$ a statement of the form $x'=({pad},\bar{k})$ where  ${pad}$  specifies the number of  dummy values that will be used to pad encrypted proofs and    $\bar{k}$ is a  secret key.
%
%
%
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x'$, they take the steps in the Setup and Agreement phases in the SAP again, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 



%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $\bar{k}$, they take the steps in the Setup and Agreement phases in the SAP again, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 

%
%\item $\mathcal C$ and $\mathcal S$ agree on a smart contract: SC. Let $p_{\scriptscriptstyle\mathcal C}=z(o+l')+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ be the total number of coins the client and server should deposit respectively. SC  explicitly specifies  parameters $z$, $p_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}$. They sign and deploy the contract. 
%
%\item $\mathcal C$ and $\mathcal S$ deposit their masked coins in SC at time $T_{\scriptscriptstyle 2}$
%\item At time $T_{\scriptscriptstyle 3}$, if the deposit amount that either party has put is less than the amount stated in SC, then SC allows each party to withdraw its
%coins and terminate the contract.
%
%
%
%\item $\mathcal S$ decrypts the public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$. Next, it runs $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *},pk)\rightarrow a$ and then sends $a$  to SC at time $T_{\scriptscriptstyle 4}$
%
%\item $\mathcal C$ and $\mathcal S$ can withdraw their coins at time $T_{\scriptscriptstyle 5}$, if the server sends $a=0$ or nothing to the SC 

\end{enumerate}
%\item \textbf{Billing-cycles}. At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 

\item \textbf{Billing-cycles}. The parties do the following, at the end of  every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $G_{\scriptscriptstyle j,1}$ and $G_{\scriptscriptstyle j,2}$, where $G_{\scriptscriptstyle j,2}>G_{\scriptscriptstyle j,1}$, and $G_{\scriptscriptstyle 1,1}>T_{\scriptscriptstyle 4}$ 

%At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 
\begin{enumerate}

\item $\mathcal C$ calls $\mathtt{PoRID.genQuery}(1^{\lambda},  pk)\rightarrow \hat{k}_{\scriptscriptstyle j}$, to generate a query. It sends   $\hat{k}_{\scriptscriptstyle j}$ to SC at time $G_{\scriptscriptstyle j,1}$

%\item $\mathcal S$  appends $j$ to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the client's query was not posted on time. In this case, it does not take the next steps, for  $j$-th verification. 


%\item If $\mathcal S$ accepts the query, i.e. $b_{\scriptscriptstyle j}=1$, then it calls $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c_{\scriptscriptstyle j},pk)\rightarrow \pi_{\scriptscriptstyle j}$, to generate the service proof. In this case, $\mathcal S$ encrypts the proof, $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})=\pi'_{\scriptscriptstyle j}$. Next, it   pads the encrypted proof with ${pad}_{\scriptscriptstyle 2}$ random values that are picked from $U$. It sends the padded encrypted proof  to SC at time $G_{\scriptscriptstyle j,2}$. Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $\pi'_{\scriptscriptstyle j}\in U$,  pads the result as above, and sends the padded dummy proof to SC at time $G_{\scriptscriptstyle j,2}$.


%\item $\mathcal S$ decrypts the query,  $\mathtt{Dec(}\bar{k},\mathtt{Enc}(\bar{k},\hat{k}_{\scriptscriptstyle j}))=\hat{k}_{\scriptscriptstyle j}$.   Then, it calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pk)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness. 


\item $\mathcal S$ calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pk)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness. 

\begin{itemize}
\item[$\bullet$] If it accepts the query, then it calls $\mathtt{PoRID.prove}(u^{\scriptscriptstyle *},\hat{k}_{\scriptscriptstyle j},pk)\rightarrow  {\bm{\pi}}_{\scriptscriptstyle j}$, to generate a PoR  proof. In this case,  $\mathcal S$ encrypts every  proof in the proof vector, i.e. $\forall g, 1\leq g\leq| {\bm{\pi}}_{\scriptscriptstyle j}|: \mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle j}[g])= {\bm{\pi}}'_{\scriptscriptstyle j}[g]$. Let vector $ {\bm{\pi}}'_{\scriptscriptstyle j}$ contain the encryption of all proofs. It pads every encrypted proof in $ {\bm{\pi}}'_{\scriptscriptstyle j}$ with $pad_{\scriptscriptstyle \pi}$ random values that are picked from the encryption's output range $U$, (by appending the random values to the encrypted proofs vector). It sends the padded encrypted proofs  to SC at time $G_{\scriptscriptstyle j,2}$ 
\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $ {\bm{\pi}}'_{\scriptscriptstyle j}$ whose elements are randomly picked from $U$,  pads the result as above, and sends the padded dummy proof to SC at time $G_{\scriptscriptstyle j,2}$

\end{itemize}

When $j=z$  and $\bm{v}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, $\mathcal S$ sets    $\bm{m}_{\scriptscriptstyle\mathcal S}:[\bm{v}_{\scriptscriptstyle\mathcal{S}},\ddot{x}_{\scriptscriptstyle qp}, \text{``dispute''}]$.




%\item  $\mathcal C$ appends $j$ to $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$, if  $\mathcal S$ does not post the proof on time. In this case, it does not take the next steps, for  $j$-th verification. 


\item In this phase,  $\mathcal C$ verifies the service proof. It first constructs two empty vectors, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$ and $\bm{w}_{\scriptscriptstyle\mathcal{C}}=\bot$. Next, it removes the pads from the padded encrypted proofs and then
 decrypts the encrypted proofs: $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle j})= {\bm{\pi}}_{\scriptscriptstyle j}$. Then, it   calls $\mathtt{PoRID.verify}( {\bm{\pi}}_{\scriptscriptstyle j},\hat{k}_{\scriptscriptstyle j},pk)\rightarrow  {\bm{d}}_{\scriptscriptstyle j}$, to verify them. If $ {\bm{\pi}}_{\scriptscriptstyle j}$ passes the verification, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=1$, then $\mathcal C$  concludes that the service for this verification has been delivered successfully. Otherwise (if proof $ {\bm{\pi}}_{\scriptscriptstyle j}$ is rejected, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=0$), then it sets $g= {\bm{d}}_{\scriptscriptstyle j}[1]$ and appends vector $[j,g]$  to $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$. Recall, $ {\bm{d}}_{\scriptscriptstyle j}[1]$ refers to a rejected proof's index in proof vector $ {\bm{\pi}}_{\scriptscriptstyle j}$. If $j=z$  and $\bm{w}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    $\bm{m}_{\scriptscriptstyle\mathcal C}:[\bm{w}_{\scriptscriptstyle\mathcal{C}},\ddot{x}_{\scriptscriptstyle qp}, \text{``dispute''}]$.
  

\end{enumerate}
\item \textbf{Dispute Resolution}. The phase takes place only in  case of dispute, i.e. when $\mathcal C$ rejects service proofs or $\mathcal S$ rejects the queries. %or either party does not receive its counterparty's message on time. %A party who accepts all proofs does not need to get involved in this phase. 

\begin{enumerate}

%\item $\mathcal C$  at time $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$ sends ``dispute'' message to SC 

%\item $\mathcal S$ sends $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ to SC, at time $K_{\scriptscriptstyle 2}$ 


%\item SC  ensures $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ is well-formed. In particular, it removes from  $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ duplicated elements or  elements that are not in the range $[1,z]$. SC for every  element $i\in  {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ checks if $\mathcal C$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery};  if the client did not do so, then it appends $i$ to $ {\bm{v}}_{\scriptscriptstyle{SC}}$ and   increments $u_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal C}$ by $1$
 
 
 % and retakes step \ref{the-arbiter-loop} with the next element of $ {\bm{v}}$. Otherwise, it proceeds to the next step. 

\item $\mathcal S$  sends $\bm{m}_{\scriptscriptstyle\mathcal S}$ to SC, at time $K_{\scriptscriptstyle 1}$, where $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$

\item SC upon receiving $\bm{m}_{\scriptscriptstyle\mathcal S}$ does the following. 
\begin{enumerate}

\item Sets two  counters: $y_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal S}$  that are initially set to $0$. Also, it constructs an empty vector $ {\bm{v}}$ 
\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}\in \bm{m}_{\scriptscriptstyle\mathcal S}$, by  sending it to SAP contract which  returns   $1$ or $0$. If the output is $0$, then SC discards the server's complaint, $\bm{m}_{\scriptscriptstyle\mathcal S}$, and does not take steps \ref{sc-dec-server-key}-\ref{sc-check-server-claim}. Otherwise, it proceeds to the next step.

\item\label{sc-dec-server-key} Uses secret key $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$

\item Removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ any element that is duplicated or is not in the range $[1,z]$ 

\item\label{sc-check-server-claim}  For any element $i\in {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$:
\begin{itemize}
\item[$\bullet$] Fetches the related query, $\hat{k}_{\scriptscriptstyle i}$,   from SC 
\item[$\bullet$]Checks if  the query is well-formed, by calling $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle i}, pk)\rightarrow b_{\scriptscriptstyle i}$. If the query is rejected, i.e. $ b_{\scriptscriptstyle i}=0$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by 1 and appends $i$ to $ {\bm{v}}$
\end{itemize}
Let $K_{\scriptscriptstyle 2}$ be the time SC finishes the above checks.
\end{enumerate}





\item $\mathcal C$  sends $\bm{m}_{\scriptscriptstyle\mathcal C}$ to SC, at time $K_{\scriptscriptstyle 3}$
 %Also,  $\mathcal S$ sends $m_{\scriptscriptstyle\mathcal S}:( {\bm{v}}_{\scriptscriptstyle\mathcal{S}},\bar{k},\mu')$ to SC %,   where $| {\bm{v}}_{\scriptscriptstyle\mathcal{C}}|\neq 0$ and $| {\bm{v}}_{\scriptscriptstyle\mathcal{S}}|\neq 0$. 

%\item\label{check-client-claim} SC  ensures $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. Specifically, it  removes from  $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ any element that is duplicated, or   not in the range $[1,z]$.  Also, it removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ the elements that are in $ {\bm{v}}_{\scriptscriptstyle{SC}}$. Next, SC  for every  element $i\in  {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ checks if $\mathcal S$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery} and increments $u_{\scriptscriptstyle\mathcal S}$ and $y_{\scriptscriptstyle\mathcal S}$ by $1$  if the server did not do that.  It appends those $i$'s that pass the check to $ {\bm{v}}'_{\scriptscriptstyle{SC}}$. Note, $ {\bm{v}}'_{\scriptscriptstyle{SC}}$ contains the indices of verifications whose PoR proofs  were rejected by the client.


\item SC upon receiving $\bm{m}_{\scriptscriptstyle\mathcal C}$, does the following. 
\begin{enumerate}
\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}\in \bm{m}_{\scriptscriptstyle\mathcal C}$.  To do that, it sends $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. If the output is $0$, then SC discards the client's complaint, $\bm{m}_{\scriptscriptstyle\mathcal C}$, and does not take steps \ref{sc-checks-client-claim}-\ref{the-contract-loop}. Otherwise, it proceeds to the next step. 

 \item\label{sc-checks-client-claim} Ensures each vector   $ {\bm{w}}\in  {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. In particular, it verifies there exist no two vectors: $ {\bm{w}}, {\bm{w}}'\in  {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$ such that $ {\bm{w}}[0]= {\bm{w}}'[0]$.  If such vectors  exist, it deletes the redundant ones from $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$. This ensures no two claims refer to the same verification.  Also, it removes any vector $ {\bm{w}}$ from $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$ if $ {\bm{w}}[0]$ is not in the range $[1,z]$ or if $ {\bm{w}}[0]\in  {\bm{v}}$. Note the latter check  (i.e. $ {\bm{w}}[0]\in  {\bm{v}}$) ensures $\mathcal C$ cannot hold $\mathcal S$ accountable if $\mathcal C$ has generated an ill-formed query for the same verification.   

\item Uses secret key $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$

\item\label{the-contract-loop} For every  vector $ {\bm{w}}\in {\bm{w}}_{\scriptscriptstyle{C}}$:
\begin{itemize}
\item[$\bullet$]  Retrieves details of a proof that was rejected in each $i$-th verification.  In particular, it sets   $i= {\bm{w}}[0]$ and $g= {\bm{w}}[1]$. Recall that $g$ refers to the index of a rejected proof in the proof vector which was generated for $i$-th verification, i.e. $ {\bm{\pi}}_{\scriptscriptstyle i}$ 

\item[$\bullet$]  Fetches the related  query, $\hat{k}_{\scriptscriptstyle i}$, from SC.

\item[$\bullet$]  Removes the pads only from $g$-th padded encrypted proof. Let $ {\bm{\pi}}'_{\scriptscriptstyle i}[g]$ be the result. Next, it decrypts the  encrypted proof, $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle i}[g]))= {\bm{\pi}}_{\scriptscriptstyle i}[g]$

\item[$\bullet$] \label{dummy-vector} Constructs a fresh vector: $ {\bm{\pi}}''_{\scriptscriptstyle i}$, such that  its $g$-th element equals $ {\bm{\pi}}_{\scriptscriptstyle i}[g]$ (i.e. $ {\bm{\pi}}''_{\scriptscriptstyle i}[g]=  {\bm{\pi}}_{\scriptscriptstyle i}[g] \text{ and } | {\bm{\pi}}''_{\scriptscriptstyle i}|= | {\bm{\pi}}_{\scriptscriptstyle i}|$) and the rest of its elements are dummy values. 

\item[$\bullet$] Calls   $\mathtt{PoRID.identify}( {\bm{\pi}}''_{\scriptscriptstyle i},g,\hat{k}_{\scriptscriptstyle i},pk)\rightarrow I_{\scriptscriptstyle i}$. If $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$  by $1$. Otherwise, it does nothing. 

\end{itemize}
\end{enumerate}
Let $K_{\scriptscriptstyle 4}$ be the time that SC finishes all the above checks.% in step \ref{the-contract-loop}

\end{enumerate} %%%%%%%%%

\item \textbf{Coin Transfer}.
\begin{enumerate}
\item Either $\mathcal C$ or $\mathcal S$ sends ``pay'' message and the statement: $\ddot{x}_{\scriptscriptstyle cp}$ to SC at time $L>K_{\scriptscriptstyle 4}$
\item SC checks the validity of the statement by sending it  to SAP contract that  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l\cdot y_{\scriptscriptstyle\mathcal S}-l'\cdot y_{\scriptscriptstyle\mathcal C}$ coins  to $\mathcal C$

\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l\cdot y_{\scriptscriptstyle\mathcal S}+l'\cdot y_{\scriptscriptstyle\mathcal C}$ coins to $\mathcal S$
%\item[$\bullet$] $l(u_{\scriptscriptstyle\mathcal S}+u_{\scriptscriptstyle\mathcal C}+y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C})$ coins to the arbiter.  
\end{itemize}

\end{enumerate}
\end{enumerate}


\begin{remark}
The reason in step \ref{dummy-vector} vector $ {\bm{\pi}}''_{\scriptscriptstyle i}$ is constructed  is to let SC make \emph{black-box}  use of $\mathtt{PoRID.identify}()$. Alternatively, SC could decrypt all proofs in $\mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle i})$ and pass them to $\mathtt{PoRID.identify}()$. However, this approach would impose a high cost, as all proofs have to be decrypted. 
\end{remark}

\begin{remark}
In general, a transaction that is sent   to a smart contract should  cover the cost of the contract's execution. Therefore, in the above protocol, if a party unnecessarily invokes a contract for an accepting proof, it has to pay the execution cost in advance. This is the reason the above protocol (unlike RC-S-P protocol) does not need to track the number of times a party unnecessarily invokes the contract.    
\end{remark}


%\input{RC-PoR-P-Proof}



