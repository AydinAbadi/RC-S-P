% !TEX root =R-zkCSP.tex


\begin{theorem}
The RC-PoR-P protocol is secure, w.r.t. Definition \ref{def::RC-S-P-Security}, if PoRID and SAP are secure and the encryption scheme is semantically secure. 
\end{theorem}


 In order to prove the above theorem, we show that RC-PoR-P meets all the security properties defined in Section \ref{sec::RC-S-P-Definition}.  We first prove that RC-PoR-P satisfies security against a malicious server.  

 \begin{lemma}
 If SAP is secure and  PoRID scheme supports correctness, soundness, and detectable abort, then RC-PoR-P is secure against malicious server, w.r.t. Definition \ref{deff::RC-S-P-SecurityAgainstMaliciousServer}. 
 \end{lemma}
 

 \begin{proof}[sketch]
 We first consider event $F(u^{\scriptscriptstyle *},\bm{q}_{\scriptscriptstyle j})= h_{\scriptscriptstyle j}\ \wedge coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$ that captures the case where the server provides an accepting service proof but makes the client withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{C},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}-o$. In this case, since the proof is valid, an honest client accepts it and does not raise any dispute. 
  However, the server  would be able to make the client  withdraw incorrect amounts of coins, if it manages to either convince the arbiter that the client has misbehaved (through dispute resolution phase), or submit to the contract, at the coin transfer phase,  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$. Nevertheless, it cannot falsely accuse the client of misbehaviour. Because,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key or pads other than what was agreed with the client in the initiation phase; specifically, it cannot persuade the arbiter to accept  $\ddot{x}'_{\scriptscriptstyle qp}$, where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$, except with a negligible probability, $\mu(\lambda)$. This ensures that the honest client's message is accessed by  the arbiter with a high probability, as the arbiter can extract the client's message using valid pad information and decryption key. Moreover,  due to the security of SAP, the server cannot persuade the contract to accept any statement other than what was agreed initially between the client and server, except with a negligible probability $\mu(\lambda)$ when it finds the hash function's collision. Also, due to the correctness of VSID, the arbiter always accepts the honest client's accepting proof. 

We now move on to event $F(u^{\scriptscriptstyle *}, \bm{q}_{\scriptscriptstyle j})\neq h_{\scriptscriptstyle j} \ \wedge (d_{\scriptscriptstyle j}=1	\vee y_{\scriptscriptstyle \mathcal S}[j]=0 \ \vee (coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z} \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l))$ which captures the case where the server provides an invalid service proof but either persuades the client to accept the proof, or  (when the client raises a dispute)  persuades the arbiter to accept the proof or makes the client or arbiter withdraw an incorrect amount of coins, i.e.    $coin_{\scriptscriptstyle\mathcal{C},j}\neq \frac{coin_{\scriptscriptstyle\mathcal C}^{\scriptscriptstyle*}}{z}$ or $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively.   Nevertheless, due to the soundness of VSID, the probability that a corrupt server can convince an honest client to accept invalid proof (i.e. outputs $d_{\scriptscriptstyle j}=1$), is negligible, $\mu(\lambda)$. On the other hand, in the case where the client rejects the proof and raises a dispute, the server may try to convince the arbiter and make it output $y_{\scriptscriptstyle \mathcal S}[j]=0$, e.g. by sending a complaint right after the client does. But, for the adversary to win, it has to either provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the client (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification, which   requires finding the hash function's collision, and its probability of success is negligible, $\mu(\lambda)$. Or it makes the arbiter  accept an invalid proof, but due to the detectable abort property of VSID, its probability of success is also negligible, $\mu(\lambda)$. In the case where the adversary does not succeed in convincing the client or arbiter, it may still try to  make them withdraw an incorrect amount of coins. To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the client. But, it would succeed only with a negligible probability, $\mu(\lambda)$, due to the security of SAP. 

Furthermore, in   both  events above, due to the security of SAP, the adversary cannot block an honest client's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
  \hfill\(\Box\)\end{proof}



\begin{lemma}
 If SAP is secure and  VSID scheme supports correctness, inputs well-formedness, and detectable abort, then RC-S-P is secure against malicious client, w.r.t. Definition \ref{deff::RC-S-P-Security-Against Malicious-Client}. 
\end{lemma}


\begin{proof}[sketch]
  First, we consider event  $(M(u^{\scriptscriptstyle *},k)= \sigma  \wedge Q(\text{aux},k)= \bm{q}_{\scriptscriptstyle j}) \wedge
  (coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o)$ which captures the case where the client provides  accepting metadata and query  but makes the server withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq  \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$. In short, for the event to  happen with a high probability, a malicious client has to break the security of SAP. In particular, since the metadata and query's proofs are valid, an honest server accepts them and does not raise any dispute.  But, the client may want to  make the server  withdraw incorrect amounts of coins, if it manages to either convince the arbiter, in phase \ref{RCSP::Dispute-Resolution}, that the server has misbehaved, or submit to the contract  an accepting  statement $\ddot{x}'_{\scriptscriptstyle cp}$ other than what was agreed at the initiation phase, i.e. $\ddot{x}_{\scriptscriptstyle cp}$, in phase \ref{RCSP::CoinTransfer}. However, it cannot falsely accuse the server of misbehaviour. As,  due to the security of SAP, it cannot  convince the arbiter to accept different decryption key and pads, by providing a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$  (where $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$), than what was initially agreed with the server, except with  probability $\mu(\lambda)$. This ensures that  the arbiter is given the honest server's messages (with a high probability). Moreover,  due to the security of SAP, the client cannot convince the contract to accept any accepting statement other than what was initially agreed  between the client and server, except with   probability $\mu(\lambda)$. Furthermore,   the correctness of VSID guarantees that  the arbiter always accepts the honest server's accepting proof. 
  
    We now turn our attention to $(M(u^{\scriptscriptstyle *},k)\neq \sigma \wedge a=1)\ \vee\ (Q(\text{aux},k)\neq \bm{q}_{\scriptscriptstyle j} \wedge b_{\scriptscriptstyle j}=1)$,   that captures the case where the server accepts an ill-formed metadata, or query. However, due to inputs well-formedness of VSID, the probability that either of the events happens is negligible, $\mu(\lambda)$. Next, we move of to      $Q(\text{aux},k)\neq \bm{q}_{\scriptscriptstyle j} \wedge
  (y_{\scriptscriptstyle\mathcal{C}}[j]=0 \ \vee  coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o \ \vee  coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l)$.  It considers the case where the client provides an invalid query, but  either convinces the arbiter to accept it, or  makes the server or arbiter  withdraw an incorrect amount of coins, i.e. $coin_{\scriptscriptstyle\mathcal{S},j}\neq \frac{coin_{\scriptscriptstyle\mathcal S}^{\scriptscriptstyle*}}{z}+o$ or  $coin_{\scriptscriptstyle\mathcal{A}r,j}\neq l$ respectively. Note, when the server rejects the query and raises a dispute, the client may try to convince the arbiter, and make it output $y_{\scriptscriptstyle \mathcal C}[j]=0$, e.g. by sending a complaint right after the server does so. However, for the adversary to win, either it has to provide a different accepting statement $\ddot{x}'_{\scriptscriptstyle qp}$, than what was initially agreed with the server (i.e. $\ddot{x}'_{\scriptscriptstyle qp}\neq \ddot{x}_{\scriptscriptstyle qp}$) and passes the verification. But,  due to the security of SAP, its probability of success is negligible, $\mu(\lambda)$. Or it has to make the arbiter  accept an invalid query, i.e. makes the arbiter output $y_{\scriptscriptstyle\mathcal{C}}[j]=0$. Nevertheless, due to the detectable abort property of VSID, its probability of success is  negligible, $\mu(\lambda)$. If the adversary does not succeed in convincing the server or arbiter, it may still try to  make them withdraw an incorrect amount of coins. To this end, at the coin transfer phase, it has to send a  different accepting statement  than what was initially agreed with the server. However, due to the security of SAP, its  success probability is negligible, $\mu(\lambda)$. Also, due to the security of SAP, the adversary cannot block an honest server's  messages, ``pay'' and $\ddot{x}_{\scriptscriptstyle cp}$, to the contract in the coin transfer phase.
 \hfill\(\Box\)\end{proof}
  
  
  Prior to proving  RC-S-P's privacy, we provide a lemma that will be used in the privacy's proof. Informally, the lemma states that encoded coins leaks no information about the actual amount of coins $(o,l)$, agreed between the client and server. 


\begin{lemma}\label{lemma::encoded-coins} Let $\beta\stackrel{\scriptscriptstyle\$}\leftarrow\{0,1\}$, price list be $\{(o_{\scriptscriptstyle 0},l_{\scriptscriptstyle 0}),(o_{\scriptscriptstyle 1},l_{\scriptscriptstyle 1})\}$, and encoded coin amounts be $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}= z\cdot(Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta},l_{\scriptscriptstyle|\beta-1|}))$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot(Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle |\beta-1|}))$. Then, given the price list, $z$, $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}$, and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}$, an adversary $\mathcal{A}$ cannot tell the value of $\beta$ with probability significantly greater than $\frac{1}{2}$ (where the probability is taken over the choice of $\beta$ and the randomness of $\mathcal{A}$).
\end{lemma}



\begin{proof}
As it is evident, the list and $z$ contains no information about $\beta$. Also, since  $z$ is a public value, we could have   $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=\frac{coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}}{z} = Max(o_{\scriptscriptstyle\beta},o_{\scriptscriptstyle|\beta-1|})+Max(l_{\scriptscriptstyle\beta}, l_{\scriptscriptstyle|\beta-1|})$. It is not hard to see $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ is a function of maximum value of $(o_{\scriptscriptstyle 0},o_{\scriptscriptstyle 1})$, and maximum value of $(l_{\scriptscriptstyle 0},l_{\scriptscriptstyle 1})$. It is also  independent of $\beta$. Therefore, given the list, $z$ and $coin'^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ the adversary learns nothing about $\beta$, unless it guesses the value,  with  success probability $\frac{1}{2}$. The same also holds for $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. 
 \hfill\(\Box\)\end{proof}


\begin{lemma} If SAP is secure and the encryption scheme is semantically secure, then RC-S-P preserves privacy, w.r.t. Definition \ref{deff::RC-S-P-Privacy}. 
\end{lemma}

\begin{proof}[sketch]
Due to the privacy property of SAP, that stems from the  hiding property of the commitment scheme, given the commitments $g_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}$, (that are stored in the blockchain as result of running SAP) the adversary learns no information about the committed values (e.g. $o, l, pad_{\scriptscriptstyle\pi}, pad_{\scriptscriptstyle q},$ and $\bar{k}$), except with negligible probability, $\mu_{\scriptscriptstyle 1}(\lambda)$.   Also, given encoded coins $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{C}}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, the adversary learns nothing about the actual price agreed between the server and client,  $(o,l)$, for each verification, due to Lemma \ref{lemma::encoded-coins}. Next we analyse the privacy of padded encrypted query vector $\bm{c}^{\scriptscriptstyle *}$. For  the sake of simplicity, we focus on   $\bm{q}^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$, that is a padded encrypted query vector for $j$-th verification. Let $\bm{q}_{\scriptscriptstyle j,0}$ and $\bm{q}_{\scriptscriptstyle j,1}$  be query vectors, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$ that    are picked by the adversary according to  Definition  \ref{deff::RC-S-P-Privacy} which lets  the environment pick $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$. Also, let $\{\bm{q}_{\scriptscriptstyle j,0},...,\bm{q}_{\scriptscriptstyle j,m}\}$ be a  list of all queries of different sizes. In the experiment, if $\bm{q}_{\scriptscriptstyle j,\beta}$  is only   encrypted (but not padded), then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$,  under the assumption  that $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)=|\bm{q}_{\scriptscriptstyle j,\beta}|$. The  assumption is  relaxed with the use of a pad; as each encrypted query is padded  to the queries' maximum size, i.e. $Max(|\bm{q}_{\scriptscriptstyle j,0}|,...,|\bm{q}_{\scriptscriptstyle j,m}|)$, the adversary cannot tell with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 1}(\lambda)$ if the  padded encrypted proof corresponds to  $\bm{q}_{\scriptscriptstyle j,0}$ or $\bm{q}_{\scriptscriptstyle j,1}$, as the padded encrypted query \emph{always has the same size} and the pad values are picked from the same range as the encryption's ciphertext are defined. The same argument holds for $\bm{w}^{\scriptscriptstyle *}_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}}\in c^{\scriptscriptstyle *}_{\scriptscriptstyle j}\in\bm{c}^{\scriptscriptstyle *}$. 

Next we analyse the privacy of padded encrypted proof vector $\bm{\pi}^{\scriptscriptstyle *}$. The argument is similar to the one presented above; however, for  the sake of completeness we provide it.  Again, we focus on an element of the vector,  $\pi_{\scriptscriptstyle j}^{\scriptscriptstyle *}\in\bm{\pi}^{\scriptscriptstyle *}$, that is a padded encrypted proof for $j$-th verification. Let $\pi_{\scriptscriptstyle j,0}$ and $\pi_{\scriptscriptstyle j,1}$  be proofs, for $j$-th verification, related to the service inputs $u_{\scriptscriptstyle 0}$ and $u_{\scriptscriptstyle 1}$, where the inputs   are picked by the adversary, w.r.t. Definition  \ref{deff::RC-S-P-Privacy} in which  the environment picks $\beta\stackrel{\scriptscriptstyle\$}\leftarrow \{0,1\}$.  Let $\{\pi_{\scriptscriptstyle j,0},...,\pi_{\scriptscriptstyle j,m}\}$ be proof list including all proofs of different sizes. In the experiment, if $\pi_{\scriptscriptstyle j,\beta}$  is only   encrypted, then given the ciphertext, due to semantical security of the encryption, an adversary cannot tell if the ciphertext corresponds to $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$  (accordingly to $u_{\scriptscriptstyle 0}$ or $u_{\scriptscriptstyle 1}$) with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$,  if $Max(|\pi_{\scriptscriptstyle j,0}|,...,|\pi_{\scriptscriptstyle j,m}|)=|\pi_{\scriptscriptstyle j,\beta}|$. However, the  assumption is  relaxed with the use of a pad. In particular, since each encrypted proof is padded  to the proofs' maximum size, the adversary cannot tell with probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$ if the  padded encrypted proof corresponds to  $\pi_{\scriptscriptstyle j,0}$ or $\pi_{\scriptscriptstyle j,1}$. Also, since the value of $a$ is independent of $u_{\scriptscriptstyle 0}$  or $u_{\scriptscriptstyle 1}$, and only depends on whether the metadata is well-formed, it leaks nothing about the service input $u_{\scriptscriptstyle\beta}$ and $\beta$. Moreover, since each padded encrypted query and proof leak no information and always contains a fixed number of elements, an adversary cannot tell the status of a proof for each $j$-th verification (i.e. whether it is accepted or rejected) with the probability greater than $\frac{1}{2}+\mu_{\scriptscriptstyle 2}(\lambda)$, given  $\bm{c}^{\scriptscriptstyle *},coin^{\scriptscriptstyle *}_{\scriptscriptstyle \mathcal S},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}, g_{\scriptscriptstyle cp},  g_{\scriptscriptstyle qp},$  $\bm{\pi}^{\scriptscriptstyle *}$, and $a$.
  \hfill\(\Box\)\end{proof}


