% !TEX root =R-zkCSP.tex

\subsection{Recurring Contingent PoR Payment (RC-PoR-P) Protocol}\label{sec::RC-PoR-P-protocol}



In this section, we present RC-PoR-P,  a concrete instantiation of the generic RC-S-P.  Although RC-PoR-P and RC-S-P have some overlaps, they have many differences too. Therefore, we provide the protocol’s overview and its detailed description below.
At a high level the protocol works as follows. The client and server utilise SAP to provably agree on two private statements, one statement includes payment details, and another one specifies a secret key, $\bar{k}$, and a pad's details, that will be used to encode sensitive messages they send to the contract. Moreover, they  agree on public parameters such as the private time bubble's length (that is the total number of billing cycles: $z$, plus a waiting period, $\texttt{H}$) and a smart contract that specifies $z$ and the total amount of masked coins each party should deposit. They deploy the contract. Each party deposits its masked coins in the contract within a fixed time. If a party does not deposit enough coins on time, then the parties have a chance to withdraw their coins and terminate the contract after a certain time. 

To start using/providing the service, the client invokes $\mathtt{PoRID.setup}(.)$ to encode the file and generate  metadata and public parameters. It sends  encryption of the metadata and public parameters to the smart contract. Also, it  sends the encoded file to the server who decrypts them and using the encoded file checks their correctness by calling $\mathtt{PoRID.server}(.)$. If the server decides not to serve, it sends to the contract $0$ within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract.  At the end of each billing cycle, the client generates a query, by calling $\mathtt{PoRID.genQuery(.)}$ and sends the query's encryption to the contract. In the same cycle, the server retrieves the query from the contract, decrypts and locally checks its correctness, by calling $\mathtt{PoRID.checkQuery(.)}$. If the query is rejected, the server locally stores the index of that billing cycle and generates  dummy PoR proofs. However, if the server accepts the query, it generates PoR proofs by calling $\mathtt{PoRID.prove(.)}$. Then, in either case, the server encrypts the proofs, pads them and sends the result to the contract. Next, the client removes the pads, decrypts the proofs and locally verifies them, by calling $\mathtt{PoRID.verify(.)}$. If the verification is passed, then the client knows the file is retrievable with a high probability. But, if the proof is rejected, then it locally stores the index of that billing cycle and details of one of the invalid proofs (in the same cycle). It  waits until the private time bubble passes and dispute resolution time arrives. 

During the dispute resolution period, in case the server rejects the query or the client rejects the PoR proofs, that party sends to the arbiter (a) details of invalid proofs and (b)  the statement that contains the decryption key and padding detail. The arbiter checks the validity of the statement first. If it accepts the statement, then it removes the pads and decrypts the values whose indices were provided by the parties. Then, the arbiter checks the party’s claim by calling $\mathtt{PoRID.checkQuery (.)}$ and $\mathtt{PoRID.identify (.)}$ if the server or client calls the contract respectively. The arbiter also keeps track of the number of times each party misbehaved.  After the arbiter processes the parties' claim, it tells to the contract how many times each party misbehaved.  In the next phase, to distribute the coins, either client or server sends to the contract: (a) “pay” message, (b) the agreed statement that specifies the payment details, and (c) the statement’s proof. The contract verifies the statement and if it is approved, then it distributes the coins according to the statement’s detail, and the number of times each party misbehaved. 



\begin{enumerate}
\item\label{RC-PoR-P::KeyGen} \textbf{Key Generation}. $\mathtt{RCPoRP}.\mathtt{keyGen}(1^{\scriptscriptstyle\lambda})$
\begin{enumerate}

\item  $\mathcal C$  picks a random secret key  $\bar{k}$ for a symmetric key encryption. It also sets  parameter $pad_{\scriptscriptstyle \pi}$ which is the number of  dummy values that will be used to pad encrypted proofs,  let $qp:=(pad_{\scriptscriptstyle \pi}, \bar{k})$. The key's size is part of the security parameter. Let  ${k}:=(sk',pk')$, where  $sk'=qp$ and $pk':=(adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\mathcal{S}})$. 





\end{enumerate}

\

\item \textbf{Client-side Initiation}. $\mathtt{RCPoRP}.\mathtt{cInit}(1^\lambda, u,{k}, z,pl)$
\begin{enumerate}

\item Calls $\mathtt{PoRID.setup}(1^{\lambda}, u)\rightarrow (u^{\scriptscriptstyle *},pp)$ to encode service input. It appends $pp$ to $qp$.


\item  Calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},qp )\rightarrow(r_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp}, adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}})$, to initiate an agreement (with $\mathcal{S}$) on $qp$.  Let $T_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp})$ be proof/query encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}:=(qp,r_{\scriptscriptstyle qp})$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 


\item   Sets coin parameters (given  price list $pl$) as  follows,  $o$: the amount of coins for each accepting proof,  and $l$ the amount of coin $\mathcal C$  or $\mathcal S$ needs to send to a smart contract to resolve a potential dispute. 






\item\label{RC-PoR-P::set-cp}  Sets  $cp:=(o,o_{\scriptscriptstyle max}, l,  l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. Then, $\mathcal C$ calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},cp )\rightarrow(r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}})$, to initiate an agreement (with $\mathcal{S}$) on $cp$. Let $T_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}:=(cp,r_{\scriptscriptstyle cp})$ is the opening and $g_{\scriptscriptstyle cp}$ is the commitment stored on the contract as a result of executing   SAP.  





\item Set parameters  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $p_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal{S}}$ are   the total number of masked coins $\mathcal C$ and $\mathcal S$ should deposit respectively. It signs and deploys a smart contract, SC, that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$, $p_{\scriptscriptstyle\mathcal{S}}$,  $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}}$, and $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}}$. Let $adr_{\scriptscriptstyle \text{SC}}$ be the address of the deployed SC, and $T:=\{T_{\scriptscriptstyle qp},T_{\scriptscriptstyle cp}\}$. It sets a set of time points/windows, $\texttt{Time}:\{ \texttt{T}_{\scriptscriptstyle 0},..., \texttt{T}_{\scriptscriptstyle 3},\texttt{G}_{\scriptscriptstyle 1,1},...,\texttt{G}_{\scriptscriptstyle z,2},\texttt{H}, \texttt{K}_{\scriptscriptstyle 1},...,\texttt{K}_{\scriptscriptstyle 6}, \texttt{L}\}$, that are explicitly specified in SC who will accept a certain party's message only in a specified  time point/window. Time allocations will become clear in the next phases. 


\item\label{setcounters} Sets four counters $[y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal S}]$ in the contract, where their initial value is $0$. Let $\bm{y}: [y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal S},\texttt{Time},adr_{\scriptscriptstyle \text{SC}}]$

\item Deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract. It  sends $u^{\scriptscriptstyle *}, e, \ddot{x}_{\scriptscriptstyle qp},\ddot{x}_{\scriptscriptstyle cp}$, and $p_{\scriptscriptstyle\mathcal{S}}$ (along with $adr_{\scriptscriptstyle \text{SC}}$) to $\mathcal S$. It also sends  $pk'$ to SC. Let $\texttt{T}_{\scriptscriptstyle 0}$ be the time that the above process finishes. 




\end{enumerate}

\
\item \textbf{Server-side Initiation}\label{RCPoRP::Server-side-Initiation}. $\mathtt{RCPoRP}.\mathtt{sInit}(u^{\scriptscriptstyle *},  z, T, p_{\scriptscriptstyle\mathcal{S}} ,\bm{y})$

\begin{enumerate}

\item Checks the parameters  in $T$ (e.g. $qp$ and $cp$) and  in SC (e.g. $p_{\scriptscriptstyle\mathcal{S}}, \bm{y}$) and ensures sufficient amount of coins has been deposited by $\mathcal C$.  

\item Calls $\mathtt{SAP.agree}(qp,r_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{1}})\rightarrow (g'_{\scriptscriptstyle qp},b_{\scriptscriptstyle 1})$ and $\mathtt{SAP.agree}(cp,r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{2}})\rightarrow (g'_{\scriptscriptstyle cp},b_{\scriptscriptstyle 2})$, to verify the correctness of tokens in $T$ and to agree on the tokens' parameters, where $qp,r_{\scriptscriptstyle qp}\in \ddot{x}_{\scriptscriptstyle qp}, \text{and }  cp,r_{\scriptscriptstyle cp} \in  \ddot{x}_{\scriptscriptstyle cp}$. Recall, if both $\mathcal{C}$ and $\mathcal{S}$ are honest, then $g_{\scriptscriptstyle qp}=g'_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}=g'_{\scriptscriptstyle cp}$. 




\item If any above check is rejected, then it sets $a=0$. Otherwise, it  calls $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *}, {pp})\rightarrow a$. 

\item Sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=p_{\scriptscriptstyle\mathcal{S}}$ coins to SC at time $\texttt{T}_{\scriptscriptstyle 1}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$
\end{enumerate}
Note, $\mathcal S$  and  $\mathcal C$ can withdraw their coins at time $\texttt{T}_{\scriptscriptstyle 2}$, if  $\mathcal S$ sends $a=0$, fewer coins than $p_{\scriptscriptstyle\mathcal{S}}$, or nothing to the SC. To withdraw, $\mathcal S$  or  $\mathcal C$  simply sends a ``pay'' message to $\mathtt{RCPoRP}.\mathtt{pay}(.)$ algorithm only at time $\texttt{T}_{\scriptscriptstyle 2}$.

\




\textbf{\textit{Billing-cycles Onset}}. $\mathcal{C}$ and $\mathcal{S}$ engage in the following three phases, i.e. phase \ref{Billing-cycles-genQuery}-\ref{Client-sideProofVerification},  at the end of every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $\texttt{G}_{\scriptscriptstyle j,1}$ and $\texttt{G}_{\scriptscriptstyle j,2}$, where $\texttt{G}_{\scriptscriptstyle j,2}>\texttt{G}_{\scriptscriptstyle j,1}$, and $\texttt{G}_{\scriptscriptstyle 1,1}>\texttt{T}_{\scriptscriptstyle 2}$ 


\

\item\textbf{Client-side Query Generation}.\label{Billing-cycles-genQuery} $\mathtt{RCPoRP}.\mathtt{genQuery}(1^\lambda,  T_{\scriptscriptstyle qp})$

\begin{enumerate}

\item Calls $\mathtt{PoRID.genQuery}(1^{\lambda},  pp)\rightarrow \hat{k}_{\scriptscriptstyle j}$ to generate a query, where  $ pp\in T_{\scriptscriptstyle qp}$


\item Sends encrypted query  $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}=\mathtt{Enc}(\bar{k},\hat{k}_{\scriptscriptstyle j})$ to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$


\end{enumerate}

\

\item\textbf{Server-side Proof Generation}. $\mathtt{RCPoRP}.\mathtt{prove}(u^{\scriptscriptstyle *},  \hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}, T_{\scriptscriptstyle qp})$


\begin{enumerate}

\item Constructs an empty  vector, $\bm{m}_{\scriptscriptstyle\mathcal S}=\bot$, if $j=1$.  

\item Decrypts the query, $\hat{k}_{\scriptscriptstyle j}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j})$

\item Calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pp)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness.

\begin{itemize}
\item[$\bullet$] If it accepts the query, then it calls $\mathtt{PoRID.prove}(u^{\scriptscriptstyle *},\hat{k}_{\scriptscriptstyle j},pp)\rightarrow  {\bm{\pi}}_{\scriptscriptstyle j}$, to generate a PoR  proof. In this case,  $\mathcal S$ encrypts every  proof in the proof vector, i.e. $\forall g, 1\leq g\leq| {\bm{\pi}}_{\scriptscriptstyle j}|: \mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle j}[g])= {\bm{\pi}}'_{\scriptscriptstyle j}[g]$, where $\bar{k}\in T_{\scriptscriptstyle qp}$. Let vector $ {\bm{\pi}}'_{\scriptscriptstyle j}$ contain the encryption of all proofs. It pads every encrypted proof in $ {\bm{\pi}}'_{\scriptscriptstyle j}$ with ${pad}_{\scriptscriptstyle \pi}\in T_{\scriptscriptstyle qp}$ random values that are picked from the encryption's output range $U$, (by appending the random values to the encrypted proofs vector). Let $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. It sends the padded encrypted proofs  to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ 
\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{m}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $ {\bm{\pi}}'_{\scriptscriptstyle j}$ whose elements are randomly picked from $U$,  pads the result as above, and sends the result, $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$

\end{itemize}

When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, it sets    $m_{\scriptscriptstyle\mathcal S}:=\bm{m}_{\scriptscriptstyle\mathcal{S}}$.

\end{enumerate}




\


\item \textbf{Client-side Proof Verification}.\label{Client-sideProofVerification} $\mathtt{RCPoRP}.\mathtt{verify}(\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \hat{k}_{\scriptscriptstyle j},T_{\scriptscriptstyle qp})$
\begin{enumerate}


\item Constructs an empty vector, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$, if $j=1$. 

\item Removes the pads from $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, utilising  parameters of $T_{\scriptscriptstyle qp}$. Let $\bm{\pi}'_{\scriptscriptstyle j}$ be the result. It decrypts the service proofs $\mathtt{Dec}(\bar{k},\bm{\pi}'_{\scriptscriptstyle j})=\bm{\pi}_{\scriptscriptstyle j}$ and then calls $\mathtt{PoRID.verify}(\bm{\pi}_{\scriptscriptstyle j}, \hat{k}_{\scriptscriptstyle j}, {pp})\rightarrow \bm{d}_{\scriptscriptstyle j}$, to verify the proof.  

\begin{itemize}
\item[$\bullet$] If $ {\bm{\pi}}_{\scriptscriptstyle j}$ passes the verification, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=1$, then $\mathcal C$  concludes that the service for this verification has been delivered successfully.  


\item[$\bullet$] Otherwise (if proof $ {\bm{\pi}}_{\scriptscriptstyle j}$ is rejected, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=0$),  it sets $g= {\bm{d}}_{\scriptscriptstyle j}[1]$ and appends vector $[j,g]$  to $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$. Recall, $ {\bm{d}}_{\scriptscriptstyle j}[1]$ refers to a rejected proof's index in proof vector $ {\bm{\pi}}_{\scriptscriptstyle j}$. 

\end{itemize}
\end{enumerate}
When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    ${m}_{\scriptscriptstyle\mathcal C}:=\bm{m}_{\scriptscriptstyle\mathcal{C}}$.




\




\item \textbf{Dispute Resolution}. \label{RCPoRP::Dispute-Resolution} $\mathtt{RCPoRP}. \mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}}, z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{q}^{\scriptscriptstyle *}},  T_{\scriptscriptstyle qp})$



The phase takes place only in  case of dispute, i.e. when $\mathcal C$ rejects service proofs or $\mathcal S$ rejects the queries. %or either party does not receive its counterparty's message on time. %A party who accepts all proofs does not need to get involved in this phase. 

\begin{enumerate}



\item The arbiter sets  counters: $y_{\scriptscriptstyle\mathcal C}, y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}$ and  $y'_{\scriptscriptstyle\mathcal S}$, that are initially set to $0$,  before time $\texttt{K}_{\scriptscriptstyle 1}$,  where $\texttt{K}_{\scriptscriptstyle 1}>\texttt{G}_{\scriptscriptstyle z,2}+\texttt{H}$. 

\item $\mathcal S$  sends ${m}_{\scriptscriptstyle\mathcal S}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter, at time $\texttt{K}_{\scriptscriptstyle 1}$.

\item The arbiter after receiving ${m}_{\scriptscriptstyle\mathcal S}$, does the following at time $\texttt{K}_{\scriptscriptstyle 2}$. 
\begin{enumerate}




\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by  sending it to SAP contract which  returns   $1$ or $0$. If the output is $0$, then it discards the server's complaint, $m_{\scriptscriptstyle\mathcal S}$, and does not take steps \ref{RCPoRP::check-v} and \ref{sc-check-server-claim}. Otherwise, it proceeds to the next step.



\item\label{RCPoRP::check-v} Removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ any element that is duplicated or is not in the range $[1,z]$. It also constructs an empty vector $ {\bm{v}}$.

\item\label{sc-check-server-claim}  For any element $i\in {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$:
\begin{itemize}

\item[$\bullet$] Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$   from SC, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$

%\item[$\bullet$] Fetches the related query, $\hat{k}_{\scriptscriptstyle i}\in \bm{q}$,   from SC 
\item[$\bullet$]Checks if  the query is well-formed, by calling $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle i}, pp)\rightarrow b_{\scriptscriptstyle i}$. If the query is rejected, i.e.  $b_{\scriptscriptstyle i}=0$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by $1$ and appends $i$ to $ {\bm{v}}$. Otherwise (if the query is accepted) it increments $y'_{\scriptscriptstyle\mathcal S}$  by $1$. 
\end{itemize}
Let $\texttt{K}_{\scriptscriptstyle 3}$ be the time the arbiter finishes the above checks.
\end{enumerate}





\item $\mathcal C$  sends $m_{\scriptscriptstyle\mathcal C}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter, at time $\texttt{K}_{\scriptscriptstyle 4}$




\item The arbiter after receiving $m_{\scriptscriptstyle\mathcal C}$, does the following, at time $\texttt{K}_{\scriptscriptstyle 5}$. 
\begin{enumerate}
\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by   sending $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. If the output is $0$, then it discards the client's complaint, ${m}_{\scriptscriptstyle\mathcal C}$, and does not take steps \ref{sc-checks-client-claim}-\ref{the-contract-loop}. Otherwise, it proceeds to the next step. 

 \item\label{sc-checks-client-claim} Ensures each vector   $ {\bm{m}}\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. In particular, it ensures there exist no two vectors: $ {\bm{m}}, {\bm{m}}'\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ such that $ {\bm{m}}[0]= {\bm{m}}'[0]$.  If such vectors  exist, it deletes the redundant ones from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$. This ensures no two claims refer to the same verification.  It removes any vector $ {\bm{m}}$ from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ if $ {\bm{m}}[0]$ is not in the range $[1,z]$ or if $ {\bm{m}}[0]\in  {\bm{v}}$. Note the latter check  (i.e. $ {\bm{m}}[0]\in  {\bm{v}}$) ensures $\mathcal C$ cannot hold $\mathcal S$ accountable if $\mathcal C$  generated an ill-formed query for the same verification.   



\item\label{the-contract-loop} For every  vector $ {\bm{m}}\in {\bm{m}}_{\scriptscriptstyle \mathcal{C}}$:
\begin{itemize}
\item[$\bullet$]  Retrieves details of a proof that was rejected in each $i$-th verification.  In particular, it sets   $i= {\bm{m}}[0]$ and $g= {\bm{m}}[1]$. Recall that $g$ refers to the index of a rejected proof in the proof vector which was generated for $i$-th verification, i.e. $ {\bm{\pi}}_{\scriptscriptstyle i}$ 


\item[$\bullet$] Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$   from SC, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$



\item[$\bullet$]  Removes the pads only from $g$-th padded encrypted proof. Let $ {\bm{\pi}}'_{\scriptscriptstyle i}[g]$ be the result. Next, it decrypts the  encrypted proof, $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle i}[g]))= {\bm{\pi}}_{\scriptscriptstyle i}[g]$

\item[$\bullet$] \label{dummy-vector} Constructs a fresh vector: $ {\bm{\pi}}''_{\scriptscriptstyle i}$, such that  its $g$-th element equals $ {\bm{\pi}}_{\scriptscriptstyle i}[g]$ (i.e. $ {\bm{\pi}}''_{\scriptscriptstyle i}[g]=  {\bm{\pi}}_{\scriptscriptstyle i}[g] \text{ and } | {\bm{\pi}}''_{\scriptscriptstyle i}|= | {\bm{\pi}}_{\scriptscriptstyle i}|$) and the rest of its elements are dummy values. 

\item[$\bullet$] Calls   $\mathtt{PoRID.identify}( {\bm{\pi}}''_{\scriptscriptstyle i},g,\hat{k}_{\scriptscriptstyle i},pp)\rightarrow I_{\scriptscriptstyle i}$. If $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$  by $1$. If  $I_{\scriptscriptstyle i}=\bot$, then it increments $y'_{\scriptscriptstyle\mathcal {C}}$ by $1$.
\end{itemize}

\end{enumerate}

\item The arbiter at time $\texttt{K}_{\scriptscriptstyle 6}$ sends $[y_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S}]$  to SC who accordingly overwrites the  elements it holds (i.e. elements of $\bm{y}$) by  the related vectors elements the arbiter sent. 

\end{enumerate} %%%%%%%%%

\

\item \textbf{Coin Transfer}. \label{RCPoRP::CoinTransfer} $\mathtt{RCPoRP}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})$
\begin{enumerate}


 \item If SC  receives  ``pay'' message  at time $\texttt{T}_{\scriptscriptstyle 2}$, where $a=0$ or $coins^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}<p_{\scriptscriptstyle\mathcal{S}}$, then it sends $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins to $\mathcal C$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$. Otherwise (i.e. they reach an agreement), they take the following step. 

\item Either $\mathcal C$ or $\mathcal S$ sends ``pay'' message and  statement $\ddot{x}_{\scriptscriptstyle cp}\in T_{\scriptscriptstyle cp}$ to SC at time $\texttt{L}>\texttt{K}_{\scriptscriptstyle 6}$
\item SC checks the validity of the statement by sending it  to SAP contract that  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$
\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$
\item[$\bullet$] $l(y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal C})$ coins to the arbiter. 



\end{itemize}

\end{enumerate}
\end{enumerate}


\begin{remark}
The reason in step \ref{dummy-vector} vector $ {\bm{\pi}}''_{\scriptscriptstyle i}$ is constructed  is to let SC make \emph{black-box}  use of $\mathtt{PoRID.identify}(.)$. Alternatively, SC could decrypt all proofs in $\mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle i})$ and pass them to $\mathtt{PoRID.identify}(.)$. However, this approach would impose a high cost, as all proofs have to be decrypted. 
\end{remark}

\begin{remark}
In general, a transaction that is sent   to a smart contract should  cover the cost of the contract's execution. Therefore, in the above protocol, if a party unnecessarily invokes a contract for an accepting proof, it has to pay the execution cost in advance. This is the reason the above protocol (unlike RC-S-P protocol) does not need to track the number of times a party unnecessarily invokes the contract.    
\end{remark}


\begin{remark} In the protocol, for the sake of simplicity, it is assumed that the cost imposed by a malicious client to the arbiter  (to resolve a dispute) is the same as the cost imposed by a malicious server. To relax the assumption, we can simply introduce another parameter $l'$.   
 We let $l$ and $l'$ be the amounts of coin a malicious client and malicious server must pay to the arbiter respectively. In this case, (a) in step \ref{RC-PoR-P::set-cp}, the client appends $l'$ to $cp$ and (b) in the coin transfer  phase, the amounts of coin each party receives would be as follow:    $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l'(y_{\scriptscriptstyle\mathcal S}+ y'_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$, and $l(y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})+l'(y_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal S})$ coins to the arbiter.
\end{remark}

%\textcolor{purple} {Explain how we can slight modify the protocol to capture the fact  that the amounts of coin the client pays for a dispute resolution is different to the amount paid by the server to resolve a dispute. The idea is we introduce another value $l'$, we let $l$ and $l'$ be the amount of coin the client and server pay to resolve a dispute.  We add $l'$ to $cp$. Accordingly, we would have $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l'\cdot y_{\scriptscriptstyle\mathcal S}-l\cdot y_{\scriptscriptstyle\mathcal C}$ coins  to $\mathcal C$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l\cdot y_{\scriptscriptstyle\mathcal C}-l'\cdot y_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$}
%


\subsubsection{Delegating the Arbiter's Role to  a Smart Contract}

In the above protocol, due to the efficiency of arbiter-side algorithm, i.e. $\mathtt{RCSPoR.resolve}(.)$,  we can  totally delegate the arbiter’s role to the smart contract, SC. In this case, the involvement of the third-party arbiter is not needed anymore.  However, to have the new variant of RC-PoR-P,   some adjustments need to be applied to the original RC-PoR-P’s protocol and definition, primarily from  two  perspectives. First,    the way a party pays to resolve a dispute would change that ultimately affects the amounts of coin each party receives at the coin distribution phase. Recall, in the RC-PoR-P and RC-S-P (presented in sections \ref{sec::RC-PoR-P-protocol} and \ref{sec::RC-S-P-protocol} respectively)  the party who raises dispute does not pay the arbiter when it sends to it a dispute query. Instead, loosely speaking, the arbiter at the coin distribution phase is paid by a misbehaving party. In contrast, when the arbiter’s role is played by a smart contract, the party who raises dispute and sends a dispute query to the contract (due to the nature of smart contracts' platform) has to pay the contract before the contract processes its query. This means, an honest party who sends a complaint to the contract needs to be compensated (by the corrupt party) for the amounts  of coin it sent to the contract to resolve the dispute. Therefore, the amounts of coin each party receives at the coin distribution phase would change, compare to the original RC-PoR-P protocol. Second, there would be no need to keep track of the number of times a party unnecessarily raises a dispute, as it pays the contract when it sends a query, before the contract processes its claim. In Appendix \ref{sec::RC-S-P-Definition2}, we provide a generic definition for RC-S-P for the case where the arbiter's role can be played by a smart contract. The generic definition also captures the new variant of RC-PoR-P. Moreover, in Appendix \ref{sec::R-PoR-P-protocol-Withohut-Arbiter}, we elaborate on how  the new variant of RC-PoR-P can be constructed and we prove its security.  

 



