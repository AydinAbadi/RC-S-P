% !TEX root =R-zkCSP.tex

\subsection{Recurring Contingent PoR Payment (RC-PoR-P) Protocol}\label{sec::RC-PoR-P-protocol}


%In this section, we present recurring contingent PoR payment (RC-PoR-P). Since proofs of  retrievability (PoR), whose definition was given in Section \ref{PoR-def}, is a concrete instantiation of the generic verifiable service, RC-PoR-P is a concrete instantiation of the generic recurring contingent service payment (RC-S-P), when the service is PoR. Nevertheless, RC-PoR-P offers  two primary added features. Specifically, unlike RC-S-P, it (a) does not use any zero-knowledge proofs (even though either client or server can still be  malicious) which significantly improves  costs, and (b)  the arbiter's dispute resolution cost is reduced; as we will show later, this also allows a smart contract efficiently plays the arbiter's role. In the following, first we  explain how the features are satisfied.
%
%\
%
%\noindent\textit{\textbf{Avoiding the Use of Zero-knowledge Proofs}}. In general, the majority of  PoR's are in the security model where a client is honest while the server is potentially malicious. They rely on metadata that is either a set of tags (e.g. MAC's or signatures) or a root of a Merkle tree,  constructed on  file blocks to ensure the file's availability. In the case where a client can  be malicious too,  if tags are used then using zero-knowledge proofs seem  an obvious choice, as it allows the client to ensure the server that the tags have been constructed correctly without leaking verification keys. However, this imposes significant computation and communication costs. We observed that using a Merkle tree would benefit our protocol from a couple of perspectives; in short, it removes the need for zero-knowledge proofs and it supports proof of misbehaviour. Our first observation is that if a Merkle tree is used to generate a metadata, then   there would be no need for the client to use zero-knowledge proofs to prove the correctness of the metadata to the server. Instead, the server can efficiently check the metadata's correctness, by reconstructing the Merkle tree on top of the file blocks. 
%
%\
%
%%\noindent\textit{\textbf{Efficiently Eliminating Arbiter's Involvement}}. 
%
%\noindent\textit{\textbf{Reducing Arbiter-side Cost}}.  As stated above, RC-PoR-P uses a Merkle tree-based PoR. In this case, each $j$-th proof contains a set of Merkle tree paths that are encoded and stored on a smart contract. For each verification, the client decoded and then verifies all paths. In a naive approach, when the client rejects the proof it raises a dispute and let the arbiter verify the proofs, i.e. \emph{all paths} in the proof \footnote{In a Merkle tree-based PoR, the number of proofs that are sent to a verifier for each verification is linear with the number of challenges, e.g. 460 challenges  to ensure 99\% of file blocks is retrievable. In contrast, in a tag-based PoR, in each verification, the verifier receives only a few proofs.}. However, we use the idea of proof of misbehaviour, put forth in \cite{}. In particular, in $j$-th verification, if the client detects invalid proofs, then  it  sends  details of only one invalid proof/path to the arbiter  who  decodes that single proof and checks its validity (as apposed to decoding and checking all proofs). This significantly reduces the arbiter computation cost. 



%\
%
%\
%
%To totally eliminate the involvement of a third-party arbiter, one could use the Merkle tree-based PoR in RC-S-P and let a smart contract play the arbiter's entire role. In this case, there will be two  naive approaches.  One approach is that for each verification, the client verifies the server's proofs\footnote{In a Merkle tree-based PoR, the number of proofs that are sent to a verifier for each verification is linear with the number of challenges, e.g. 460 challenges  to ensure 99\% of file blocks is retrievable. In contrast, in a tag-based PoR, in each verification, the verifier receives only a few proofs.} and if it rejects them, then it sends the proofs (after the private time bubble)  to the contract who verifies the proofs again. However, this requires the smart contract to verify \emph{all} proofs which imposes a high cost. Another approach is that for each verification, the server's proofs  are always checked only by the contract, without the client's involvement. But, this requires the contract to always perform the verification, even if both parties  behaved honestly, which imposes unnecessary hight computation cost too. To  achieve our goal, we use a Merkle tree-based PoR  and let the client  verify the server's proofs locally. However, we use the idea of proof of misbehaviour, put forth in \cite{}. In particular, if the client detects invalid proofs for each verification  it only sends one invalid proof to the contract  who  checks the validity of that single proof (as apposed to checking all proofs). Thus, this eliminates the involvement of the arbiter and has a much lower cost. 



In this section, we present RC-PoR-P,  a concrete instantiation of the generic RC-S-P.  Although RC-PoR-P and RC-S-P have some overlaps, they have many differences too. Therefore, we provide the protocol’s overview and its detailed description below.
At a high level the protocol works as follows. The client and server utilise SAP to provably agree on two private statements, one statement includes payment details, and another one specifies a secret key, $\bar{k}$, and a pad's details, that will be used to encode sensitive messages they send to the contract. Moreover, they  agree on public parameters such as the private time bubble's length (that is the total number of billing cycles: $z$, plus a waiting period, $\texttt{H}$) and a smart contract that specifies $z$ and the total amount of masked coins each party should deposit. They deploy the contract. Each party deposits its masked coins in the contract within a fixed time. If a party does not deposit enough coins on time, then the parties have a chance to withdraw their coins and terminate the contract after a certain time. 

To start using/providing the service, the client invokes $\mathtt{PoRID.setup}(.)$ to encode the file and generate  metadata and public parameters. It sends  encryption of the metadata and public parameters to the smart contract. Also, it  sends the encoded file to the server who decrypts them and using the encoded file checks their correctness by calling $\mathtt{PoRID.server}(.)$. If the server decides not to serve, it sends to the contract $0$ within a fixed time; in this case, the parties can withdraw their deposit and terminate the contract.  At the end of each billing cycle, the client generates a query, by calling $\mathtt{PoRID.genQuery(.)}$ and sends the query's encryption to the contract. In the same cycle, the server retrieves the query from the contract, decrypts and locally checks its correctness, by calling $\mathtt{PoRID.checkQuery(.)}$. If the query is rejected, the server locally stores the index of that billing cycle and generates  dummy PoR proofs. However, if the server accepts the query, it generates PoR proofs by calling $\mathtt{PoRID.prove(.)}$. Then, in either case, the server encrypts the proofs, pads them and sends the result to the contract. Next, the client removes the pads, decrypts the proofs and locally verifies them, by calling $\mathtt{PoRID.verify(.)}$. If the verification is passed, then the client knows the file is retrievable with a high probability. But, if the proof is rejected, then it locally stores the index of that billing cycle and details of one of the invalid proofs (in the same cycle). It  waits until the private time bubble passes and dispute resolution time arrives. 

During the dispute resolution period, in case the server rejects the query or the client rejects the PoR proofs, that party sends to the arbiter (a) details of invalid proofs and (b)  the statement that contains the decryption key and padding detail. The arbiter checks the validity of the statement first. If it accepts the statement, then it removes the pads and decrypts the values whose indices were provided by the parties. Then, the arbiter checks the party’s claim by calling $\mathtt{PoRID.checkQuery (.)}$ and $\mathtt{PoRID.identify (.)}$ if the server or client calls the contract respectively. The arbiter also keeps track of the number of times each party misbehaved.  After the arbiter processes the parties' claim, it tells to the contract how many times each party misbehaved.  In the next phase, to distribute the coins, either client or server sends to the contract: (a) “pay” message, (b) the agreed statement that specifies the payment details, and (c) the statement’s proof. The contract verifies the statement and if it is approved, then it distributes the coins according to the statement’s detail, and the number of times each party misbehaved. 



\begin{enumerate}
\item\label{RC-PoR-P::KeyGen} \textbf{Key Generation}. $\mathtt{RCPoRP}.\mathtt{keyGen}(1^{\scriptscriptstyle\lambda})$
\begin{enumerate}

\item  $\mathcal C$  picks a random secret key  $\bar{k}$ for a symmetric key encryption. It also sets  parameter $pad_{\scriptscriptstyle \pi}$ which is the number of  dummy values that will be used to pad encrypted proofs,  let $qp:=(pad_{\scriptscriptstyle \pi}, \bar{k})$. The key's size is part of the security parameter. Let  ${k}:=(sk',pk')$, where  $sk'=qp$ and $pk':=(adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\mathcal{S}})$. 




%\item  \textcolor{green}{$\mathcal C$ sets coin parameters as   follows,   $o$: the amount of coins for each accepting proof,  as well as $l$ and $l'$ which are the amount of coins $\mathcal C$ and $\mathcal S$ respectively need to send to a smart contract to resolve a potential dispute.  Let $k':=\{o,l,l',qp\}$. }


\end{enumerate}

\

\item \textbf{Client-side Initiation}. $\mathtt{RCPoRP}.\mathtt{cInit}(1^\lambda, u,{k}, z,pl)$
\begin{enumerate}

\item Calls $\mathtt{PoRID.setup}(1^{\lambda}, u)\rightarrow (u^{\scriptscriptstyle *},pp)$ to encode service input. It appends $pp$ to $qp$.


\item  Calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},qp )\rightarrow(r_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp}, adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}})$, to initiate an agreement (with $\mathcal{S}$) on $qp$.  Let $T_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp}, g_{\scriptscriptstyle qp})$ be proof/query encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}:=(qp,r_{\scriptscriptstyle qp})$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 


\item   Sets coin parameters (given  price list $pl$) as  follows,  $o$: the amount of coins for each accepting proof,  and $l$ the amount of coin $\mathcal C$  or $\mathcal S$ needs to send to a smart contract to resolve a potential dispute. 


%
%\item   Sets coin parameters (given  price list $pl$) as  follows,  $o$: the amount of coins for each accepting proof,  as well as $l$ and $l'$ which are the amount of coins $\mathcal C$ and $\mathcal S$ respectively need to send to a smart contract to resolve a potential dispute. 






\item  Sets  $cp:=(o,o_{\scriptscriptstyle max}, l,  l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. Then, $\mathcal C$ calls $\mathtt{SAP.init}(1^{\scriptscriptstyle\lambda}, adr_{\scriptscriptstyle\mathcal{C}}, adr_{\scriptscriptstyle\mathcal{S}},cp )\rightarrow(r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}})$, to initiate an agreement (with $\mathcal{S}$) on $cp$. Let $T_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}:=(cp,r_{\scriptscriptstyle cp})$ is the opening and $g_{\scriptscriptstyle cp}$ is the commitment stored on the contract as a result of executing   SAP.  





\item Set parameters  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $p_{\scriptscriptstyle\mathcal{S}}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal{S}}$ are   the total number of masked coins $\mathcal C$ and $\mathcal S$ should deposit respectively. It signs and deploys a smart contract, SC, that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$, $p_{\scriptscriptstyle\mathcal{S}}$,  $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 1}}$, and $adr_{\scriptscriptstyle\text{SAP}_{\scriptscriptstyle 2}}$. Let $adr_{\scriptscriptstyle \text{SC}}$ be the address of the deployed SC, and $T:=\{T_{\scriptscriptstyle qp},T_{\scriptscriptstyle cp}\}$. It sets a set of time points/windows, $\texttt{Time}:\{ \texttt{T}_{\scriptscriptstyle 0},..., \texttt{T}_{\scriptscriptstyle 3},\texttt{G}_{\scriptscriptstyle 1,1},...,\texttt{G}_{\scriptscriptstyle z,2},\texttt{H}, \texttt{K}_{\scriptscriptstyle 1},...,\texttt{K}_{\scriptscriptstyle 6}, \texttt{L}\}$, that are explicitly specified in SC who will accept a certain party's message only in a specified  time point/window. Time allocations will become clear in the next phases. 


\item\label{setcounters} Sets four counters $[y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal S}]$ in the contract, where their initial value is $0$. Let $\bm{y}: [y_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal S},\texttt{Time},adr_{\scriptscriptstyle \text{SC}}]$

\item Deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract. It  sends $u^{\scriptscriptstyle *}, e, \ddot{x}_{\scriptscriptstyle qp},\ddot{x}_{\scriptscriptstyle cp}$, and $p_{\scriptscriptstyle\mathcal{S}}$ (along with $adr_{\scriptscriptstyle \text{SC}}$) to $\mathcal S$. It also sends  $pk'$ to SC. Let $\texttt{T}_{\scriptscriptstyle 0}$ be the time that the above process finishes. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\textcolor{red}{
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $qp$, $\mathcal C$ sends $qp$ to  $\mathcal S$.  Next (if the $\mathcal S$ agrees on the parameters) they take the steps in the Setup and Agreement phases in the SAP, at time $T_{\scriptscriptstyle 0}$. Let $t_{\scriptscriptstyle qp}:=(\ddot{x}_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp})$ be proof encoding token,  where  $\ddot{x}_{\scriptscriptstyle qp}$ is the opening and $g_{\scriptscriptstyle qp}$ is the commitment stored on the contract as a result of running   SAP. 
%\item Let  $cp:=(o,o_{\scriptscriptstyle max},l,l',l_{\scriptscriptstyle max},z)$, where $o_{\scriptscriptstyle max}$ is the maximum amount of coins  for an accepting service proof,  $l_{\scriptscriptstyle max}$  is the maximum amount of coins to resolve a potential dispute, and $z$ is the number of  service proofs/verifications. For $\mathcal C$ and $\mathcal S$ to provably agree on $cp$, similar to the previous step, they invoke SAP, at time $T_{\scriptscriptstyle 1}$.  Let $t_{\scriptscriptstyle cp}:=(\ddot{x}_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp})$ be coin encoding token,  where  $\ddot{x}_{\scriptscriptstyle cp}$ is the opening and $g_{\scriptscriptstyle cp}$ is the commitment stored on the contract as a result of executing the  SAP. 
%\item $\mathcal C$ sets   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}=z\cdot (o_{\scriptscriptstyle max}+l_{\scriptscriptstyle max})$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=z\cdot l_{\scriptscriptstyle max}$, where $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ are   the total number of masked coins that $\mathcal C$ and $\mathcal S$ should deposit respectively. $\mathcal C$ signs and deploys  a smart contract, SC, that explicitly specifies  parameters $z$,  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$. It deposits $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins in the contract.}
%\textcolor{green}{\item $\mathcal C$ constructs  vector $\bm{w}_{\scriptscriptstyle\mathcal C}$, also $\mathcal S$  constructs $\bm{v}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty. }
%
%\item\textcolor{red}{ $\mathcal C$ runs $\mathtt{PoRID.setup}(1^{\lambda}, u)\rightarrow (u^{\scriptscriptstyle *},pp)$.  It sends  encoded file $u^{\scriptscriptstyle *}$ to $\mathcal S$, and sends the public key's encryption: $\mathtt{Enc}(\bar{k},pk)$ to SC at time $T_{\scriptscriptstyle 2}$
%\item $\mathcal S$ checks the above parameters, and ensures sufficient amount of coins has been deposited.  If any check is rejected, then it sets $a=0$. Otherwise, it decrypts the public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$. It runs $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *},pp)\rightarrow a$. Next, it sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to SC at time $T_{\scriptscriptstyle 3}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$
%\item $\mathcal C$  and  $\mathcal S$ can withdraw their coins at time $T_{\scriptscriptstyle 4}$, if the server sends $a=0$, fewer coins than $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$, or nothing to the SC
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%
%\item $\mathcal C$ constructs  vector  $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$ and $\mathcal S$  constructs $ {\bm{v}}_{\scriptscriptstyle\mathcal S}$,  where the vectors are initially empty.   
%
%\item $\mathcal C$ and $\mathcal S$ agree on the following parameters, $z$: the number of the service proofs/verifications, $o$: the amount of coins for each accepting proof, $l$ and $l'$ which are the amount of coins $\mathcal C$ and $\mathcal S$ respectively need to send to a smart contract to resolve a dispute. Furthermore, they agree on $f_{\scriptscriptstyle\mathcal C}$ and $f_{\scriptscriptstyle\mathcal S}$ that are the amount of masking coins $\mathcal C$ and $\mathcal S$ will use respectively. 


%where $l_{\scriptscriptstyle\mathcal C}$ and $l_{\scriptscriptstyle\mathcal S}$ cover the costs of a light verification of the client's and server's inputs respectively, while $l'_{\scriptscriptstyle\mathcal S}$ covers the cost of a more involved verification of the server's input.  

%\item $\mathcal C$ and $\mathcal S$ construct  a statement of the  form: $x=(o,l,l', f_{\scriptscriptstyle\mathcal C},f_{\scriptscriptstyle\mathcal S},z)$   
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x$, they take the steps in the Setup and Agreement phases in the SAP, at time $T_0$. Let $\mu$ be the statement's proof. 
%


%\item $\mathcal S$ picks and sends to $\mathcal C$ a random key, $\bar{k}$

%\item  $\mathcal C$ sends to $\mathcal S$ a statement of the form $x'=({pad},\bar{k})$ where  ${pad}$  specifies the number of  dummy values that will be used to pad encrypted proofs and    $\bar{k}$ is a  secret key.
%
%
%
%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $x'$, they take the steps in the Setup and Agreement phases in the SAP again, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 



%\item For $\mathcal C$ and $\mathcal S$ to provably agree on $\bar{k}$, they take the steps in the Setup and Agreement phases in the SAP again, at time $T_{\scriptscriptstyle 1}$. Let $\mu'$ be the proof. 

%
%\item $\mathcal C$ and $\mathcal S$ agree on a smart contract: SC. Let $p_{\scriptscriptstyle\mathcal C}=z(o+l')+f_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}=zl+f_{\scriptscriptstyle\mathcal S}$ be the total number of coins the client and server should deposit respectively. SC  explicitly specifies  parameters $z$, $p_{\scriptscriptstyle\mathcal C}$ and $p_{\scriptscriptstyle\mathcal S}$. They sign and deploy the contract. 
%
%\item $\mathcal C$ and $\mathcal S$ deposit their masked coins in SC at time $T_{\scriptscriptstyle 2}$
%\item At time $T_{\scriptscriptstyle 3}$, if the deposit amount that either party has put is less than the amount stated in SC, then SC allows each party to withdraw its
%coins and terminate the contract.
%
%
%
%\item $\mathcal S$ decrypts the public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$. Next, it runs $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *},pk)\rightarrow a$ and then sends $a$  to SC at time $T_{\scriptscriptstyle 4}$
%
%\item $\mathcal C$ and $\mathcal S$ can withdraw their coins at time $T_{\scriptscriptstyle 5}$, if the server sends $a=0$ or nothing to the SC 

\end{enumerate}

\
\item \textbf{Server-side Initiation}\label{RCPoRP::Server-side-Initiation}. $\mathtt{RCPoRP}.\mathtt{sInit}(u^{\scriptscriptstyle *},  z, T, p_{\scriptscriptstyle\mathcal{S}} ,\bm{y})$

\begin{enumerate}

\item Checks the parameters  in $T$ (e.g. $qp$ and $cp$) and  in SC (e.g. $p_{\scriptscriptstyle\mathcal{S}}, \bm{y}$) and ensures sufficient amount of coins has been deposited by $\mathcal C$.  

\item Calls $\mathtt{SAP.agree}(qp,r_{\scriptscriptstyle qp},g_{\scriptscriptstyle qp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{1}})\rightarrow (g'_{\scriptscriptstyle qp},b_{\scriptscriptstyle 1})$ and $\mathtt{SAP.agree}(cp,r_{\scriptscriptstyle cp},g_{\scriptscriptstyle cp},adr_{\scriptscriptstyle\mathcal{C}},adr_{\scriptscriptstyle\text{SAP}_{2}})\rightarrow (g'_{\scriptscriptstyle cp},b_{\scriptscriptstyle 2})$, to verify the correctness of tokens in $T$ and to agree on the tokens' parameters, where $qp,r_{\scriptscriptstyle qp}\in \ddot{x}_{\scriptscriptstyle qp}, \text{and }  cp,r_{\scriptscriptstyle cp} \in  \ddot{x}_{\scriptscriptstyle cp}$. Recall, if both $\mathcal{C}$ and $\mathcal{S}$ are honest, then $g_{\scriptscriptstyle qp}=g'_{\scriptscriptstyle qp}$ and $g_{\scriptscriptstyle cp}=g'_{\scriptscriptstyle cp}$. 




\item If any above check is rejected, then it sets $a=0$. Otherwise, it  calls $\mathtt{PoRID.serve}(u^{\scriptscriptstyle *}, {pp})\rightarrow a$. 

\item Sends $a$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=p_{\scriptscriptstyle\mathcal{S}}$ coins to SC at time $\texttt{T}_{\scriptscriptstyle 1}$, where  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}=\bot$ if $a=0$
\end{enumerate}
Note, $\mathcal S$  and  $\mathcal C$ can withdraw their coins at time $\texttt{T}_{\scriptscriptstyle 2}$, if  $\mathcal S$ sends $a=0$, fewer coins than $p_{\scriptscriptstyle\mathcal{S}}$, or nothing to the SC. To withdraw, $\mathcal S$  or  $\mathcal C$  simply sends a ``pay'' message to $\mathtt{RCPoRP}.\mathtt{pay}(.)$ algorithm only at time $\texttt{T}_{\scriptscriptstyle 2}$.

\





%\item \textbf{Billing-cycles}. At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 

\textbf{\textit{Billing-cycles Onset}}. $\mathcal{C}$ and $\mathcal{S}$ engage in the following three phases, i.e. phase \ref{Billing-cycles-genQuery}-\ref{Client-sideProofVerification},  at the end of every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $\texttt{G}_{\scriptscriptstyle j,1}$ and $\texttt{G}_{\scriptscriptstyle j,2}$, where $\texttt{G}_{\scriptscriptstyle j,2}>\texttt{G}_{\scriptscriptstyle j,1}$, and $\texttt{G}_{\scriptscriptstyle 1,1}>\texttt{T}_{\scriptscriptstyle 2}$ 


\

\item\textbf{Client-side Query Generation}.\label{Billing-cycles-genQuery} $\mathtt{RCPoRP}.\mathtt{genQuery}(1^\lambda,  T_{\scriptscriptstyle qp})$

\begin{enumerate}

\item Calls $\mathtt{PoRID.genQuery}(1^{\lambda},  pp)\rightarrow \hat{k}_{\scriptscriptstyle j}$ to generate a query, where  $ pp\in T_{\scriptscriptstyle qp}$


\item Sends encrypted query  $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}=\mathtt{Enc}(\bar{k},\hat{k}_{\scriptscriptstyle j})$ to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$

%\item Sends   $\hat{k}_{\scriptscriptstyle j}$ to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$


%\item Calls $\mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q, \textcolor{purple}{pp})\rightarrow c_{\scriptscriptstyle j}:=(\bm{q}_{\scriptscriptstyle j},\bm{w}_{\scriptscriptstyle q_{_{\scaleto{j}{\size}}}})$, to generate a query-proof pair. 
%\item Encrypts the pair, $\mathtt{Enc}(\bar{k},c_{\scriptscriptstyle j})=c'_{\scriptscriptstyle j}$, where $\bar{k}\in T_{\scriptscriptstyle qp}$. Then, it pads (each element of) the result with ${pad}_{\scriptscriptstyle q}\in T_{\scriptscriptstyle qp}$ random values that are picked from the encryption's output range, $U$. Let $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. 
%\item Sends the padded encrypted query-proof pair, $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$
\end{enumerate}

\

\item\textbf{Server-side Proof Generation}. $\mathtt{RCPoRP}.\mathtt{prove}(u^{\scriptscriptstyle *},  \hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j}, T_{\scriptscriptstyle qp})$


\begin{enumerate}

\item Constructs an empty  vector, $\bm{m}_{\scriptscriptstyle\mathcal S}=\bot$, if $j=1$.  

\item Decrypts the query, $\hat{k}_{\scriptscriptstyle j}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle j})$

\item Calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pp)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness.

\begin{itemize}
\item[$\bullet$] If it accepts the query, then it calls $\mathtt{PoRID.prove}(u^{\scriptscriptstyle *},\hat{k}_{\scriptscriptstyle j},pp)\rightarrow  {\bm{\pi}}_{\scriptscriptstyle j}$, to generate a PoR  proof. In this case,  $\mathcal S$ encrypts every  proof in the proof vector, i.e. $\forall g, 1\leq g\leq| {\bm{\pi}}_{\scriptscriptstyle j}|: \mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle j}[g])= {\bm{\pi}}'_{\scriptscriptstyle j}[g]$, where $\bar{k}\in T_{\scriptscriptstyle qp}$. Let vector $ {\bm{\pi}}'_{\scriptscriptstyle j}$ contain the encryption of all proofs. It pads every encrypted proof in $ {\bm{\pi}}'_{\scriptscriptstyle j}$ with ${pad}_{\scriptscriptstyle \pi}\in T_{\scriptscriptstyle qp}$ random values that are picked from the encryption's output range $U$, (by appending the random values to the encrypted proofs vector). Let $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. It sends the padded encrypted proofs  to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ 
\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{m}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $ {\bm{\pi}}'_{\scriptscriptstyle j}$ whose elements are randomly picked from $U$,  pads the result as above, and sends the result, $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$

\end{itemize}


%
%\item Removes the pads from $c^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, using  parameters of $T_{\scriptscriptstyle qp}$. Let  $c'_{\scriptscriptstyle j}$ be the result. Next, it  decrypts  the result, $\mathtt{Dec(}\bar{k},c'_{\scriptscriptstyle j})=c_{\scriptscriptstyle j}$. Then,  it   runs $\mathtt{VSID.checkQuery}(c_{\scriptscriptstyle j}, pk, \textcolor{purple}{pp})\rightarrow b_{\scriptscriptstyle j}$, to check the correctness of the queries.

%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$. % or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.



%\item  $\mathcal S$ appends $j$  to $\vv{\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$, or were not posted on time. In this case, it does not proceed to the next step for this $j$-th verification.

%\begin{itemize}
%\item[$\bullet$] If $\mathcal S$ accepts the query, i.e. $b_{\scriptscriptstyle j}=1$, then  calls $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c_{\scriptscriptstyle j},pk,\textcolor{purple}{pp})\rightarrow \pi_{\scriptscriptstyle j}$, to generate the service proof. In this case, $\mathcal S$ encrypts it, $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})=\pi'_{\scriptscriptstyle j}$. Next, it   pads (every element of) the encrypted proof with ${pad}_{\scriptscriptstyle \pi}\in T_{\scriptscriptstyle qp}$ random values  picked from $U$. Let $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}$ be the result. It sends the padded encrypted proof  to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ 
%
%\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends  $j$  to $\bm{m}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $\pi'_{\scriptscriptstyle j}\in U$,  pads the result as above, and sends the padded dummy proof, $\pi^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, to SC at time $\texttt{G}_{\scriptscriptstyle j,2}$ %, if the above proofs are rejected, i.e. $b_{\scriptscriptstyle j}=0$.
%\end{itemize}
When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, it sets    $m_{\scriptscriptstyle\mathcal S}:=\bm{m}_{\scriptscriptstyle\mathcal{S}}$.

\end{enumerate}













%\item \textbf{Billing-cycles}. The parties do the following, at the end of  every $j$-th billing cycle, where $1\leq j\leq z$. Each $j$-th cycle includes two  time points, $\texttt{G}_{\scriptscriptstyle j,1}$ and $\texttt{G}_{\scriptscriptstyle j,2}$, where $\texttt{G}_{\scriptscriptstyle j,2}>\texttt{G}_{\scriptscriptstyle j,1}$, and $\texttt{G}_{\scriptscriptstyle 1,1}>\texttt{T}_{\scriptscriptstyle 2}$ 

%At each time $G_{\scriptscriptstyle j}$, (where $1\leq j\leq z$ and $G_{\scriptscriptstyle 1}>T_{\scriptscriptstyle 5}$), that a proof is generated, the parties perform as follows. 



%\item $\mathcal C$ calls $\mathtt{PoRID.genQuery}(1^{\lambda},  pp)\rightarrow \hat{k}_{\scriptscriptstyle j}$, to generate a query. It sends   $\hat{k}_{\scriptscriptstyle j}$ to SC at time $\texttt{G}_{\scriptscriptstyle j,1}$

%\item $\mathcal S$  appends $j$ to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$, if the client's query was not posted on time. In this case, it does not take the next steps, for  $j$-th verification. 


%\item If $\mathcal S$ accepts the query, i.e. $b_{\scriptscriptstyle j}=1$, then it calls $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c_{\scriptscriptstyle j},pk)\rightarrow \pi_{\scriptscriptstyle j}$, to generate the service proof. In this case, $\mathcal S$ encrypts the proof, $\mathtt{Enc}(\bar{k},\pi_{\scriptscriptstyle j})=\pi'_{\scriptscriptstyle j}$. Next, it   pads the encrypted proof with ${pad}_{\scriptscriptstyle 2}$ random values that are picked from $U$. It sends the padded encrypted proof  to SC at time $G_{\scriptscriptstyle j,2}$. Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $\pi'_{\scriptscriptstyle j}\in U$,  pads the result as above, and sends the padded dummy proof to SC at time $G_{\scriptscriptstyle j,2}$.


%\item $\mathcal S$ decrypts the query,  $\mathtt{Dec(}\bar{k},\mathtt{Enc}(\bar{k},\hat{k}_{\scriptscriptstyle j}))=\hat{k}_{\scriptscriptstyle j}$.   Then, it calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pk)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness. 

%\begin{enumerate}
%\item $\mathcal S$ calls $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle j}, pp)\rightarrow b_{\scriptscriptstyle j}$ to check the query's correctness. 
%
%\begin{itemize}
%\item[$\bullet$] If it accepts the query, then it calls $\mathtt{PoRID.prove}(u^{\scriptscriptstyle *},\hat{k}_{\scriptscriptstyle j},pp)\rightarrow  {\bm{\pi}}_{\scriptscriptstyle j}$, to generate a PoR  proof. In this case,  $\mathcal S$ encrypts every  proof in the proof vector, i.e. $\forall g, 1\leq g\leq| {\bm{\pi}}_{\scriptscriptstyle j}|: \mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle j}[g])= {\bm{\pi}}'_{\scriptscriptstyle j}[g]$. Let vector $ {\bm{\pi}}'_{\scriptscriptstyle j}$ contain the encryption of all proofs. It pads every encrypted proof in $ {\bm{\pi}}'_{\scriptscriptstyle j}$ with $pad_{\scriptscriptstyle \pi}$ random values that are picked from the encryption's output range $U$, (by appending the random values to the encrypted proofs vector). It sends the padded encrypted proofs  to SC at time $G_{\scriptscriptstyle j,2}$ 
%\item[$\bullet$] Otherwise (if $\mathcal S$ rejects the query), it appends $j$  to $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$,  constructs a dummy proof $ {\bm{\pi}}'_{\scriptscriptstyle j}$ whose elements are randomly picked from $U$,  pads the result as above, and sends the padded dummy proof to SC at time $G_{\scriptscriptstyle j,2}$
%
%\end{itemize}

%\textcolor{green}{When $j=z$  and $\bm{v}_{\scriptscriptstyle\mathcal{S}}\neq\bot$, $\mathcal S$ sets    $\bm{m}_{\scriptscriptstyle\mathcal S}:[\bm{v}_{\scriptscriptstyle\mathcal{S}},\ddot{x}_{\scriptscriptstyle qp}, \text{``dispute''}]$.}


\


\item \textbf{Client-side Proof Verification}.\label{Client-sideProofVerification} $\mathtt{RCPoRP}.\mathtt{verify}(\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}, \hat{k}_{\scriptscriptstyle j},T_{\scriptscriptstyle qp})$
\begin{enumerate}


\item Constructs an empty vector, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$, if $j=1$. 

\item Removes the pads from $\bm{\pi}^{\scriptscriptstyle *}_{\scriptscriptstyle j}$, utilising  parameters of $T_{\scriptscriptstyle qp}$. Let $\bm{\pi}'_{\scriptscriptstyle j}$ be the result. It decrypts the service proofs $\mathtt{Dec}(\bar{k},\bm{\pi}'_{\scriptscriptstyle j})=\bm{\pi}_{\scriptscriptstyle j}$ and then calls $\mathtt{PoRID.verify}(\bm{\pi}_{\scriptscriptstyle j}, \hat{k}_{\scriptscriptstyle j}, {pp})\rightarrow \bm{d}_{\scriptscriptstyle j}$, to verify the proof.  

\begin{itemize}
\item[$\bullet$] If $ {\bm{\pi}}_{\scriptscriptstyle j}$ passes the verification, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=1$, then $\mathcal C$  concludes that the service for this verification has been delivered successfully.  


\item[$\bullet$] Otherwise (if proof $ {\bm{\pi}}_{\scriptscriptstyle j}$ is rejected, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=0$),  it sets $g= {\bm{d}}_{\scriptscriptstyle j}[1]$ and appends vector $[j,g]$  to $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$. Recall, $ {\bm{d}}_{\scriptscriptstyle j}[1]$ refers to a rejected proof's index in proof vector $ {\bm{\pi}}_{\scriptscriptstyle j}$. 

\end{itemize}
\end{enumerate}
When $j=z$  and $\bm{m}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    ${m}_{\scriptscriptstyle\mathcal C}:=\bm{m}_{\scriptscriptstyle\mathcal{C}}$.


%\item  $\mathcal C$ appends $j$ to $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$, if  $\mathcal S$ does not post the proof on time. In this case, it does not take the next steps, for  $j$-th verification. 


%In this phase,  $\mathcal C$ verifies the service proof. It first constructs two empty vectors, $\bm{m}_{\scriptscriptstyle\mathcal C}=\bot$ and $\bm{w}_{\scriptscriptstyle\mathcal{C}}=\bot$. Next, it removes the pads from the padded encrypted proofs and then
% decrypts the encrypted proofs: $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle j})= {\bm{\pi}}_{\scriptscriptstyle j}$. Then, it   calls $\mathtt{PoRID.verify}( {\bm{\pi}}_{\scriptscriptstyle j},\hat{k}_{\scriptscriptstyle j},pp)\rightarrow  {\bm{d}}_{\scriptscriptstyle j}$, to verify them. If $ {\bm{\pi}}_{\scriptscriptstyle j}$ passes the verification, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=1$, then $\mathcal C$  concludes that the service for this verification has been delivered successfully. Otherwise (if proof $ {\bm{\pi}}_{\scriptscriptstyle j}$ is rejected, i.e. $ {\bm{d}}_{\scriptscriptstyle j}[0]=0$), then it sets $g= {\bm{d}}_{\scriptscriptstyle j}[1]$ and appends vector $[j,g]$  to $ {\bm{w}}_{\scriptscriptstyle\mathcal{C}}$. Recall, $ {\bm{d}}_{\scriptscriptstyle j}[1]$ refers to a rejected proof's index in proof vector $ {\bm{\pi}}_{\scriptscriptstyle j}$. 
 
 
 %\textcolor{green}{If $j=z$  and $\bm{w}_{\scriptscriptstyle\mathcal{C}}\neq\bot$, $\mathcal C$ sets    $\bm{m}_{\scriptscriptstyle\mathcal C}:[\bm{w}_{\scriptscriptstyle\mathcal{C}},\ddot{x}_{\scriptscriptstyle qp}, \text{``dispute''}]$.}
  

%\end{enumerate}

\

% \textbf{Dispute Resolution}.\label{RCSP::Dispute-Resolution} $\mathtt{RCSP}.\mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}}, z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{c}}^{\scriptscriptstyle *}, pk, T_{\scriptscriptstyle qp},enc)$


\item \textbf{Dispute Resolution}. \label{RCPoRP::Dispute-Resolution} $\mathtt{RCPoRP}. \mathtt{resolve}(m_{\scriptscriptstyle \mathcal{C}},m_{\scriptscriptstyle \mathcal{S}}, z, {\bm{\pi}}^{\scriptscriptstyle *}, {\bm{q}^{\scriptscriptstyle *}},  T_{\scriptscriptstyle qp})$



The phase takes place only in  case of dispute, i.e. when $\mathcal C$ rejects service proofs or $\mathcal S$ rejects the queries. %or either party does not receive its counterparty's message on time. %A party who accepts all proofs does not need to get involved in this phase. 

\begin{enumerate}

%\item $\mathcal C$  at time $K_{\scriptscriptstyle 1}>G_{\scriptscriptstyle z,2}+H$ sends ``dispute'' message to SC 

%\item $\mathcal S$ sends $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ to SC, at time $K_{\scriptscriptstyle 2}$ 


%\item SC  ensures $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ is well-formed. In particular, it removes from  $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ duplicated elements or  elements that are not in the range $[1,z]$. SC for every  element $i\in  {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ checks if $\mathcal C$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery};  if the client did not do so, then it appends $i$ to $ {\bm{v}}_{\scriptscriptstyle{SC}}$ and   increments $u_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal C}$ by $1$
 
 
 % and retakes step \ref{the-arbiter-loop} with the next element of $ {\bm{v}}$. Otherwise, it proceeds to the next step. 

\item The arbiter sets  counters: $y_{\scriptscriptstyle\mathcal C}, y'_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S}$ and  $y'_{\scriptscriptstyle\mathcal S}$, that are initially set to $0$,  before time $\texttt{K}_{\scriptscriptstyle 1}$,  where $\texttt{K}_{\scriptscriptstyle 1}>\texttt{G}_{\scriptscriptstyle z,2}+\texttt{H}$. 

\item $\mathcal S$  sends ${m}_{\scriptscriptstyle\mathcal S}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter, at time $\texttt{K}_{\scriptscriptstyle 1}$.

\item The arbiter after receiving ${m}_{\scriptscriptstyle\mathcal S}$, does the following at time $\texttt{K}_{\scriptscriptstyle 2}$. 
\begin{enumerate}

%\item Sets two  counters: $y_{\scriptscriptstyle\mathcal C}$ and $y_{\scriptscriptstyle\mathcal S}$  that are initially set to $0$. Also,


\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by  sending it to SAP contract which  returns   $1$ or $0$. If the output is $0$, then it discards the server's complaint, $m_{\scriptscriptstyle\mathcal S}$, and does not take steps \ref{RCPoRP::check-v} and \ref{sc-check-server-claim}. Otherwise, it proceeds to the next step.

%\item\label{sc-dec-server-key} Uses secret key $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$

\item\label{RCPoRP::check-v} Removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$ any element that is duplicated or is not in the range $[1,z]$. It also constructs an empty vector $ {\bm{v}}$.

\item\label{sc-check-server-claim}  For any element $i\in {\bm{v}}_{\scriptscriptstyle\mathcal{S}}$:
\begin{itemize}

\item[$\bullet$] Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$   from SC, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$

%\item[$\bullet$] Fetches the related query, $\hat{k}_{\scriptscriptstyle i}\in \bm{q}$,   from SC 
\item[$\bullet$]Checks if  the query is well-formed, by calling $\mathtt{PoRID.checkQuery}(\hat{k}_{\scriptscriptstyle i}, pp)\rightarrow b_{\scriptscriptstyle i}$. If the query is rejected, i.e.  $b_{\scriptscriptstyle i}=0$, then it increments $y_{\scriptscriptstyle\mathcal C}$ by $1$ and appends $i$ to $ {\bm{v}}$. Otherwise (if the query is accepted) it increments $y'_{\scriptscriptstyle\mathcal S}$  by $1$. 
\end{itemize}
Let $\texttt{K}_{\scriptscriptstyle 3}$ be the time the arbiter finishes the above checks.
\end{enumerate}





\item $\mathcal C$  sends $m_{\scriptscriptstyle\mathcal C}$ and $\ddot{x}_{\scriptscriptstyle qp}$ to the arbiter, at time $\texttt{K}_{\scriptscriptstyle 4}$
 %Also,  $\mathcal S$ sends $m_{\scriptscriptstyle\mathcal S}:( {\bm{v}}_{\scriptscriptstyle\mathcal{S}},\bar{k},\mu')$ to SC %,   where $| {\bm{v}}_{\scriptscriptstyle\mathcal{C}}|\neq 0$ and $| {\bm{v}}_{\scriptscriptstyle\mathcal{S}}|\neq 0$. 

%\item\label{check-client-claim} SC  ensures $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. Specifically, it  removes from  $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ any element that is duplicated, or   not in the range $[1,z]$.  Also, it removes from $ {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ the elements that are in $ {\bm{v}}_{\scriptscriptstyle{SC}}$. Next, SC  for every  element $i\in  {\bm{v}}_{\scriptscriptstyle\mathcal{C}}$ checks if $\mathcal S$  sent to SC an encrypted query on time, in step \ref{Billing-cycles-genQuery} and increments $u_{\scriptscriptstyle\mathcal S}$ and $y_{\scriptscriptstyle\mathcal S}$ by $1$  if the server did not do that.  It appends those $i$'s that pass the check to $ {\bm{v}}'_{\scriptscriptstyle{SC}}$. Note, $ {\bm{v}}'_{\scriptscriptstyle{SC}}$ contains the indices of verifications whose PoR proofs  were rejected by the client.


\item The arbiter after receiving $m_{\scriptscriptstyle\mathcal C}$, does the following, at time $\texttt{K}_{\scriptscriptstyle 5}$. 
\begin{enumerate}
\item Checks the validity of  statement $\ddot{x}_{\scriptscriptstyle qp}$, by   sending $\ddot{x}_{\scriptscriptstyle qp}$ to SAP contract which  returns  either $1$ or $0$. If the output is $0$, then it discards the client's complaint, ${m}_{\scriptscriptstyle\mathcal C}$, and does not take steps \ref{sc-checks-client-claim}-\ref{the-contract-loop}. Otherwise, it proceeds to the next step. 

 \item\label{sc-checks-client-claim} Ensures each vector   $ {\bm{m}}\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ is well-formed. In particular, it ensures there exist no two vectors: $ {\bm{m}}, {\bm{m}}'\in  {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ such that $ {\bm{m}}[0]= {\bm{m}}'[0]$.  If such vectors  exist, it deletes the redundant ones from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$. This ensures no two claims refer to the same verification.  It removes any vector $ {\bm{m}}$ from $ {\bm{m}}_{\scriptscriptstyle\mathcal{C}}$ if $ {\bm{m}}[0]$ is not in the range $[1,z]$ or if $ {\bm{m}}[0]\in  {\bm{v}}$. Note the latter check  (i.e. $ {\bm{m}}[0]\in  {\bm{v}}$) ensures $\mathcal C$ cannot hold $\mathcal S$ accountable if $\mathcal C$  generated an ill-formed query for the same verification.   

%\item Uses secret key $\bar{k}\in \ddot{x}_{\scriptscriptstyle qp}$ to decrypt the encrypted public key, $\mathtt{Dec}(\bar{k},\mathtt{Enc}(\bar{k},pk))=pk$

\item\label{the-contract-loop} For every  vector $ {\bm{m}}\in {\bm{m}}_{\scriptscriptstyle \mathcal{C}}$:
\begin{itemize}
\item[$\bullet$]  Retrieves details of a proof that was rejected in each $i$-th verification.  In particular, it sets   $i= {\bm{m}}[0]$ and $g= {\bm{m}}[1]$. Recall that $g$ refers to the index of a rejected proof in the proof vector which was generated for $i$-th verification, i.e. $ {\bm{\pi}}_{\scriptscriptstyle i}$ 


\item[$\bullet$] Fetches the related encrypted query $\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i}\in \bm{q}^{\scriptscriptstyle *}$   from SC, and   decrypts it, $\hat{k}_{\scriptscriptstyle i}=\mathtt{Dec}(\bar{k},\hat{k}^{\scriptscriptstyle *}_{\scriptscriptstyle i})$

%\item[$\bullet$]  Fetches the related  query, $\hat{k}_{\scriptscriptstyle i}$, from SC.

\item[$\bullet$]  Removes the pads only from $g$-th padded encrypted proof. Let $ {\bm{\pi}}'_{\scriptscriptstyle i}[g]$ be the result. Next, it decrypts the  encrypted proof, $\mathtt{Dec}(\bar{k}, {\bm{\pi}}'_{\scriptscriptstyle i}[g]))= {\bm{\pi}}_{\scriptscriptstyle i}[g]$

\item[$\bullet$] \label{dummy-vector} Constructs a fresh vector: $ {\bm{\pi}}''_{\scriptscriptstyle i}$, such that  its $g$-th element equals $ {\bm{\pi}}_{\scriptscriptstyle i}[g]$ (i.e. $ {\bm{\pi}}''_{\scriptscriptstyle i}[g]=  {\bm{\pi}}_{\scriptscriptstyle i}[g] \text{ and } | {\bm{\pi}}''_{\scriptscriptstyle i}|= | {\bm{\pi}}_{\scriptscriptstyle i}|$) and the rest of its elements are dummy values. 

\item[$\bullet$] Calls   $\mathtt{PoRID.identify}( {\bm{\pi}}''_{\scriptscriptstyle i},g,\hat{k}_{\scriptscriptstyle i},pp)\rightarrow I_{\scriptscriptstyle i}$. If $I_{\scriptscriptstyle i}=\mathcal S$, then it increments $y_{\scriptscriptstyle\mathcal S}$  by $1$. If  $I_{\scriptscriptstyle i}=\bot$, then it increments $y'_{\scriptscriptstyle\mathcal {C}}$ by $1$.
\end{itemize}

\end{enumerate}

\item The arbiter at time $\texttt{K}_{\scriptscriptstyle 6}$ sends $[y_{\scriptscriptstyle\mathcal C},y_{\scriptscriptstyle\mathcal S},  y'_{\scriptscriptstyle\mathcal C},y'_{\scriptscriptstyle\mathcal S}]$  to SC who accordingly overwrites the  elements it holds (i.e. elements of $\bm{y}$) by  the related vectors elements the arbiter sent. 

\end{enumerate} %%%%%%%%%

\

\item \textbf{Coin Transfer}. \label{RCPoRP::CoinTransfer} $\mathtt{RCPoRP}.\mathtt{pay}(\bm{y},T_{\scriptscriptstyle cp},a,p_{\scriptscriptstyle\mathcal S}, coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C},coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S})$
\begin{enumerate}


 \item If SC  receives  ``pay'' message  at time $\texttt{T}_{\scriptscriptstyle 2}$, where $a=0$ or $coins^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal{S}}<p_{\scriptscriptstyle\mathcal{S}}$, then it sends $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}$ coins to $\mathcal C$ and $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$. Otherwise (i.e. they reach an agreement), they take the following step. 

\item Either $\mathcal C$ or $\mathcal S$ sends ``pay'' message and  statement $\ddot{x}_{\scriptscriptstyle cp}\in T_{\scriptscriptstyle cp}$ to SC at time $\texttt{L}>\texttt{K}_{\scriptscriptstyle 6}$
\item SC checks the validity of the statement by sending it  to SAP contract that  returns  either $1$ or $0$. SC only proceeds to the next step if the output is $1$
\item SC distributes the coins to the parties as follows:

\begin{itemize}
\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$
\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})-l(y_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$
\item[$\bullet$] $l(y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C}+y'_{\scriptscriptstyle\mathcal S}+y'_{\scriptscriptstyle\mathcal C})$ coins to the arbiter. 


%\item[$\bullet$]   $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l(y_{\scriptscriptstyle\mathcal S}-y_{\scriptscriptstyle\mathcal C})$ coins  to $\mathcal C$
%
%\item[$\bullet$] $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l( y_{\scriptscriptstyle\mathcal C}-y_{\scriptscriptstyle\mathcal S})$ coins to $\mathcal S$
%\item[$\bullet$] $l(u_{\scriptscriptstyle\mathcal S}+u_{\scriptscriptstyle\mathcal C}+y_{\scriptscriptstyle\mathcal S}+y_{\scriptscriptstyle\mathcal C})$ coins to the arbiter.  
\end{itemize}

\end{enumerate}
\end{enumerate}


\begin{remark}
The reason in step \ref{dummy-vector} vector $ {\bm{\pi}}''_{\scriptscriptstyle i}$ is constructed  is to let SC make \emph{black-box}  use of $\mathtt{PoRID.identify}(.)$. Alternatively, SC could decrypt all proofs in $\mathtt{Enc}(\bar{k}, {\bm{\pi}}_{\scriptscriptstyle i})$ and pass them to $\mathtt{PoRID.identify}(.)$. However, this approach would impose a high cost, as all proofs have to be decrypted. 
\end{remark}

\begin{remark}
In general, a transaction that is sent   to a smart contract should  cover the cost of the contract's execution. Therefore, in the above protocol, if a party unnecessarily invokes a contract for an accepting proof, it has to pay the execution cost in advance. This is the reason the above protocol (unlike RC-S-P protocol) does not need to track the number of times a party unnecessarily invokes the contract.    
\end{remark}


\begin{remark}
\textcolor{purple}{Explain how we can slight modify the protocol to capture the fact  that the amounts of coin the client pays for a dispute resolution is different to the amount paid by the server to resolve a dispute. The idea is we introduce another value $l'$, we let $l$ and $l'$ be the amount of coin the client and server pay to resolve a dispute.  We add $l'$ to $cp$. Accordingly, we would have $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal C}-o(z-y_{\scriptscriptstyle\mathcal S})+l'\cdot y_{\scriptscriptstyle\mathcal S}-l\cdot y_{\scriptscriptstyle\mathcal C}$ coins  to $\mathcal C$ and  $coin^{\scriptscriptstyle *}_{\scriptscriptstyle\mathcal S}+o(z-y_{\scriptscriptstyle\mathcal S})+l\cdot y_{\scriptscriptstyle\mathcal C}-l'\cdot y_{\scriptscriptstyle\mathcal S}$ coins to $\mathcal S$}
\end{remark}


\subsubsection{Delegating the Arbiter's Role to  a Smart Contract}

In the above protocol, due to the efficiency of arbiter-side algorithm, i.e. $\mathtt{RCSPoR.resolve}(.)$,  we can  totally delegate the arbiter’s role to the smart contract, SC. In this case, the involvement of the third-party arbiter is not needed anymore.  However, to have the new variant of RC-PoR-P,   some adjustments need to be applied to the original RC-PoR-P’s protocol and definition, primarily from  two  perspectives. First,    the way a party pays to resolve a dispute would change that ultimately affects the amounts of coin each party receives at the coin distribution phase. Recall, in the RC-PoR-P and RC-S-P (presented in sections \ref{sec::RC-PoR-P-protocol} and \ref{sec::RC-S-P-protocol} respectively)  the party who raises dispute does not pay the arbiter when it sends to it a dispute query. Instead, loosely speaking, the arbiter at the coin distribution phase is paid by a misbehaving party. In contrast, when the arbiter’s role is played by a smart contract, the party who raises dispute and sends a dispute query to the contract (due to the nature of smart contracts' platform) has to pay the contract before the contract processes its query. This means, an honest party who sends a complaint to the contract needs to be compensated (by the corrupt party) for the amounts  of coin it sent to the contract to resolve the dispute. Therefore, the amounts of coin each party receives at the coin distribution phase would change, compare to the original RC-PoR-P protocol. Second, there would be no need to keep track of the number of times a party unnecessarily raises a dispute, as it pays the contract when it sends a query, before the contract processes its claim. In Appendix \ref{sec::RC-S-P-Definition2}, we provide a generic definition for RC-S-P for the case where the arbiter's role can be played by a smart contract. The generic definition also captures the new variant of RC-PoR-P. Moreover, in Appendix \ref{sec::R-PoR-P-protocol-Withohut-Arbiter}, we elaborate on how  the new variant of RC-PoR-P can be constructed and we prove its security.  

 
% \input{RCPoRP-Proof}


%\in[ut{RC-PoR-P-Definition}

%\input{RC-PoR-P-Proof}



