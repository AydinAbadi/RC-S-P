% !TEX root =R-zkCSP.tex


\section{VSID Protocol}


In this section, we present the VSID protocol. We show how it  can be built upon a protocol that realises the VS definition.  As stated previously, VS scheme inherently protects an honest client from a malicious server. Therefore, at a high-level, VSID needs to have two added features; namely, it protects an honest server from a malicious client and allows an arbiter to detect a corrupt party. VSID can be built upon VS using  the following standard techniques; Briefly, (a) all parties sign their outgoing messages, (b) they post the signed messages on a bulletin board, and (c) the client, using a non-interactive publicly verifiable zero-knowledge scheme, proves to the server that its inputs have been correctly constructed.   In particular, like VS, the client first generates its secret and public parameters and then, in the setup, it encodes its input: $u$ using the encoding function $M$. This results in a  metadata.  Also, the client   utilises a non-interactive publicly verifiable zero-knowledge scheme to prove to the server that the metadata has been constructed correctly.  The client posts $u$, metadata and the poofs along with their signatures to a bulletin board. Next, the server verifies the signatures and proofs. It  agrees to serve the client, if they are accepted.  Like VS, when the client wants the server to run  function $F$ on its input $u$, it uses  function $Q$ to generate a query. But, it uses the zero-knowledge scheme to prove to the server that the query has been constructed correctly. The client posts the query,  proofs, and their signatures to the board. After that, the server verifies the  signatures and proofs. The server-side prove  and client-side verify algorithms remain unchanged with a difference that the server posts its proofs (i.e. output of prove algorithm) and thier signatures to the board and the client first verifies the signatures before checking the proofs.  In the case of any dispute/abort, either party invokes the arbiter who, given the signed posted messages,  checks the signatures and proofs in turn to identify a corrupt party. Below, we present VSID protocol in which we assume all parties sign their outgoing messages and their counter-party first verify the signature on the messages, before they  fed them to their local algorithms. %Also, to let the protocol  terminate within a fixed time, we require that each party send out its message within a certain time, after the client sends out its  messages. 

%However, if $M$ takes as inputs private parameters, then the client commits to the parameters and  


\begin{enumerate}
\item\textbf{Key Generation}\label{VSID::keygen}. $\mathtt{VSID.keyGen}(1^{\lambda},F)$ 
\begin{enumerate}
\item Calls  $\mathtt{VS.keyGen}(1^{\lambda},F)$ to generate a pair of secret and public keys, $k:(sk,pk)$
\item Commits to the secret key and appends the commitment: $\mathtt{Com}_{\scriptscriptstyle sk}$ to $pk$
%\item Commits to the secret keys: $sk\in k$. This yields: $\mathtt{Com}(sk)$.
\item Posts $pk$ to a bulletin board. %Now on, all parties consider this as $pk$.  
\end{enumerate}

\

\item\textbf{Client-side Setup}\label{VSID::Client-side-Setup}. $\mathtt{VSID.setup}(1^{\lambda}, u,k,M)$
\begin{enumerate}
\item Calls  $\mathtt{VS.setup}(1^{\lambda}, u,k,M)\rightarrow (\sigma,u^{\scriptscriptstyle *})$, to generate a   metadata: $\sigma=M(u^{\scriptscriptstyle *},k,{pp})$, encoded file service input and { (input dependent) parameters $pp$}. %It may add more parameters, e.g. file size, to $pk$. 


\item Generates non-interactive publicly verifiable zero-knowledge proofs asserting  $\sigma$ has been generated correctly, i.e. $\sigma$ is the output of  $M$ that is evaluated on $u^{\scriptscriptstyle *}$, $pk$,  $sk$, and {$pp$} without revealing $sk$. Let $w_{\scriptscriptstyle\sigma}$ contains the proofs.
\item\label{vsid::post-metadata} Posts $ e:=(\sigma,w_{\scriptscriptstyle\sigma})$, {$pp$},  and $u^{\scriptscriptstyle *}$ to the bulletin board. 
\end{enumerate}

\

\item\textbf{Server-side Setup}. $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk,{pp})$

Ensures the metadata $\sigma$ has been constructed correctly, by verifying the proofs in $w_{\sigma}$ (where $\sigma,w_{\scriptscriptstyle\sigma}\in e$). If the proofs are accepted, then it outputs $a=1$  and proceeds to the next step; otherwise, it outputs $a=0$ and halts. 
%\item\label{Server-side Setup-post} At time $P_0$ posts $1$ to the board,  if the proofs are accepted; otherwise, it posts $0$ to the board.  

\

\item\textbf{Client-side Query Generation}\label{VSID::Client-side-QueryGeneration}. $\mathtt{VSID.genQuery}(1^{\lambda},  \text{aux},k,Q,{pp} )$ 
\begin{enumerate}
\item Calls $\mathtt{VS.genQuery}(1^{\lambda}, \text{aux},k,Q,{pp} )\rightarrow \bm{q}$, to generate a query vector, $\bm{q}=Q(\text{aux},k,{pp})$. If $\text{aux}$ is a private input, then it also commits to it,  that yields  $\mathtt{Com}_{\scriptscriptstyle \text{aux}}$
\item Generates non-interactive publicly verifiable zero-knowledge proofs proving $\bm{q}$ has been generated correctly, i.e. $\bm{q}$ is the
output of $Q$ which is evaluated on $\text{aux}$, $pk$, $sk$, and $pp$ without revealing $sk$ (and $\text{aux}$, if it is a private input). Let $\bm{w}_{\scriptscriptstyle q}$ contain the proofs and  $\text{aux}$ (or  $\mathtt{Com}_{\scriptscriptstyle \text{aux}}$ if $\text{aux}$ is a private input).
%\item At time $P_1$ posts $c:(q,w_{q})$ to the board 
\item Posts $c:(\bm{q},\bm{w}_{\scriptscriptstyle q})$ to the board 
\end{enumerate}

\

\item\textbf{Server-side Query Verification}. $\mathtt{VSID.checkQuery}(c, pk, {pp})$

Checks if   the query: $\bm{q}\in c$ has been constructed correctly by verifying the proofs  $\bm{w}_{\scriptscriptstyle q}\in c$. If the check passes, then it outputs $b=1$; otherwise, it outputs $b=0$

  

\

\item\textbf{Server-side Service Proof Generation}. $\mathtt{VSID.prove}(u^{\scriptscriptstyle *},\sigma,c,pk,{pp} )$ This phase starts only if the query was accepted, i.e. $b=1$ 
\begin{enumerate}
\item Calls $\mathtt{VS.prove}(u^{\scriptscriptstyle *},\sigma, \bm{q},pk,{pp})\rightarrow \pi$, to generate $\pi:=(F(u^{\scriptscriptstyle *},\bm{q},{pp}),\delta)$. Recall that $\bm{q}\in c$
\item Posts $\pi$ to the board. 
%\item At time $P_2$ posts $\pi$ to the board. 
\end{enumerate}

\

\item\textbf{Client-side Proof Verification}. $\mathtt{VSID.verify}(\pi,\bm{q},k,{pp})$

Calls $\mathtt{VS.verify}(\pi,\bm{q},k,{pp})\rightarrow d$, to verify  proof $\pi$. It accepts the proof if $d=1$; otherwise, it rejects it. 



\

\item\textbf{Arbiter-side Identification}. $\mathtt{VSID.identify}(\pi,c,k,e,u^{\scriptscriptstyle *},{pp})$ 
\begin{enumerate}


\item\label{Arb-VSID.serve} Calls $\mathtt{VSID.serve}(u^{\scriptscriptstyle *},e,pk,{pp})\rightarrow a$. If $a=1$, then it proceeds to the next step. Otherwise, it outputs $I=\mathcal C$ and halts. 

\item Calls $\mathtt{VSID.checkQuery}(c, pk,{pp})\rightarrow b$. If $b=1$, then it proceeds to the next step. Otherwise, it outputs $I=\mathcal C$ and halts. 

\item  If $\pi$ is  privately verifiable, then the arbiter  first checks if $sk\in k$ (provided by the client along with other opening information) matches $\mathtt{Com}_{\scriptscriptstyle sk}\in pk$. If they do not match, then the arbiter outputs $I=\mathcal C$. Otherwise,  it calls $\mathtt{VS.verify}(\pi, \bm{q},k,{pp})\rightarrow d$. If $d=1$, then it outputs $I=\bot$; otherwise, it outputs $I=\mathcal S$
\end{enumerate}
\end{enumerate}




\begin{theorem}
The VSID protocol satisfies the soundness, inputs well-formedness, and detectable abort properties, w.r.t. Definitions \ref{deff::VSID-Soundness}-\ref{def::VSID-Identifiable-Abort}, if the commitment, non-interactive publicly verifiable zero-knowledge, VS, and signature schemes are secure. 
\end{theorem}

\input{VSID-Proof}


\begin{remark}\label{remark::light-VSID}
As we mentioned before, often it is sufficient  to let the arbiter pinpoint a corrupt party \emph{after} the client and server agree to deal with each other. We denoted a VSID protocol that meets the latter (lighter) requirement, by $\text{VSID}_{\scriptscriptstyle \text{light}}$. This  version would impose lower costs, when $u$ and elements of $e$ are of large size. In  $\text{VSID}_{\scriptscriptstyle \text{light}}$ protocol, the client and server  run phases 1-3 of the VSID protocol as before, with a difference that the client does not post $e$ and $u^{\scriptscriptstyle*}$ to the board; instead, it sends them directly to the server. In $\text{VSID}_{\scriptscriptstyle\text{light}}$  the arbiter algorithm, i.e. $\mathtt{VSID.identify}(.)$, needs to take only $(\pi,c,k,e',{pp})$ as input, where $e'$ contains the opening of $\mathtt{Com}_{\scriptscriptstyle {sk}}$ if $\mathtt{VSID.verify}(.)$ is privately verifiable or $e'=\bot$ if  it is publicly verifiable. In this light version, the arbiter   skips step \ref{Arb-VSID.serve}. Thus, $\text{VSID}_{\scriptscriptstyle\text{light}}$ saves (a)  communication cost, as   $u^{\scriptscriptstyle*}$ and $e$ are never sent to the board and  arbiter, and (b) computation  cost as the arbiter does not need to run $\mathtt{VSID.serve}(.)$ anymore. 
\end{remark}







